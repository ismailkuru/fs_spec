<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#interactive-top-level-directives">Interactive top-level directives</a></li>
<li><a href="#fs_spec.ml">fs_spec.ml</a><ul>
<li><a href="#fs_types1">Fs_types1</a></li>
<li><a href="#resolve-names">Resolve names</a></li>
<li><a href="#fs_ops2"><code>Fs_ops2</code></a></li>
<li><a href="#fs-transition-system">Fs transition system</a></li>
<li><a href="#os-transition-system">OS transition system</a></li>
<li><a href="#fs_spec_everything"><code>Fs_spec_everything</code></a></li>
<li><a href="#debug">Debug</a></li>
</ul></li>
</ul>
</div>
<h1 id="interactive-top-level-directives"><a href="#interactive-top-level-directives">Interactive top-level directives</a></h1>
<p>Via findlib:</p>
<pre><code>#use &quot;topfind&quot;;;
#require &quot;unix&quot;;;
#require &quot;bigarray&quot;;;
#require &quot;str&quot;;;
(* #cd &quot;/tmp/l/general/research/fs/fs_spec/src&quot;;; *)
#use &quot;fs_prelude.toplevel.ml&quot;;;
#use &quot;fs_spec.toplevel.ml&quot;;;
open Fs_prelude;;
open Fs_spec;;
open Fs_spec_everything;;</code></pre>
<h1 id="fs_spec.ml"><a href="#fs_spec.ml">fs_spec.ml</a></h1>
<h2 id="fs_types1"><a href="#fs_types1">Fs_types1</a></h2>
<p>Types common to all implementations of the basic operations</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">
<span class="ot">open</span> Fs_prelude

<span class="co">(* as an optimization, we expect that each of these refs is actually a ref to a sector *)</span>

<span class="ot">module</span> Fs_types1 = <span class="kw">struct</span>

  <span class="ot">open</span> Prelude

  <span class="kw">type</span> num = <span class="dt">int</span> <span class="co">(* FIXME; also fix uses of type int below to be num where appropriate *)</span>

  <span class="kw">type</span> bytes = MyDynArray<span class="kw">.</span>t
  <span class="kw">type</span> name = <span class="dt">string</span> <span class="co">(* shortest component of a filename - doesn&#39;t include /; may be empty; may be . or .. *)</span>

  <span class="kw">type</span> error =
      <span class="dt">E2BIG</span>
    | <span class="dt">EACCES</span>
    | <span class="dt">EAGAIN</span>
    | <span class="dt">EBADF</span>
    | <span class="dt">EBUSY</span>
    | <span class="dt">ECHILD</span>
    | <span class="dt">EDEADLK</span>
    | <span class="dt">EDOM</span>
    | <span class="dt">EEXIST</span>
    | <span class="dt">EFAULT</span>
    | <span class="dt">EFBIG</span>
    | <span class="dt">EINTR</span>
    | <span class="dt">EINVAL</span>
    | <span class="dt">EIO</span>
    | <span class="dt">EISDIR</span>
    | <span class="dt">EMFILE</span>
    | <span class="dt">EMLINK</span>
    | <span class="dt">ENAMETOOLONG</span>
    | <span class="dt">ENFILE</span>
    | <span class="dt">ENODEV</span>
    | <span class="dt">ENOENT</span>
    | <span class="dt">ENOEXEC</span>
    | <span class="dt">ENOLCK</span>
    | <span class="dt">ENOMEM</span>
    | <span class="dt">ENOSPC</span>
    | <span class="dt">ENOSYS</span>
    | <span class="dt">ENOTDIR</span>
    | <span class="dt">ENOTEMPTY</span>
    | <span class="dt">ENOTTY</span>
    | <span class="dt">ENXIO</span>
    | <span class="dt">EPERM</span>
    | <span class="dt">EPIPE</span>
    | <span class="dt">ERANGE</span>
    | <span class="dt">EROFS</span>
    | <span class="dt">ESPIPE</span>
    | <span class="dt">ESRCH</span>
    | <span class="dt">EXDEV</span>
    | <span class="dt">EWOULDBLOCK</span>
    | <span class="dt">EINPROGRESS</span>
    | <span class="dt">EALREADY</span>
    | <span class="dt">ENOTSOCK</span>
    | <span class="dt">EDESTADDRREQ</span>
    | <span class="dt">EMSGSIZE</span>
    | <span class="dt">EPROTOTYPE</span>
    | <span class="dt">ENOPROTOOPT</span>
    | <span class="dt">EPROTONOSUPPORT</span>
    | <span class="dt">ESOCKTNOSUPPORT</span>
    | <span class="dt">EOPNOTSUPP</span>
    | <span class="dt">EPFNOSUPPORT</span>
    | <span class="dt">EAFNOSUPPORT</span>
    | <span class="dt">EADDRINUSE</span>
    | <span class="dt">EADDRNOTAVAIL</span>
    | <span class="dt">ENETDOWN</span>
    | <span class="dt">ENETUNREACH</span>
    | <span class="dt">ENETRESET</span>
    | <span class="dt">ECONNABORTED</span>
    | <span class="dt">ECONNRESET</span>
    | <span class="dt">ENOBUFS</span>
    | <span class="dt">EISCONN</span>
    | <span class="dt">ENOTCONN</span>
    | <span class="dt">ESHUTDOWN</span>
    | <span class="dt">ETOOMANYREFS</span>
    | <span class="dt">ETIMEDOUT</span>
    | <span class="dt">ECONNREFUSED</span>
    | <span class="dt">EHOSTDOWN</span>
    | <span class="dt">EHOSTUNREACH</span>
    | <span class="dt">ELOOP</span>
    | <span class="dt">EOVERFLOW</span>
    | <span class="dt">EUNKNOWNERR</span> <span class="kw">of</span> <span class="dt">int</span>
 
  <span class="co">(* from unix.mli *)</span>
  <span class="kw">type</span> open_flag =
      <span class="dt">O_RDONLY</span>                    <span class="co">(** Open for reading *)</span>
    | <span class="dt">O_WRONLY</span>                    <span class="co">(** Open for writing *)</span>
    | <span class="dt">O_RDWR</span>                      <span class="co">(** Open for reading and writing *)</span>
    | <span class="dt">O_NONBLOCK</span>                  <span class="co">(** Open in non-blocking mode *)</span>
    | <span class="dt">O_APPEND</span>                    <span class="co">(** Open for append *)</span>
    | <span class="dt">O_CREAT</span>                     <span class="co">(** Create if nonexistent *)</span>
    | <span class="dt">O_TRUNC</span>                     <span class="co">(** Truncate to 0 length if existing *)</span>
    | <span class="dt">O_EXCL</span>                      <span class="co">(** Fail if existing *)</span>
    | <span class="dt">O_NOCTTY</span>                    <span class="co">(** Don&#39;t make this dev a controlling tty *)</span>
    | <span class="dt">O_DSYNC</span>                     <span class="co">(** Writes complete as `Synchronised I/O data</span>
<span class="co">                                     integrity completion&#39; *)</span>
    | <span class="dt">O_SYNC</span>                      <span class="co">(** Writes complete as `Synchronised I/O file</span>
<span class="co">                                     integrity completion&#39; *)</span>
    | <span class="dt">O_RSYNC</span>                     <span class="co">(** Reads complete as writes (depending on</span>
<span class="co">                                     O_SYNC/O_DSYNC) *)</span>
    | <span class="dt">O_SHARE_DELETE</span>              <span class="co">(** Windows only: allow the file to be deleted</span>
<span class="co">                                   while still open *)</span>

  <span class="kw">type</span> file_perm = <span class="dt">int</span>


  <span class="kw">type</span> file_kind = 
    <span class="dt">S_REG</span>                       <span class="co">(** Regular file *)</span>
  | <span class="dt">S_DIR</span>                       <span class="co">(** Directory *)</span>
  | <span class="dt">S_LNK</span>                       <span class="co">(** Symbolic link *)</span>


  


  <span class="co">(* top-level labels, intended to mirror the syscalls, but with functional interface; TODO need to incorporate file descriptors, &quot;current position&quot; etc *)</span>
  <span class="kw">type</span> ty_label = 
    | <span class="dt">LINK</span> <span class="kw">of</span> (<span class="dt">string</span> * <span class="dt">string</span>)
    | <span class="dt">MKDIR</span> <span class="kw">of</span> (<span class="dt">string</span> * file_perm)
    | <span class="dt">OPEN</span> <span class="kw">of</span> (<span class="dt">string</span> * open_flag <span class="dt">list</span>)
    | <span class="dt">READ</span> <span class="kw">of</span> (<span class="dt">string</span> * <span class="dt">int</span> * <span class="dt">int</span>)
    | <span class="dt">READDIR</span> <span class="kw">of</span> <span class="dt">string</span>
    | <span class="dt">RENAME</span> <span class="kw">of</span> (<span class="dt">string</span> * <span class="dt">string</span>)
    | <span class="dt">RMDIR</span> <span class="kw">of</span> <span class="dt">string</span>
    | <span class="dt">STAT</span> <span class="kw">of</span> <span class="dt">string</span>
    | <span class="dt">SYMLINK</span> <span class="kw">of</span> (<span class="dt">string</span> * <span class="dt">string</span>)
    | <span class="dt">TRUNCATE</span> <span class="kw">of</span> (<span class="dt">string</span> * <span class="dt">int</span>)
    | <span class="dt">UNLINK</span> <span class="kw">of</span> <span class="dt">string</span>
    | <span class="dt">WRITE</span> <span class="kw">of</span> (<span class="dt">string</span> * <span class="dt">int</span> * bytes * <span class="dt">int</span>)


  <span class="kw">type</span> file_contents = bytes <span class="co">(* really a map from index to ... *)</span>

  <span class="kw">type</span> ret_value = <span class="dt">None1</span> | <span class="dt">Int1</span> <span class="kw">of</span> <span class="dt">int</span> | <span class="dt">Bytes1</span> <span class="kw">of</span> bytes <span class="co">(* FIXME add init return type *)</span> | <span class="dt">Names1</span> <span class="kw">of</span> name <span class="dt">list</span>
    | <span class="dt">Stats1</span> <span class="kw">of</span> Unix<span class="kw">.</span>LargeFile<span class="kw">.</span>stats
  <span class="kw">let</span> dest_bytes1 (<span class="dt">Bytes1</span> bs) = bs
 
  <span class="co">(* names types; also type name earlier *)</span>
  
  <span class="co">(* following moved from ops parser *)</span>
  <span class="kw">type</span> dirname = <span class="dt">string</span> <span class="dt">list</span>
  <span class="kw">type</span> filename = <span class="dt">string</span> <span class="dt">list</span> <span class="co">(* non-empty *)</span>

  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref) entry = (&#39;dir_ref,&#39;inode_ref) sum
  <span class="kw">let</span> is_dir_ref_entry = is_Inl
  <span class="kw">let</span> is_inode_ref_entry = is_Inr
  <span class="kw">let</span> dest_dir_ref_entry = dest_Inl
  <span class="kw">let</span> dest_inode_ref_entry = dest_Inr

  <span class="co">(* break the string into components *)</span>
  <span class="kw">type</span> ty_name_list = {
    ns2: name <span class="dt">list</span>; <span class="co">(* invariant: not [] *)</span>
  }
  <span class="co">(* let ends_with_slash nl = nl.ends_with_slash2 *)</span>

  <span class="co">(* process . and .. and empty entries relative to a cwd *)</span>
  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref) ty_realpath1 = {
    cwd3: &#39;dir_ref; <span class="co">(* cwd for process *)</span>
    nl3: ty_name_list; <span class="co">(* the original string *)</span>
    ns3: name <span class="dt">list</span>; <span class="co">(* invariant: not []; first entry is empty; no . and .. entries; no further empty entries (absolute paths) *)</span>
    <span class="co">(* FIXME we don&#39;t need e3  if we are interested in paths *)</span>                                  
                                  <span class="co">(* e3: ((&#39;dir_ref,&#39;inode_ref) entry,name)sum (* inr means that the path might target a non-existent file or directory, but everything else resolved *) *)</span>
  }
  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref) ty_realpath = <span class="dt">OK1</span> <span class="kw">of</span> (&#39;dir_ref,&#39;inode_ref) ty_realpath1 | <span class="dt">Err1</span> <span class="kw">of</span> (error * ty_name_list)
                       
  <span class="co">(* resolved name relative to a state *)</span>
  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref) res_name = 
    <span class="dt">Dname2</span> <span class="kw">of</span> (&#39;dir_ref * (&#39;dir_ref,&#39;inode_ref) ty_realpath1)
  | <span class="dt">Fname2</span> <span class="kw">of</span> (&#39;dir_ref * name * &#39;inode_ref * (&#39;dir_ref,&#39;inode_ref) ty_realpath1)
  | <span class="dt">None2</span> <span class="kw">of</span> (&#39;dir_ref * name * (&#39;dir_ref,&#39;inode_ref) ty_realpath1)
  | <span class="dt">Err2</span> <span class="kw">of</span> (error * ty_name_list)
  <span class="co">(* invariant: if Fname2 ns, then not (ns.ends_with_slash2) *)</span>
  <span class="co">(* invariant: if Err2 then ns.ends_with_slash2 *)</span>
  <span class="co">(* FIXME since these are resolved, we may want to include the i0_ref and d0_ref *)</span>

  <span class="kw">let</span> is_Err2 x = (<span class="kw">match</span> x <span class="kw">with</span> | <span class="dt">Err2</span> _ -&gt; <span class="kw">true</span> | _ -&gt; <span class="kw">false</span>)

  <span class="kw">let</span> name_list_of_res_name n = (<span class="kw">match</span> n <span class="kw">with</span> 
    | <span class="dt">Dname2</span> (_,rp) -&gt; rp.nl3
    | <span class="dt">Fname2</span> (_,_,_,rp) -&gt; rp.nl3
    | <span class="dt">None2</span> (_,_,rp) -&gt; rp.nl3
    | <span class="dt">Err2</span> (_,nl) -&gt; nl)
 
  <span class="kw">let</span> string_of_names ns = (String<span class="kw">.</span>concat <span class="st">&quot;/&quot;</span> ns)

  <span class="kw">let</span> string_of_res_name n = (
    <span class="kw">let</span> nl = name_list_of_res_name n <span class="kw">in</span>
    string_of_names nl.ns2)


  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref) ty_fs_label = 
    | <span class="dt">FS_LINK</span> <span class="kw">of</span> ((&#39;dir_ref,&#39;inode_ref) res_name * (&#39;dir_ref,&#39;inode_ref) res_name)
    | <span class="dt">FS_MKDIR</span> <span class="kw">of</span> ((&#39;dir_ref,&#39;inode_ref) res_name * file_perm)
    | <span class="dt">FS_OPEN</span> <span class="kw">of</span> ((&#39;dir_ref,&#39;inode_ref) res_name * open_flag <span class="dt">list</span>)
    | <span class="dt">FS_READ</span> <span class="kw">of</span> ((&#39;dir_ref,&#39;inode_ref) res_name * <span class="dt">int</span> * <span class="dt">int</span>)
    | <span class="dt">FS_READDIR</span> <span class="kw">of</span> (&#39;dir_ref,&#39;inode_ref) res_name
    | <span class="dt">FS_RENAME</span> <span class="kw">of</span> ((&#39;dir_ref,&#39;inode_ref) res_name * (&#39;dir_ref,&#39;inode_ref) res_name)
    | <span class="dt">FS_RMDIR</span> <span class="kw">of</span> (&#39;dir_ref,&#39;inode_ref) res_name
    | <span class="dt">FS_STAT</span> <span class="kw">of</span> (&#39;dir_ref,&#39;inode_ref) res_name
    | <span class="dt">FS_SYMLINK</span> <span class="kw">of</span> ((&#39;dir_ref,&#39;inode_ref) res_name * <span class="dt">string</span>)
    | <span class="dt">FS_TRUNCATE</span> <span class="kw">of</span> ((&#39;dir_ref,&#39;inode_ref) res_name * <span class="dt">int</span>)
    | <span class="dt">FS_UNLINK</span> <span class="kw">of</span> (&#39;dir_ref,&#39;inode_ref) res_name
    | <span class="dt">FS_WRITE</span> <span class="kw">of</span> ((&#39;dir_ref,&#39;inode_ref) res_name * <span class="dt">int</span> * bytes * <span class="dt">int</span>)


  <span class="co">(*</span>
<span class="co">  let is_None2 x = (match x with None2 _ -&gt; true | _ -&gt; false)</span>
<span class="co">  *)</span>


  <span class="kw">type</span> &#39;impl ty_return2 = {
    state2: &#39;impl;
    ret2: ret_value;
  } 
  <span class="kw">let</span> return s = { state2=s; ret2=None1 }


  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref,&#39;impl) ty_ops1 = {
    get_init_state1: <span class="dt">unit</span> -&gt; &#39;impl;
    get_parent1: &#39;impl -&gt; &#39;dir_ref -&gt; (&#39;dir_ref * name <span class="dt">option</span>); <span class="co">(* parent of root is root; name is none iff root  *)</span>
    get_root1: &#39;impl -&gt; &#39;dir_ref <span class="dt">option</span>;
    dest_dir_ref1: &#39;impl -&gt; &#39;dir_ref -&gt; <span class="dt">int</span>;
    dest_inode_ref1: &#39;impl -&gt; &#39;inode_ref -&gt; <span class="dt">int</span>;
    get_symlink1: &#39;impl -&gt; &#39;inode_ref -&gt; <span class="dt">bool</span>;
    link_file1: &#39;impl -&gt; &#39;inode_ref -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2;
    unlink1: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2;
    mkdir1: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2;
    mv1: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2;
    mvdir1: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2;
    read1: &#39;impl -&gt; &#39;inode_ref -&gt; &#39;impl ty_return2;
    readdir1: &#39;impl -&gt; &#39;dir_ref -&gt; &#39;impl ty_return2; <span class="co">(* don&#39;t return . and .. entries *)</span>
    resolve11: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; (&#39;dir_ref,&#39;inode_ref) entry <span class="dt">option</span>; <span class="co">(* resolves normal entries; use get_parent for .. *)</span>
    rm1: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2; <span class="co">(* FIXME don&#39;t need this and unlink1 *)</span>
    rmdir1: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2; <span class="co">(* FIXME probably don&#39;t need this either *)</span>
    touch1: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2;
    write1: &#39;impl -&gt; &#39;inode_ref -&gt; bytes -&gt; &#39;impl ty_return2;
    set_symlink1: &#39;impl -&gt; &#39;inode_ref -&gt; <span class="dt">bool</span> -&gt; &#39;impl ty_return2;
  }

  <span class="co">(* calls to the fs take place in a process context *)</span>
  <span class="kw">type</span> (&#39;dir_ref,&#39;impl) fs_state_process_state = {
    cwd4: &#39;dir_ref;
    fs_state4: &#39;impl
  }
    


  <span class="co">(* modelling the host *)</span>

  <span class="co">(* process ids *)</span>
  <span class="kw">type</span> ty_pid = <span class="dt">Pid</span> <span class="kw">of</span> num

  <span class="co">(* a process can only make a single call into OS (so, no threads); process is blocked until return *)</span>
  <span class="kw">type</span> os_label = 
    | <span class="dt">OS_CALL</span> <span class="kw">of</span> (ty_pid * ty_label)
    | <span class="dt">OS_RETURN</span> <span class="kw">of</span> (ty_pid * (error,ret_value) sum)
    | <span class="dt">OS_CREATE</span> <span class="kw">of</span> ty_pid
    | <span class="dt">OS_DESTROY</span> <span class="kw">of</span> ty_pid


  <span class="co">(* file descriptors *)</span>
  <span class="kw">type</span> ty_fd = <span class="dt">FD</span> <span class="kw">of</span> num

  <span class="co">(* dir handles *)</span>
  <span class="kw">type</span> ty_dh = <span class="dt">DH</span> <span class="kw">of</span> num

  <span class="co">(* FIXME check this in linux kernel docs *)</span>
  <span class="kw">type</span> fd_open_closed_state = <span class="dt">FD_OPEN</span> | <span class="dt">FD_CLOSED</span>

  <span class="kw">type</span> dh_open_closed_state = <span class="dt">DH_OPEN</span> | <span class="dt">DH_CLOSED</span>

  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref,&#39;impl) fd_state = {
    open_or_closed: fd_open_closed_state;
    inode_ref2: &#39;inode_ref;
    offset: num
  }

  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref,&#39;impl) dh_state = {
    open_or_closed: dh_open_closed_state;
    dir_ref2: &#39;dir_ref;
    offset: num
  }

  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref) ty_pid_run_state = <span class="dt">RUNNING</span> | <span class="dt">BLOCKED_CALL</span> <span class="kw">of</span> (&#39;dir_ref,&#39;inode_ref) ty_fs_label | <span class="dt">PENDING_RETURN</span> <span class="kw">of</span> ((error,ret_value) sum)

  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref,&#39;impl) per_process_state = {
    <span class="co">(* root3: &#39;dir_ref; *)</span> <span class="co">(* process root directory; FIXME not currently implemented *)</span>
    cwd: &#39;dir_ref; <span class="co">(* FIXME rename this *)</span>
    fd_table: (ty_fd,(&#39;dir_ref,&#39;inode_ref,&#39;impl) fd_state) fmap;
    dh_table: (ty_dh,(&#39;dir_ref,&#39;inode_ref,&#39;impl) dh_state) fmap;
    pid_run_state: (&#39;dir_ref,&#39;inode_ref) ty_pid_run_state
  }

  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref,&#39;impl) ty_os_state = {
    pid_table: (ty_pid,(&#39;dir_ref,&#39;inode_ref,&#39;impl) per_process_state) fmap;
    fs_state: &#39;impl <span class="co">(* FIXME index this fieldname *)</span>
  }



<span class="kw">end</span></code></pre>
<h2 id="resolve-names"><a href="#resolve-names">Resolve names</a></h2>
<p>We want to take a string such as <code>/x/y/z/d/</code> and process it:</p>
<ul>
<li>extract the components</li>
<li>record whether the string starts in / (* but maybe vfs ensures all strings start in / *)</li>
<li>record whether the string ends in /</li>
<li>process the string (against the current state) to remove .. and . (providing entries exist; if not return ENOENT; function remove_dot_dotdot) and empty entries</li>
<li>then compare result with the current state to determine whether the string
<ol style="list-style-type: decimal">
<li>ends with a / and matches a dir</li>
<li>ends with a / and matches a file (error)</li>
<li>doesn't end with a slash and matches a file or dir</li>
<li>ends with a slash or not, and doesn't match anything</li>
</ol></li>
</ul>
<p>Proposed processing of last step: Ignoring trailing slash, do we match or not? Yes - check agreement with trailing slash (1) and (2) and (3). No - (4)</p>
<p>--</p>
<p>Update: we first process the string to give a list of entries; /a/b/c -&gt; [&quot;&quot;;&quot;a&quot;;&quot;b&quot;;&quot;c&quot;]; /a/b/c/ -&gt; [&quot;&quot;;&quot;a&quot;;&quot;b&quot;;&quot;c&quot;;&quot;&quot;]; a/b/c -&gt; [&quot;a&quot;;&quot;b&quot;;&quot;c&quot;]; note that [] is not in the range of this function; the empty string &quot;&quot; maps to [&quot;&quot;]. We keep this first list because we may need to examine it at some points. We expect that all paths start with a slash. So we remove the first empty component. We record the last empty component as &quot;ends_with_slash2&quot;</p>
<p>Note that this assumption that the path starts with / is somewhat dangerous because it means that we have to have a prior step which handles empty string. But this prior step may need to raise an error, or it may defer to an error raised at a later stage. So really we can't assume that paths start with a /: the empty string must be dealt with. But we probably can assume that relative paths are processed by appending them to the processes CWD;</p>
<p>what about a relative path that is empty? in this case, it appears that this is returned as an error ENOENT (so the CWD is not appended in this case)</p>
<p>so it appears we need both the path of the process, and the actual path supplied as a parameter to the command (and is there a normal form for the path supplied as CWD?)</p>
<p>interestingly if you delete /tmp/d1 and a process is still in d1, the PWD for that process is /tmp/d1; and in /proc/pid/cwd it says &quot;/tmp/d1 (deleted)&quot;</p>
<p>--</p>
<p>lets move to a list of entries</p>
<p>define functions starts_with, ends_with</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">
<span class="co">(* FIXME tidy this up *)</span>
<span class="ot">module</span> X = <span class="kw">struct</span>

  <span class="ot">open</span> Fs_types1
  
  <span class="co">(* hack to get an abstract state type *)</span>
  <span class="ot">module</span> Y : <span class="kw">sig</span> 
    <span class="kw">type</span> t1
    <span class="kw">type</span> t2
    <span class="kw">type</span> t3
    <span class="kw">type</span> t4
    <span class="kw">type</span> t5
  <span class="kw">end</span> = <span class="kw">struct</span> 
    <span class="kw">type</span> t1 = <span class="dt">int</span>
    <span class="kw">type</span> t2 = <span class="dt">int</span>
    <span class="kw">type</span> t3 = <span class="dt">int</span>
    <span class="kw">type</span> t4 = <span class="dt">int</span>
    <span class="kw">type</span> t5 = <span class="dt">int</span>
  <span class="kw">end</span> 

<span class="kw">end</span>

<span class="ot">module</span> Resolve = <span class="kw">struct</span>
 
  <span class="ot">open</span> Prelude
  <span class="ot">open</span> Fs_types1
<span class="co">(*  open Fs_ops1 *)</span>

  <span class="co">(* for the purposes of type-checking the following defns without spurious type vars *)</span>
  <span class="ot">module</span> XR = <span class="kw">struct</span>
    <span class="co">(* type ty_ops&#39; = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)</span>
    <span class="kw">type</span> ty_ops&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3,X<span class="kw">.</span>Y<span class="kw">.</span>t5) ty_ops1
    <span class="kw">type</span> dir_ref&#39; = X<span class="kw">.</span>Y<span class="kw">.</span>t1
    <span class="kw">type</span> ty_impl&#39; = X<span class="kw">.</span>Y<span class="kw">.</span>t5
    <span class="kw">type</span> inode_ref&#39; = X<span class="kw">.</span>Y<span class="kw">.</span>t3
    <span class="kw">type</span> ty_return&#39; = X<span class="kw">.</span>Y<span class="kw">.</span>t5 ty_return2
    <span class="kw">type</span> rname&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3) res_name
    <span class="kw">type</span> entry&#39; = (dir_ref&#39;,inode_ref&#39;) entry
  <span class="kw">end</span>
  <span class="ot">open</span> XR

  <span class="co">(* we introduce a local type to record the result of trying to resolve a path *)</span>
  <span class="kw">type</span> (&#39;a,&#39;b) ok_or_err = <span class="dt">Ok3</span> <span class="kw">of</span> &#39;a | <span class="dt">Err3</span> <span class="kw">of</span> &#39;b

  <span class="co">(* let file_exists ops s0 ns = (resolve_inode_ref ops s0 ns &lt;&gt; None) *)</span>

  <span class="co">(* get the real path, given a dir_ref *)</span>
  <span class="kw">let</span> <span class="kw">rec</span> real_path_dir_ref ops s0 d0_ref = (
    <span class="kw">match</span> (ops.get_parent1 s0 d0_ref) <span class="kw">with</span>
    | (d1_ref,<span class="dt">None</span>) -&gt; [<span class="st">&quot;&quot;</span>]
    | (d1_ref,<span class="dt">Some</span> n) -&gt; (real_path_dir_ref ops s0 d1_ref)@[n])

  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref) ty_resolve_relative_ok = 
  | <span class="dt">Dir4</span> <span class="kw">of</span> &#39;dir_ref
  | <span class="dt">File4</span> <span class="kw">of</span> (&#39;dir_ref * name * &#39;inode_ref)
  | <span class="dt">None4</span> <span class="kw">of</span> (&#39;dir_ref * name)

  <span class="kw">let</span> <span class="kw">rec</span> resolve_relative ops s0 sofar ns = (
    <span class="kw">match</span> ns <span class="kw">with</span> 
    | [] -&gt; (<span class="dt">Ok3</span>(<span class="dt">Dir4</span>(sofar)))
    | n::ns -&gt; (
      <span class="kw">if</span> (n=<span class="st">&quot;.&quot;</span>) || (n=<span class="st">&quot;&quot;</span>) <span class="kw">then</span> (
        resolve_relative ops s0 sofar ns
      ) <span class="kw">else</span> <span class="kw">if</span> (n=<span class="st">&quot;..&quot;</span>) <span class="kw">then</span> (
        <span class="kw">let</span> (dir_ref,_) = ops.get_parent1 s0 sofar <span class="kw">in</span>
        resolve_relative ops s0 dir_ref ns
      ) <span class="kw">else</span> (
        <span class="kw">let</span> m = ops.resolve11 s0 sofar n <span class="kw">in</span>
        <span class="kw">match</span> m <span class="kw">with</span> 
        | <span class="dt">None</span> -&gt; (
          <span class="kw">if</span> (ns=[] || ns=[<span class="st">&quot;&quot;</span>]) <span class="kw">then</span> <span class="co">(* may end in a slash *)</span>
            <span class="dt">Ok3</span>(<span class="dt">None4</span>(sofar,n))
          <span class="kw">else</span>
            <span class="dt">Err3</span>(<span class="dt">ENOENT</span>))
        | <span class="dt">Some</span> entry -&gt; (
          <span class="kw">match</span> entry <span class="kw">with</span> 
          | <span class="dt">Inr</span> i0_ref -&gt; (
            <span class="kw">if</span> ns=[] <span class="kw">then</span> <span class="co">(* not allowed to end in slash *)</span>
              <span class="dt">Ok3</span>(<span class="dt">File4</span>(sofar,n,i0_ref)) 
            <span class="kw">else</span>
              <span class="dt">Err3</span>(<span class="dt">ENOTDIR</span>))
          | <span class="dt">Inl</span> d0_ref -&gt; (
            resolve_relative ops s0 d0_ref ns)))))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; ty_impl&#39; -&gt; dir_ref&#39; -&gt; name <span class="dt">list</span> -&gt; ((dir_ref&#39;,inode_ref&#39;)ty_resolve_relative_ok,error) ok_or_err) = resolve_relative

  <span class="kw">let</span> process_path1 path = (
    <span class="kw">let</span> p = explode path <span class="kw">in</span>
    <span class="kw">let</span> f1 (ns,cur) c = (<span class="kw">if</span> c=<span class="st">&quot;/&quot;</span> <span class="kw">then</span> (ns@[cur],<span class="st">&quot;&quot;</span>) <span class="kw">else</span> (ns,cur^c)) <span class="kw">in</span>
    <span class="kw">let</span> (ns,cur) = List<span class="kw">.</span>fold_left f1 ([],<span class="st">&quot;&quot;</span>) p <span class="kw">in</span>
    <span class="kw">let</span> ns = ns@[cur] <span class="kw">in</span>
    { ns2=ns })
  <span class="kw">let</span> (_:string -&gt; ty_name_list) = process_path1

 <span class="co">(* assumes root not none *)</span>
 <span class="kw">let</span> process_name_list ops s0 cwd nl = (
   <span class="kw">let</span> root = dest_Some (ops.get_root1 s0) <span class="kw">in</span>
   <span class="kw">if</span> nl.ns2 = [<span class="st">&quot;&quot;</span>] <span class="kw">then</span> <span class="dt">Err2</span>(<span class="dt">ENOENT</span>,nl) <span class="co">(* nl.ns2 was the empty string *)</span>
   <span class="kw">else</span> (
     <span class="kw">let</span> is_absolute_nl = (List<span class="kw">.</span>hd nl.ns2 = <span class="st">&quot;&quot;</span>) <span class="kw">in</span>
     <span class="kw">let</span> r = (
       <span class="kw">if</span> is_absolute_nl <span class="kw">then</span>
         resolve_relative ops s0 root nl.ns2
       <span class="kw">else</span>
         resolve_relative ops s0 cwd nl.ns2)
     <span class="kw">in</span>
     <span class="kw">match</span> r <span class="kw">with</span>
     | <span class="dt">Ok3</span> x -&gt; (
       <span class="kw">match</span> x <span class="kw">with</span>
       | <span class="dt">Dir4</span> d0_ref -&gt; (
         <span class="kw">let</span> rp = { cwd3=cwd; nl3=nl; ns3=(real_path_dir_ref ops s0 d0_ref) } <span class="kw">in</span>
         <span class="dt">Dname2</span>(d0_ref,rp))
       | <span class="dt">File4</span> (d0_ref,n,i0_ref) -&gt; (
         <span class="kw">let</span> rp = { cwd3=cwd; nl3=nl; ns3=((real_path_dir_ref ops s0 d0_ref)@[n]) } <span class="kw">in</span>
         <span class="dt">Fname2</span>(d0_ref,n,i0_ref,rp))
       | <span class="dt">None4</span> (d0_ref,n) -&gt; 
         <span class="kw">let</span> rp = {cwd3=cwd; nl3=nl; ns3=(real_path_dir_ref ops s0 d0_ref)@[n] } <span class="kw">in</span>
         <span class="dt">None2</span> (d0_ref,n,rp))
     | <span class="dt">Err3</span> x -&gt; (<span class="dt">Err2</span>(x,nl))))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; ty_impl&#39; -&gt; dir_ref&#39; -&gt; ty_name_list -&gt; rname&#39;) = process_name_list

  <span class="co">(* guarantees: returns option of Fname or Dname  *)</span>
  <span class="kw">let</span> process_path ops s0 cwd path = (
    <span class="kw">let</span> nl = process_path1 path <span class="kw">in</span>
    <span class="kw">let</span> rn = process_name_list ops s0 cwd nl <span class="kw">in</span>
    rn)  
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; ty_impl&#39; -&gt; dir_ref&#39; -&gt; <span class="dt">string</span> -&gt; rname&#39;) = process_path

  <span class="kw">let</span> process_path_from_root ops s0 path = (
    <span class="kw">let</span> root = dest_Some(ops.get_root1 s0) <span class="kw">in</span>
    process_path ops s0 root path)

  <span class="kw">let</span> ends_with_slash rn = (
    <span class="kw">let</span> nl = name_list_of_res_name rn <span class="kw">in</span>
    last (nl.ns2) = <span class="st">&quot;&quot;</span>)

  <span class="co">(* FIXME we want subsequent defns to work in terms of rname, and possible ty_name_list; we want invariants on these *)</span>

  <span class="co">(* note that true = list_prefix [] [] = list_prefix xs xs; but the semantics checks e.g. whether we are rename something to itself *)</span>
  <span class="kw">let</span> <span class="kw">rec</span> list_prefix xs ys = (
    <span class="kw">match</span> (xs,ys) <span class="kw">with</span>
    | ([],_) -&gt; <span class="kw">true</span>
    | (_,[]) -&gt; <span class="kw">false</span>
    | (x::xs,y::ys) -&gt; (
      <span class="kw">if</span> (x=y) <span class="kw">then</span> list_prefix xs ys <span class="kw">else</span> <span class="kw">false</span>))

  <span class="co">(* check if renaming a dir to a subdir of itself; we expect to check for equality before calling this *)</span>
  <span class="kw">let</span> subdir s d = (
    list_prefix s.ns3 d.ns3)

  <span class="co">(* want to restrict uses of resolve_dir_ref and resolve_inode_ref to this module *)</span>
  <span class="co">(* FIXME check this is never used on the root directory, or get_parent_dir root = root, or maybe return None *)</span>
  <span class="co">(*</span>
<span class="co">  let get_parent_dir ops s0 nl = (</span>
<span class="co">    resolve_dir_ref ops s0 (butlast nl.ns2))</span>
<span class="co">  let (_:ty_ops&#39; -&gt; ty_impl&#39; -&gt; ty_name_list -&gt; dir_ref&#39; option) = get_parent_dir</span>
<span class="co">  *)</span>


<span class="kw">end</span></code></pre>
<h2 id="fs_ops2"><a href="#fs_ops2"><code>Fs_ops2</code></a></h2>
<p>Fs ops is very precise about what each argument is expected to be. Dirnames start and end in <code>/</code>. Filenames must not end in <code>/</code>. We don't check that the target of a <code>mv</code> is empty, or doesn't exist etc. However, at the command line, there is some ambiguity:</p>
<ul>
<li><p>assuming <code>tmp.txt</code> is a file, then <code>mv tmp.txt d</code> will treat <code>d</code> as a file (if no d exists), or as a dir (if d exists and is a dir)</p></li>
<li><p><code>mv tmp.txt d/</code> will treat <code>d/</code> as a dir always</p></li>
</ul>
<p>So some possible sources of ambiguity are:</p>
<ul>
<li><p>is <code>tmp.txt</code> a file or a directory? (if it exists, then it is whatever it is)</p></li>
<li><p>if we mean a dir, we can add a '/', and this makes clear what we mean; if we don't add a '/' then the fs may not know whether we intend a file or directory</p></li>
<li><p>even if we are clear that we mean a dir, there can be multiple interpretations: <code>mv c/ e/</code> renames c to e, providing e doesn't already exist; if e does exist, then c goes into e</p></li>
<li><p><code>mv c/ e/</code> will overwrite a directory <code>e/c</code> if <code>e/c</code> is empty; will fail if <code>e/c</code> is not empty</p></li>
</ul>
<p>At the user level, there is some extra logic which makes commands behave differently eg if the target is absent, or a file, or a directory eg for the command <code>mv src dst</code></p>
<ul>
<li><p>if src is a file, and dst is a dir, then src is moved into dir</p></li>
<li><p>if src if a file and dst is a file, then src is moved over dst (dst is unlinked)</p></li>
<li><p>if src is a dir and dst is a dir, then</p></li>
</ul>
<p>Some criteria:</p>
<ul>
<li><p>src,dst ends in '/'</p></li>
<li><p>src,dst exists/not exists (but how to connect name to entity? the point is that this connection is heuristic in some sense; proposal: given a fordname, check whether a dir exists with that name; if not, attempt to interpret as file)</p></li>
<li><p>src,dst exists and is a file/ is a dir</p></li>
</ul>
<p>Proposed <code>mv</code> processing stages:</p>
<ol style="list-style-type: decimal">
<li><p>if either src or dst is fordname (no trailing /) then try to disambiguate: if directory src exists, then src is a dirname, otherwise filename; from this point onwards, we use &quot;src&quot; to indicate a filename, and &quot;src/&quot; to indicate a dirname</p>
<p><code>mv src dst/</code>: move file src to dst directory; if src doesn't exist, fail; if dst directory doesn't exist, fail</p>
<p><code>mv src/ dst</code>: move directory src to directory dst; dst directory doesn't exist by disambiguation (otherwise the command would have been interpreted as <code>mv src/ dst/</code>); fail if src doesn't exist</p>
<p><code>mv src dst</code>: move file src to file dst; if src doesn't exist, fail</p>
<p><code>mv src/ dst/</code>: if <code>dst</code> exists, then attempt to move dir src to a subdirectory of dst; if <code>dst/src</code> file exists, overwrite; if <code>dst/src</code> dir exists, and is empty, then do the move, otherwise fail</p></li>
</ol>
<p>Note: these options don't even include checking whether src and dst are soft links (which further complicates matters; FIXME we don't deal with soft links at this stage)</p>
<p>For the moment, we content ourselves with the following horrible code...</p>
<p>For <code>Fs_ops2</code> we provide functions from state to Inl of state * err, or Inr of state * ret</p>
<p>--</p>
<p>Invariant: if any exception is raised, the state is not changed</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">
<span class="co">(* FIXME these work in terms of rnames; assumes no Err2 *)</span>
<span class="ot">module</span> Fs_ops2 = <span class="kw">struct</span>
  
  <span class="ot">open</span> Unix <span class="co">(* for st_dev record fields etc *)</span>
  <span class="ot">open</span> LargeFile <span class="co">(* FIXME include stats in Fs_types1? *)</span>

  <span class="ot">open</span> Prelude
  <span class="ot">open</span> Fs_types1
<span class="co">(*  open Fs_ops1 *)</span>
  <span class="co">(* open Resolve *)</span>

<span class="co">(*  let get_parent_dir = Resolve.get_parent_dir</span>
<span class="co">  let resolve_process_path2 = Resolve.process_path2 *)</span>
  <span class="kw">let</span> resolve_subdir = Resolve<span class="kw">.</span>subdir
  <span class="kw">let</span> ends_with_slash = Resolve<span class="kw">.</span>ends_with_slash


  <span class="co">(* type error = Fs_types1.error *)</span>
  <span class="kw">type</span> (&#39;impl,&#39;a) ty_return3 = ((&#39;impl * Fs_types1<span class="kw">.</span>error, &#39;impl * &#39;a) sum) finset
  <span class="co">(* vars u, v used eg for Mymonad u *)</span>
  <span class="kw">type</span> (&#39;impl,&#39;a) mymonad = <span class="dt">Mymonad</span> <span class="kw">of</span> (&#39;impl -&gt; (&#39;impl,&#39;a) ty_return3)
  <span class="kw">let</span> dest_mymonad (<span class="dt">Mymonad</span> u) = u
  <span class="kw">let</span> return x = <span class="dt">Mymonad</span> (<span class="kw">fun</span> s -&gt; finset_insert (<span class="dt">Inr</span>(s,x)) finset_empty)
  <span class="kw">let</span> (_:&#39;a -&gt; (&#39;impl,&#39;a) mymonad) = return

  <span class="co">(* for the purposes of type-checking the following defns without spurious type vars *)</span>
  <span class="co">(* N.B. these dummy X module defns are interesting because they show what types are used in each module *)</span>
  <span class="ot">module</span> X2 = <span class="kw">struct</span>
    <span class="kw">type</span> &#39;a ty_return3&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t5,&#39;a) ty_return3
    <span class="kw">type</span> &#39;a ty_mymonad&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t5,&#39;a) mymonad
    <span class="kw">type</span> res_name&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3) res_name    
    <span class="co">(* type ty_ops&#39; = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)</span>
    <span class="kw">type</span> ty_ops&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3,X<span class="kw">.</span>Y<span class="kw">.</span>t5) ty_ops1
  <span class="kw">end</span>
  <span class="ot">open</span> X2

  <span class="kw">let</span> bind u f = <span class="dt">Mymonad</span> (<span class="kw">fun</span> s0 -&gt;
    <span class="kw">let</span> u = dest_mymonad u <span class="kw">in</span>
    <span class="kw">let</span> rs = u s0 <span class="kw">in</span>
    <span class="kw">let</span> f1 v = (<span class="kw">match</span> v <span class="kw">with</span> 
      | <span class="dt">Inl</span> x -&gt; (finset_singleton (<span class="dt">Inl</span> x))
      | <span class="dt">Inr</span> (s,x) -&gt; (
        <span class="kw">let</span> v = dest_mymonad (f x) <span class="kw">in</span>
        v s))
    <span class="kw">in</span>
    <span class="kw">let</span> rs&#39; = finset_image f1 rs <span class="kw">in</span>
    <span class="kw">let</span> rs&#39;&#39; = finset_bigunion rs&#39; <span class="kw">in</span>
    rs&#39;&#39;)    
  <span class="kw">let</span> (_: &#39;a ty_mymonad&#39; -&gt; (&#39;a -&gt; &#39;b ty_mymonad&#39;) -&gt; &#39;b ty_mymonad&#39;) = bind

  <span class="co">(* FIXME we also want to bake in that as soon as we have an exception, we will not alter the state further *)</span>

  <span class="kw">let</span> ( &gt;&gt;= ) = bind
  
  <span class="kw">let</span> get_state = <span class="dt">Mymonad</span> (<span class="kw">fun</span> (s) -&gt; finset_singleton(<span class="dt">Inr</span>(s,s)))
  <span class="kw">let</span> put_state s0 = <span class="dt">Mymonad</span> (<span class="kw">fun</span> (s) -&gt; finset_singleton(<span class="dt">Inr</span>(s0,<span class="dt">None1</span>)))
  <span class="kw">let</span> myraise e = <span class="dt">Mymonad</span> (<span class="kw">fun</span> (s) -&gt; finset_singleton(<span class="dt">Inl</span>(s,e)))
  <span class="kw">let</span> maybe_raise e = <span class="dt">Mymonad</span> (<span class="kw">fun</span> (s) -&gt; 
    finset_insert (<span class="dt">Inr</span>(s,())) (finset_singleton(<span class="dt">Inl</span>(s,e))))

  <span class="co">(* bes is a list of (b,e); if exists a b that is true, raise those e&#39;s where b is true, else do nothing *)</span>
  <span class="kw">let</span> cond_raise bes = <span class="dt">Mymonad</span> (<span class="kw">fun</span> s -&gt;
    <span class="kw">let</span> bs = List<span class="kw">.</span>filter (<span class="kw">fun</span> (b,e) -&gt; b=true) bes <span class="kw">in</span>
    <span class="kw">if</span> bs=[] <span class="kw">then</span> 
      finset_singleton(<span class="dt">Inr</span>(s,()))
    <span class="kw">else</span>
      finset_image (<span class="kw">fun</span> (b,e) -&gt; <span class="dt">Inl</span>(s,e)) bs)      

  <span class="kw">let</span> choose xs = <span class="dt">Mymonad</span> (<span class="kw">fun</span> s -&gt; finset_image (<span class="kw">fun</span> x -&gt; <span class="dt">Inr</span>(s,x)) xs)

  <span class="co">(* for a deterministic version, choose some particular value *)</span>
  <span class="kw">let</span> choose xs = <span class="dt">Mymonad</span> (<span class="kw">fun</span> s -&gt; finset_singleton(<span class="dt">Inr</span>(s,finset_choose xs)))

  <span class="kw">let</span> do_nothing = <span class="dt">Mymonad</span> (<span class="kw">fun</span> s -&gt; finset_singleton(<span class="dt">Inr</span>(s,())))

  <span class="kw">let</span> run_mymonad (<span class="dt">Mymonad</span> f) s = (f (s))
  <span class="kw">let</span> (_:(&#39;a,&#39;b) mymonad -&gt; &#39;a -&gt; (&#39;a,&#39;b) ty_return3) = run_mymonad
  
  <span class="co">(*  let is_empty_dir (s0:&#39;impl) ns = failwith &quot;FIXME&quot; *)</span>

  <span class="kw">let</span> default_stats = {
    st_dev = 2049; <span class="co">(* device number FIXME 0? *)</span>
    st_ino = 999; <span class="co">(* inode number FIXME change this for particular file etc *)</span>
    st_kind = Unix<span class="kw">.</span><span class="dt">S_DIR;</span> <span class="co">(* FIXME *)</span>
    st_perm = 0o777; <span class="co">(* ugo+rwx *)</span>
    st_nlink = 2; <span class="co">(* FIXME dummy - for dir should be number of entries + 2 *)</span>
    st_uid = 1000; <span class="co">(* FIXME 0? *)</span>
    st_gid = 1000; 
    st_rdev = 0; <span class="co">(* device minor number *)</span>
    st_size = 4096L; <span class="co">(* FIXME dummy *)</span>
    st_atime = 0.;
    st_mtime = 0.;
    st_ctime = 0.
  }

  <span class="kw">let</span> default_file_stats ops s0 i0_ref = { default_stats <span class="kw">with</span>
    st_ino=(ops.dest_inode_ref1 s0 i0_ref);
    st_kind=(
      <span class="kw">if</span> (ops.get_symlink1 s0 i0_ref) <span class="kw">then</span> Unix<span class="kw">.</span><span class="dt">S_LNK</span> <span class="kw">else</span> Unix<span class="kw">.</span><span class="dt">S_REG</span>); <span class="co">(* FIXME we may need our own stats structure *)</span>
    st_size=(
      <span class="kw">let</span> bs = dest_bytes1 ((ops.read1 s0 i0_ref).ret2) <span class="kw">in</span>
      (Int64<span class="kw">.</span>of_int (MyDynArray<span class="kw">.</span>dim bs)))
  }
 
  <span class="kw">let</span> default_dir_stats ops s0 d0_ref = { default_stats <span class="kw">with</span>
    st_ino=(ops.dest_dir_ref1 s0 d0_ref);
    st_kind=Unix.<span class="dt">S_DIR;</span>
    st_size=4096L; <span class="co">(* seems to be default on my system - but changes depending on number of entries? *)</span>
  }

  <span class="co">(* Fs_ops1 returns ty_return3, which apart from read is just a state *)</span>
  <span class="kw">let</span> put_state&#39; r = put_state r.state2

  <span class="co">(* FIXME remove *)</span>
  <span class="kw">let</span> put_state&#39;&#39; f = (put_state&#39; (f ()))

  <span class="co">(* posix/1 *)</span>

  <span class="kw">let</span> link ops spath dpath = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">match</span> spath <span class="kw">with</span> 
    | <span class="dt">Fname2</span>(d0_ref,name,i0_ref,rp)  -&gt; (
      <span class="kw">match</span> dpath <span class="kw">with</span> 
      | <span class="dt">None2</span> (d0_ref,n,rp) -&gt; (
        <span class="kw">let</span> s0 = ops.link_file1 s0 i0_ref d0_ref n <span class="kw">in</span>
        put_state&#39; s0)
      | <span class="dt">Err2</span>(e,_) -&gt; (
        <span class="co">(* (maybe_raise EEXIST) &gt;&gt;= fun _ -&gt; (* arguably linux bug *) *)</span>
        myraise e)
      | <span class="dt">Fname2</span> _ -&gt; (myraise <span class="dt">EEXIST</span>)
      | <span class="dt">Dname2</span> _ -&gt; (myraise <span class="dt">EEXIST</span>))
    | <span class="dt">Dname2</span> _ -&gt; (
      (<span class="kw">match</span> dpath <span class="kw">with</span>
        | <span class="dt">Err2</span>(e,_) -&gt; (maybe_raise e)
        | _ -&gt; do_nothing) &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
      myraise <span class="dt">EPERM</span>))
    | <span class="dt">Err2</span>(e,_) -&gt; (myraise e)
    | <span class="dt">None2</span> __ -&gt; (myraise <span class="dt">ENOENT</span>))

  <span class="kw">let</span> mkdir ops rpath perms = (
    <span class="co">(* FIXME deal with perms *)</span>
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">match</span> rpath <span class="kw">with</span> 
    | <span class="dt">None2</span>(d0_ref,n,_) -&gt; (
      <span class="kw">let</span> s0 = ops.mkdir1 s0 d0_ref n <span class="kw">in</span>
      put_state&#39; s0)
    | <span class="dt">Err2</span>(e,_) -&gt; (myraise e)
    | <span class="dt">Dname2</span> _ -&gt; (myraise <span class="dt">EEXIST</span>)
    | <span class="dt">Fname2</span> _ -&gt; (myraise <span class="dt">EEXIST</span>))

  <span class="co">(* FIXME we have to take care of flags eg O_TRUNC *)</span>
  <span class="co">(* FIXME return is int option - meaning optional file handle? *)</span>
  <span class="co">(* FIXME why is this called fopen (taking an fd?) rather than open? *)</span>
  <span class="co">(* FIXME the mapping between fds and files is handled elsewhere - needs a new part of spec *)</span>
  <span class="kw">let</span> _open ops rpath flags = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">match</span> rpath <span class="kw">with</span>
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>)
    | <span class="dt">Dname2</span>(_,_) -&gt; (myraise <span class="dt">ENOENT</span>) <span class="co">(* FIXME should be EISDIR? can we open a dir? *)</span>
    | _ -&gt; (return <span class="dt">None1</span>)) <span class="co">(* FIXME err case should raise an err? *)</span>
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; res_name&#39; -&gt; &#39;a -&gt; ret_value ty_mymonad&#39;) = _open

  <span class="kw">let</span> open_create ops rpath = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">match</span> rpath <span class="kw">with</span> 
    | <span class="dt">Dname2</span> _ -&gt; (myraise <span class="dt">EEXIST</span>) 
    | <span class="dt">Fname2</span> _ -&gt; (myraise <span class="dt">EEXIST</span>)
    | <span class="dt">Err2</span> (e,_) -&gt; (myraise e)
    | <span class="dt">None2</span>(d0_ref,n,ns) -&gt; (
      <span class="co">(* FIXME for us, open_create should only create files *)</span>
      <span class="kw">if</span> ends_with_slash rpath <span class="kw">then</span> 
        myraise <span class="dt">EISDIR</span>
      <span class="kw">else</span>
        <span class="kw">let</span> s0 = ops.touch1 s0 d0_ref n <span class="kw">in</span>
        put_state&#39; s0))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; res_name&#39; -&gt; ret_value ty_mymonad&#39;) = open_create

  <span class="co">(* FIXME the real spec would allow reading less than all the bytes; recall len is maxlen *)</span>
  <span class="kw">let</span> read ops rn ofs len = (
    <span class="kw">match</span> rn <span class="kw">with</span> 
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>)
    | <span class="dt">Dname2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>)
    | <span class="dt">Err2</span> (e,_) -&gt; (myraise e)
    | <span class="dt">Fname2</span>(d0_ref,n,i0_ref,rp) -&gt; (
      get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (
      <span class="kw">let</span> r = ops.read1 s0 i0_ref <span class="kw">in</span> <span class="co">(* FIXME Fs_ops1 may have to take an offset too *)</span>
      (put_state&#39; r) &gt;&gt;= <span class="kw">fun</span> _ -&gt; 
      <span class="co">(* non-deterministically choose the amount of data to write *)</span>
      choose (downto&#39; len 0) &gt;&gt;= <span class="kw">fun</span> len -&gt;
      <span class="kw">let</span> bs = dest_bytes1 r.ret2 <span class="kw">in</span>
      <span class="kw">let</span> len_bs = MyDynArray<span class="kw">.</span>dim bs <span class="kw">in</span>
      <span class="co">(* assume ofs is wellformed *)</span>
      <span class="kw">let</span> len = <span class="kw">if</span> ofs+len &lt;= len_bs <span class="kw">then</span> len <span class="kw">else</span> len_bs - ofs <span class="kw">in</span>
      <span class="co">(* let _ = print_endline (&quot;read len_bs: &quot;^(string_of_int len_bs)^&quot;; len: &quot;^(string_of_int len)^&quot;; ofs: &quot;^(string_of_int ofs)) in *)</span>
      <span class="co">(* let _ = print_endline &quot;before&quot; in *)</span>
      <span class="kw">let</span> bs&#39; = MyDynArray<span class="kw">.</span>sub bs ofs len <span class="kw">in</span>
      <span class="co">(* let _ = print_endline &quot;after&quot; in *)</span>
      return (<span class="dt">Bytes1</span>(bs&#39;))))))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; res_name&#39; -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; ret_value ty_mymonad&#39;) = read

  <span class="kw">let</span> readdir ops rn = (
    get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (
    <span class="kw">match</span> rn <span class="kw">with</span> 
    | <span class="dt">Err2</span> (e,_) -&gt; (myraise e)
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>) <span class="co">(* (raise (Unix_error (ENOENT,&quot;readdir&quot;,&quot;/FIXMEreaddir&quot;))) (* FIXME we may need access to the underlying path that was given by the user *) *)</span>
    | <span class="dt">Fname2</span> _ -&gt; (myraise <span class="dt">ENOTDIR</span>) <span class="co">(* (raise (Unix_error (ENOTDIR,&quot;readdir&quot;,&quot;/FIXMEreaddir&quot;))) *)</span>
    | <span class="dt">Dname2</span>(d0_ref,rp) -&gt; (
      <span class="kw">let</span> r = ops.readdir1 s0 d0_ref <span class="kw">in</span>
      (put_state&#39; r) &gt;&gt;= (<span class="kw">fun</span> _ -&gt; (
      return r.ret2))))))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; res_name&#39; -&gt; ret_value ty_mymonad&#39;) = readdir
  <span class="co">(* NB later we may want to also return a state, given access times can cause changes when reading etc *)</span>

  <span class="co">(* FIXME surely a lot of this complexity is because this is the user land behaviour of the mv command - but we want to target the syscall interface *)</span>
  <span class="co">(* FIXME we probably want the containing dirs as well, when doing rename; put this in resolve *)</span>
  <span class="co">(* FIXME rename to subdir of self? *)</span>
  <span class="co">(* NB if an error is possible, then all transitions result in an error; we should check that this invariant holds of the spec *)</span>

  <span class="co">(* posix/2 *)</span>

  <span class="kw">let</span> rename ops rsrc rdst = (
    get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; 
    <span class="kw">match</span> rsrc <span class="kw">with</span>
    | <span class="dt">None2</span> _ -&gt; (
      <span class="co">(* target may have ENOENT path *)</span>
      (<span class="kw">match</span> rdst <span class="kw">with</span> 
      | <span class="dt">Err2</span> (e&#39;,_) -&gt; (
        maybe_raise e&#39;) <span class="co">(* tr/11 *)</span>
      | _ -&gt; do_nothing) &gt;&gt;= (<span class="kw">fun</span> _ -&gt; (
        myraise <span class="dt">ENOENT</span>))) <span class="co">(* no src file *)</span>
    | <span class="dt">Err2</span> (e,_) -&gt; (
      <span class="co">(* target may have ENOENT path *)</span>
      (<span class="kw">match</span> rdst <span class="kw">with</span> 
      | <span class="dt">Err2</span> (e&#39;,_) -&gt; (
        maybe_raise e&#39;) <span class="co">(* tr/1 *)</span>
      | _ -&gt; do_nothing) &gt;&gt;= (<span class="kw">fun</span> _ -&gt; (
      myraise e))) <span class="co">(* tr/2 *)</span>
    | <span class="dt">Fname2</span> (d0_ref,nsrc,i0_ref,rp) -&gt; (
      <span class="kw">match</span> rdst <span class="kw">with</span> 
      | <span class="dt">Err2</span> (e,_) -&gt; (myraise e)
      | <span class="dt">None2</span> (d1_ref,ndst,rp) -&gt; (
        (<span class="kw">let</span> cond1 = ends_with_slash rdst <span class="kw">in</span>
        cond_raise [(cond1,<span class="dt">ENOTDIR</span>)]) &gt;&gt;= <span class="kw">fun</span> _ -&gt; <span class="co">(* tr/3 *)</span>
        <span class="co">(* do the move; there is no file ns_dst *)</span>
        put_state&#39;&#39; (<span class="kw">fun</span> () -&gt; ops.mv1 s0 d0_ref nsrc d1_ref ndst))
      | <span class="dt">Fname2</span> (d1_ref,ndst,i1_ref,rp) -&gt; (
        <span class="co">(* do the move; there is a file name ns_dst *)</span>
        <span class="kw">if</span> (d1_ref=d0_ref) &amp;&amp; (ndst=nsrc) <span class="kw">then</span> 
          return <span class="dt">None1</span> <span class="co">(* tr/4 *)</span>
        <span class="kw">else</span>
          put_state&#39;&#39; (<span class="kw">fun</span> () -&gt; ops.mv1 s0 d0_ref nsrc d1_ref ndst))
        <span class="co">(* FIXME may want to have putstate return a void value *)</span>
      | <span class="dt">Dname2</span> (d0_ref,rp) -&gt; (
        <span class="co">(* several reasonable options *)</span>
        (<span class="kw">if</span> (ends_with_slash rdst) <span class="kw">then</span> 
          maybe_raise <span class="dt">ENOTDIR</span>         <span class="co">(* tr/5 arguably a Linux bug? Confirmed non-posix behaviour *)</span>
        <span class="kw">else</span> 
          do_nothing) &gt;&gt;= (<span class="kw">fun</span> _ -&gt; 
        <span class="kw">if</span> ((ops.readdir1 s0 d0_ref).ret2&lt;&gt;Names1[]) <span class="kw">then</span> 
          maybe_raise <span class="dt">ENOTEMPTY</span>       <span class="co">(* tr/6 strange, but posix allows this; FIXME posix also allows EEXIST in this case *)</span>
        <span class="kw">else</span>
          do_nothing) &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
        myraise <span class="dt">EISDIR</span>))) <span class="co">(* expected *)</span>
    | <span class="dt">Dname2</span> (d0_ref,rps) -&gt; (
      <span class="co">(* rename a directory; directory exists *)</span>
      <span class="kw">match</span> rdst <span class="kw">with</span>
      | <span class="dt">None2</span> (d1_ref,ndst,rpd) -&gt; (
        <span class="co">(* do the move; there is no file ns_dst *)</span>
        <span class="kw">if</span> (resolve_subdir rps rpd) <span class="kw">then</span> 
          myraise <span class="dt">EINVAL</span>
        <span class="kw">else</span>
          <span class="kw">let</span> p = ops.get_parent1 s0 d0_ref <span class="kw">in</span>
          <span class="kw">match</span> p <span class="kw">with</span> 
          | (d0_ref,<span class="dt">Some</span> nsrc) -&gt; (
            put_state&#39;&#39; (<span class="kw">fun</span> () -&gt; ops.mvdir1 s0 d0_ref nsrc d1_ref ndst))
          | (d0_ref,<span class="dt">None</span>) -&gt; ( 
            <span class="co">(* src was root *)</span>
            myraise <span class="dt">EINVAL</span>))
      | <span class="dt">Err2</span> (e,_) -&gt; (
        (maybe_raise <span class="dt">EINVAL</span>) &gt;&gt;= (<span class="kw">fun</span> _ -&gt; <span class="co">(* tr/7 confirmed non-posix behaviour *)</span>
        myraise e))
      | <span class="dt">Fname2</span> (_,_,_,rpd) -&gt; (
        <span class="co">(* check rename to subdir before rename to file; NB there are different reasonable options here *)</span>
        (<span class="kw">if</span> (resolve_subdir rps rpd) <span class="kw">then</span>
          maybe_raise <span class="dt">EINVAL</span> 
        <span class="kw">else</span> 
          do_nothing) &gt;&gt;= (<span class="kw">fun</span> _ -&gt; 
        myraise <span class="dt">ENOTDIR</span>)) 
      | <span class="dt">Dname2</span> (d1_ref,rpd) -&gt; (
        <span class="co">(* if same dir, return silently *)</span>
        <span class="kw">if</span> (d1_ref=d0_ref) <span class="kw">then</span>
          (return <span class="dt">None1</span>) <span class="co">(* tr/8 *)</span>
        <span class="co">(* FIXME check if renaming to a subdir *)</span> <span class="co">(* FIXME following two exceptions should be maybe_raise *)</span>
        <span class="kw">else</span> <span class="kw">if</span> (resolve_subdir rps rpd) <span class="kw">then</span> 
          (myraise <span class="dt">EINVAL</span>)
        <span class="co">(* FIXME check if dir not empty *)</span>
        <span class="kw">else</span> <span class="kw">if</span> ((ops.readdir1 s0 d1_ref).ret2&lt;&gt;Names1[]) <span class="kw">then</span> 
          (myraise <span class="dt">ENOTEMPTY</span>) <span class="co">(* tr/9 *)</span>
        <span class="co">(* otherwise target dir is empty; do rename; FIXME presumably root, if empty, can&#39;t be target unless src=root *)</span>
        <span class="co">(* FIXME with the unix backend, we really don&#39;t want to execute this last because we know we are going to raise an error; but we must allow for future stages to raise further exceptions *)</span>
        <span class="kw">else</span>
          <span class="kw">let</span> (d0_ref&#39;,x) = ops.get_parent1 s0 d0_ref <span class="kw">in</span>
          <span class="kw">let</span> (d1_ref&#39;,y) = ops.get_parent1 s0 d1_ref <span class="kw">in</span>
          <span class="kw">match</span> x <span class="kw">with</span>
          | <span class="dt">None</span> -&gt; (myraise <span class="dt">EINVAL</span>)
          | <span class="dt">Some</span> nsrc -&gt; (
            <span class="kw">match</span> y <span class="kw">with</span> 
            | <span class="dt">None</span> -&gt; (
              failwith <span class="st">&quot;impossible rename of dir onto root; can&#39;t happen because dst must be nonempty&quot;</span>)
            | <span class="dt">Some</span> ndst -&gt; (
              put_state&#39;&#39; (<span class="kw">fun</span> () -&gt; ops.mvdir1 s0 d0_ref&#39; nsrc d1_ref&#39; ndst)))))))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; res_name&#39; -&gt; res_name&#39; -&gt; ret_value ty_mymonad&#39;) = rename      

  <span class="kw">let</span> rmdir ops rpath = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">match</span> rpath <span class="kw">with</span> 
    | <span class="dt">Dname2</span>(d0_ref,rp) -&gt; (
      <span class="kw">if</span> ((ops.readdir1 s0 d0_ref).ret2&lt;&gt;Names1[]) <span class="kw">then</span>
        (myraise <span class="dt">ENOTEMPTY</span>)
      <span class="kw">else</span>
        <span class="kw">let</span> (d1_ref,x) = ops.get_parent1 s0 d0_ref <span class="kw">in</span>
        <span class="kw">match</span> x <span class="kw">with</span> 
        | <span class="dt">None</span> -&gt; (
          <span class="co">(* attempt to remove the root directory, may fail or succeed *)</span>
          (maybe_raise <span class="dt">EBUSY</span>) &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
            (return <span class="dt">None1</span>)))
        | <span class="dt">Some</span> n -&gt; (
          <span class="kw">let</span> s0 = ops.unlink1 s0 d1_ref n <span class="kw">in</span>
          put_state&#39; s0))
    | <span class="dt">Fname2</span> _ -&gt; (myraise <span class="dt">ENOTDIR</span>)
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>)
    | <span class="dt">Err2</span> (e,_) -&gt; (myraise e))

  <span class="kw">let</span> stat ops rn = (
    get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (
    <span class="co">(* let _ = (print_endline (&quot;stat: &quot;^(string_of_res_name rn))) in *)</span>
    <span class="kw">match</span> rn <span class="kw">with</span>
    | <span class="dt">Err2</span> (e,_) -&gt; (myraise e)
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>) 
    | <span class="dt">Fname2</span>(d0_ref,n,i0_ref,rp) -&gt; (return (<span class="dt">Stats1</span> (default_file_stats ops s0 i0_ref)))
    | <span class="dt">Dname2</span>(d0_ref,rp) -&gt; (return (<span class="dt">Stats1</span> (default_dir_stats ops s0 d0_ref)))))) 
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; res_name&#39; -&gt; ret_value ty_mymonad&#39;) = stat

  <span class="kw">let</span> truncate ops rpath len = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">match</span> rpath <span class="kw">with</span> 
    | <span class="dt">Err2</span> (e,_) -&gt; (myraise e)
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>)
    | <span class="dt">Dname2</span> _ -&gt; (myraise <span class="dt">EISDIR</span>) <span class="co">(* FIXME check error messages are sensible *)</span>
    | <span class="dt">Fname2</span>(d0_ref,n,i0_ref,rp) -&gt; (
      <span class="kw">let</span> r = ops.read1 s0 i0_ref <span class="kw">in</span>
      <span class="kw">let</span> bs = dest_bytes1 r.ret2 <span class="kw">in</span>
      <span class="co">(* create a new array, of length len, with same contents *)</span>
      <span class="kw">let</span> bs&#39; = MyDynArray<span class="kw">.</span>resize bs len <span class="kw">in</span>
      <span class="kw">let</span> s0 = ops.write1 s0 i0_ref bs&#39; <span class="kw">in</span>
      put_state&#39; s0))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; res_name&#39; -&gt; <span class="dt">int</span> -&gt; ret_value ty_mymonad&#39;) = truncate

  <span class="kw">let</span> unlink ops rpath = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">match</span> rpath <span class="kw">with</span> 
    | <span class="dt">Err2</span>(e,_) -&gt; (myraise e)
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>)
    | <span class="dt">Dname2</span> _ -&gt; (myraise <span class="dt">EISDIR</span>)
    | <span class="dt">Fname2</span>(d0_ref,n,i0_ref,rp) -&gt; (
      <span class="co">(* FIXME for resolving a file, often useful to have dir ref as well *)</span>
      <span class="kw">let</span> s0 = ops.unlink1 s0 d0_ref n <span class="kw">in</span>
      put_state&#39; s0))

  <span class="co">(* FIXME we need to make this take an offset in order to be usable, also read *)</span>
  <span class="kw">let</span> write ops rn ofs bs len = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt; 
    <span class="kw">match</span> rn <span class="kw">with</span> 
    | <span class="dt">Err2</span> (e,_) -&gt; (myraise e)
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>) 
    | <span class="dt">Dname2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>)
    | <span class="dt">Fname2</span>(d0_ref,n,i0_ref,rp) -&gt; (
      choose (downto&#39; len 0) &gt;&gt;= <span class="kw">fun</span> len -&gt;
      <span class="kw">let</span> r = ops.read1 s0 i0_ref <span class="kw">in</span>
      <span class="kw">let</span> bs&#39; = dest_bytes1 r.ret2 <span class="kw">in</span>
      <span class="co">(* want to create a new array from bs&#39; and bs *)</span>
      <span class="kw">let</span> bs&#39;&#39; = MyDynArray<span class="kw">.</span>write (bs,0,len) (bs&#39;,ofs) <span class="kw">in</span>
      <span class="kw">let</span> r = ops.write1 s0 i0_ref bs&#39;&#39; <span class="kw">in</span>
      put_state&#39; r &gt;&gt;= <span class="kw">fun</span> _ -&gt; 
      return (<span class="dt">Int1</span> len)))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; res_name&#39; -&gt; <span class="dt">int</span> -&gt; file_contents -&gt; <span class="dt">int</span> -&gt; ret_value ty_mymonad&#39;) = write

  <span class="co">(* FIXME this is a hack - should do lots of checking eg src is a dir *)</span>
  <span class="co">(*</span>
<span class="co">  let symlink ops src dst = (</span>
<span class="co">    open_create ops dst &gt;&gt;= fun _ -&gt; </span>
<span class="co">    write ops dst 0 (MyDynArray.of_string src) (String.length src) &gt;&gt;= fun _ -&gt; </span>
<span class="co">    get_state &gt;&gt;= fun s0 -&gt;</span>
<span class="co">    let rpath = process_path ops s0 dst in</span>
<span class="co">    let Fname2(i0_ref,_) = rpath in</span>
<span class="co">    let r = ops.set_symlink1 s0 i0_ref true in</span>
<span class="co">    put_state&#39; r)</span>
<span class="co">  let (_:ty_ops&#39; -&gt; string -&gt; string -&gt; ret_value ty_mymonad&#39;) = symlink    </span>
<span class="co">  *)</span>

<span class="kw">end</span></code></pre>
<h2 id="fs-transition-system"><a href="#fs-transition-system">Fs transition system</a></h2>
<p>The model is of a labelled transition system from state to state, but where each transition may result in a return to userland (of a value or an error). FIXME need to be non-determinisitic eg in write and read behaviour.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">
<span class="ot">module</span> Fs_transition_system = <span class="kw">struct</span>

  <span class="ot">open</span> Prelude 
  <span class="ot">open</span> Fs_types1
  <span class="ot">open</span> Fs_ops2
  <span class="co">(* open Fs_ops3 *)</span>

  <span class="ot">module</span> X4 = <span class="kw">struct</span> 
    <span class="co">(* for the purposes of type-checking the following defns without spurious type vars *)</span>
    <span class="co">(* type ty_ops&#39; = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)</span>
    <span class="kw">type</span> ty_ops&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3,X<span class="kw">.</span>Y<span class="kw">.</span>t5) ty_ops1
    <span class="kw">type</span> state&#39; = X<span class="kw">.</span>Y<span class="kw">.</span>t5
    <span class="kw">type</span> ty_fs_label&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3) ty_fs_label
  <span class="kw">end</span>
  <span class="ot">open</span> X4

  <span class="co">(* the transition function takes a state, a label, and returns an updated state with a possible value returned, or an error *)</span>
  <span class="co">(* FIXME readlink is just read, but may want to have a separate label *)</span>
  <span class="kw">let</span> fs_trans ops s0 lbl = (
    <span class="co">(* let _ = print_endline (string_of_label lbl) in *)</span>
    <span class="kw">let</span> m = (<span class="kw">match</span> lbl <span class="kw">with</span> 
      | <span class="dt">FS_LINK</span> (s,d) -&gt; (link ops s d)
      | <span class="dt">FS_MKDIR</span> (s,p) -&gt; (mkdir ops s p)
      | <span class="dt">FS_OPEN</span> (p,fs) -&gt; (
          <span class="kw">if</span> (List<span class="kw">.</span>mem <span class="dt">O_CREAT</span> fs) <span class="kw">then</span> (open_create ops p <span class="co">(* FIXME fs *)</span>) 
          <span class="kw">else</span> (_open ops p fs))
      | <span class="dt">FS_READ</span> (p,i,j) -&gt; (read ops p i j)
      | <span class="dt">FS_READDIR</span> p -&gt; (readdir ops p)
      | <span class="dt">FS_RENAME</span> (s,d) -&gt; (rename ops s d)
      | <span class="dt">FS_RMDIR</span> p -&gt; (rmdir ops p)
      | <span class="dt">FS_STAT</span> p -&gt; (stat ops p)
      | <span class="dt">FS_SYMLINK</span> (s,d) -&gt; failwith <span class="st">&quot;FIXME&quot;</span> <span class="co">(* (symlink ops s d) *)</span>
      | <span class="dt">FS_TRUNCATE</span> (p,l) -&gt; (truncate ops p l)
      | <span class="dt">FS_UNLINK</span> p -&gt; (unlink ops p)
      | <span class="dt">FS_WRITE</span> (p,ofs,bs,len) -&gt; (write ops p ofs bs len))
    <span class="kw">in</span>
    <span class="kw">let</span> rs = run_mymonad m s0 <span class="kw">in</span>
    <span class="kw">let</span> f1 ve = (<span class="kw">match</span> ve <span class="kw">with</span>
      | <span class="dt">Inl</span>(s,e) -&gt; (s,<span class="dt">Inl</span> e)
      | <span class="dt">Inr</span>(s,v) -&gt; (s,<span class="dt">Inr</span> v))
    <span class="kw">in</span>
    <span class="kw">let</span> rs = List<span class="kw">.</span>map f1 rs <span class="kw">in</span>
    rs)
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; state&#39; -&gt; ty_fs_label&#39; -&gt; (state&#39; * (error,ret_value)sum) finset) = fs_trans

  <span class="co">(* convenience method to process a label; always choose first possible result (state,e+v) *)</span>
  <span class="kw">let</span> process_label ops s0 lbl = (
    <span class="kw">let</span> rs = fs_trans ops s0 lbl <span class="kw">in</span>
    <span class="kw">let</span> _ = <span class="kw">if</span> rs = finset_empty <span class="kw">then</span> failwith <span class="st">&quot;process_label: no result state&quot;</span> <span class="kw">else</span> () <span class="kw">in</span>
    <span class="kw">let</span> (s&#39;,v) = finset_choose rs <span class="kw">in</span>
    (s&#39;,v))
  
  <span class="co">(* convenience method to process a list of labels *)</span>
  <span class="kw">let</span> process_labels ops s0 lbls = (
    <span class="kw">let</span> f1 = (<span class="kw">fun</span> xs -&gt; <span class="kw">fun</span> lbl -&gt; 
      <span class="kw">let</span> l = last xs <span class="kw">in</span>
      <span class="kw">let</span> (_,_,(s,_)) = l <span class="kw">in</span>
      <span class="kw">let</span> (s&#39;,v) = process_label ops s lbl <span class="kw">in</span>
      xs@[(List<span class="kw">.</span>length xs,lbl,(s&#39;,v))])
    <span class="kw">in</span>
    <span class="kw">let</span> dummy_lbl = <span class="dt">FS_STAT</span>(<span class="dt">Err2</span>(<span class="dt">EINVAL</span>, { ns2=[<span class="st">&quot;dummy lbl&quot;</span>] })) <span class="kw">in</span>
    <span class="kw">let</span> dummy_error_or_value = <span class="dt">Inr</span> <span class="dt">None1</span> <span class="kw">in</span>
    List<span class="kw">.</span>fold_left f1 [(0,dummy_lbl,(s0,dummy_error_or_value))] lbls)
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; state&#39; -&gt; ty_fs_label&#39; <span class="dt">list</span> -&gt; (<span class="dt">int</span> * ty_fs_label&#39; * (state&#39; * (error,ret_value)sum)) <span class="dt">list</span>) = process_labels

<span class="kw">end</span></code></pre>
<h2 id="os-transition-system"><a href="#os-transition-system">OS transition system</a></h2>
<p>The model of transitions at the operating system level is:</p>
<ul>
<li><p>A call gets made with OS_CALL label</p></li>
<li><p>The process gets moved to a blocked state</p></li>
<li><p>Further steps process the call</p></li>
<li><p>A return transition occurs with OS_RETURN; at this point, the process is unblocked</p></li>
</ul>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">
<span class="ot">module</span> Os_transition_system = <span class="kw">struct</span>

  <span class="ot">open</span> Prelude 
  <span class="ot">open</span> Fs_types1
  <span class="ot">open</span> Fs_transition_system

  <span class="kw">let</span> process_path = Resolve<span class="kw">.</span>process_path

  <span class="ot">module</span> X5 = <span class="kw">struct</span> 
    <span class="co">(* for the purposes of type-checking the following defns without spurious type vars *)</span>
    <span class="co">(* type ty_ops&#39; = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)</span>
    <span class="kw">type</span> ty_ops&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3,X<span class="kw">.</span>Y<span class="kw">.</span>t5) ty_ops1
    <span class="kw">type</span> os_state&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3,X<span class="kw">.</span>Y<span class="kw">.</span>t5) ty_os_state
  <span class="kw">end</span>
  <span class="ot">open</span> X5

  <span class="co">(* s0 is impl state *)</span>
  <span class="kw">let</span> fs_lbl_of ops s0 cwd lbl = (
    <span class="kw">let</span> pp = process_path ops s0 cwd <span class="kw">in</span>
     <span class="kw">match</span> lbl <span class="kw">with</span>
    | <span class="dt">LINK</span> (s,d) -&gt; (<span class="dt">FS_LINK</span>(pp s, pp d))
    | <span class="dt">MKDIR</span> (s,p) -&gt; (<span class="dt">FS_MKDIR</span>(pp s, p))
    | <span class="dt">OPEN</span> (p,fs) -&gt; (<span class="dt">FS_OPEN</span>(pp p, fs))
    | <span class="dt">READ</span> (p,i,j) -&gt; (<span class="dt">FS_READ</span>(pp p, i, j))
    | <span class="dt">READDIR</span> p -&gt; (<span class="dt">FS_READDIR</span>(pp p))
    | <span class="dt">RENAME</span> (s,d) -&gt; (<span class="dt">FS_RENAME</span>(pp s, pp d))
    | <span class="dt">RMDIR</span> p -&gt; (<span class="dt">FS_RMDIR</span>(pp p))
    | <span class="dt">STAT</span> p -&gt; (<span class="dt">FS_STAT</span>(pp p))
    | <span class="dt">SYMLINK</span> (s,d) -&gt; failwith <span class="st">&quot;FIXME&quot;</span> <span class="co">(* (symlink ops s d) *)</span>
    | <span class="dt">TRUNCATE</span> (p,l) -&gt; (<span class="dt">FS_TRUNCATE</span>(pp p,l))
    | <span class="dt">UNLINK</span> p -&gt; (<span class="dt">FS_UNLINK</span>(pp p))
    | <span class="dt">WRITE</span> (p,ofs,bs,len) -&gt; (<span class="dt">FS_WRITE</span>(pp p,ofs,bs,len)))

  <span class="co">(* we return a finite set of possible next states; FIXME should we have functions to decompose and recompose hosts etc without doing everything manually? *)</span>
  <span class="kw">let</span> os_trans_pid ops s0 pid lblopt = (
    <span class="kw">match</span> (fmap_lookup s0.pid_table pid) <span class="kw">with</span> | <span class="dt">None</span> -&gt; (failwith <span class="st">&quot;os_trans: impossible&quot;</span>)
    | <span class="dt">Some</span> ppstate -&gt; (
      <span class="kw">let</span> cwd = ppstate.cwd <span class="kw">in</span>
      <span class="kw">match</span> (ppstate.pid_run_state,lblopt) <span class="kw">with</span> 
      | (<span class="dt">RUNNING</span>,<span class="dt">Some</span>(<span class="dt">OS_CALL</span>(pid&#39;,lbl))) -&gt; (
        <span class="kw">if</span> (pid&#39; &lt;&gt; pid) <span class="kw">then</span> finset_empty
        <span class="kw">else</span> (
          <span class="kw">let</span> lbl = fs_lbl_of ops s0.fs_state cwd lbl <span class="kw">in</span>
          <span class="kw">let</span> ppstate&#39; = { ppstate <span class="kw">with</span> pid_run_state = <span class="dt">BLOCKED_CALL</span>(lbl) } <span class="kw">in</span>
          <span class="kw">let</span> s0 = { s0 <span class="kw">with</span> pid_table=(fmap_update s0.pid_table (pid,ppstate&#39;)) } <span class="kw">in</span>
          finset_singleton s0))
      | (<span class="dt">BLOCKED_CALL</span>(lbl),<span class="dt">None</span>) -&gt; (
        <span class="kw">let</span> fs_s0 = s0.fs_state <span class="kw">in</span>
        <span class="kw">let</span> next_fs_states = fs_trans ops fs_s0 lbl <span class="kw">in</span>
        <span class="kw">let</span> f1 (fs_s0&#39;,ev) = (
          <span class="kw">let</span> ppstate&#39; = { ppstate <span class="kw">with</span> pid_run_state = <span class="dt">PENDING_RETURN</span>(ev) } <span class="kw">in</span>
          { s0 <span class="kw">with</span> fs_state=fs_s0&#39;; pid_table=(fmap_update s0.pid_table (pid,ppstate&#39;)) })
        <span class="kw">in</span>
        finset_image f1 next_fs_states)
      | (<span class="dt">PENDING_RETURN</span>(ev),<span class="dt">Some</span>(<span class="dt">OS_RETURN</span>(pid&#39;,ev&#39;))) -&gt; (
        <span class="kw">if</span> (pid&#39; &lt;&gt; pid) <span class="kw">then</span> finset_empty 
        <span class="kw">else</span> <span class="kw">if</span> (ev&#39; &lt;&gt; ev) <span class="kw">then</span> finset_empty
        <span class="kw">else</span> (
          <span class="kw">let</span> ppstate&#39; = { ppstate <span class="kw">with</span> pid_run_state = <span class="dt">RUNNING</span> } <span class="kw">in</span>
          <span class="kw">let</span> s0 = { s0 <span class="kw">with</span> pid_table=(fmap_update s0.pid_table (pid,ppstate&#39;)) } <span class="kw">in</span>
          finset_singleton s0))
      | (<span class="dt">RUNNING</span>,<span class="dt">None</span>) -&gt; (finset_singleton s0)
      | (_,_) -&gt; finset_empty))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; os_state&#39; -&gt; ty_pid -&gt; os_label <span class="dt">option</span> -&gt; os_state&#39; finset) = os_trans_pid

  <span class="kw">let</span> create_pid ops s0 pid = { 
    cwd=(dest_Some (ops.get_root1 s0)); 
    fd_table=fmap_empty; 
    dh_table=fmap_empty; 
    pid_run_state=RUNNING 
  }

  <span class="kw">let</span> os_trans_pcreate_destroy ops s0 lblopt = (
    <span class="kw">match</span> lblopt <span class="kw">with</span> | <span class="dt">None</span> -&gt; finset_empty
    | <span class="dt">Some</span> lbl -&gt; (
      <span class="kw">match</span> lbl <span class="kw">with</span>
      | <span class="dt">OS_CREATE</span>(pid) -&gt; (
        <span class="kw">if</span> finset_mem pid (fmap_dom s0.pid_table) <span class="kw">then</span> 
          finset_empty
        <span class="kw">else</span> (
          <span class="kw">let</span> s0 = { s0 <span class="kw">with</span> pid_table=(fmap_update s0.pid_table (pid,create_pid ops s0.fs_state pid)) } <span class="kw">in</span>
          finset_singleton s0))
      | <span class="dt">OS_DESTROY</span>(pid) -&gt; (
        <span class="kw">if</span> not (finset_mem pid (fmap_dom s0.pid_table)) <span class="kw">then</span> 
          finset_empty
        <span class="kw">else</span> (
          <span class="kw">let</span> ppstate = dest_Some (fmap_lookup s0.pid_table pid) <span class="kw">in</span>
          <span class="kw">match</span> ppstate.pid_run_state <span class="kw">with</span> 
          | <span class="dt">RUNNING</span> -&gt; (
            <span class="kw">let</span> s0 = { s0 <span class="kw">with</span> pid_table=(fmap_remove s0.pid_table pid) } <span class="kw">in</span>
            finset_singleton s0)
          | _ -&gt; finset_empty <span class="co">(* we don&#39;t allow processes to be destroyed if they are in kernel *)</span>))
      | _ -&gt; finset_empty))
            
  <span class="co">(* assumes pid is in host pid_table *)</span>
  <span class="kw">let</span> os_trans ops s0 lblopt = (
    <span class="co">(* process transitions *)</span>
    <span class="kw">let</span> pids = fmap_dom s0.pid_table <span class="kw">in</span>
    <span class="kw">let</span> ss = finset_image (<span class="kw">fun</span> pid -&gt; os_trans_pid ops s0 pid lblopt) pids <span class="kw">in</span>
    <span class="kw">let</span> ss = finset_bigunion ss <span class="kw">in</span>
    <span class="co">(* create/ destroy transitions *)</span>
    <span class="kw">let</span> ss = finset_union ss (os_trans_pcreate_destroy ops s0 lblopt) <span class="kw">in</span>
    ss)
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; os_state&#39; -&gt; os_label <span class="dt">option</span> -&gt; os_state&#39; finset) = os_trans


  <span class="co">(* convenience method to process a label; always choose first possible result (state,e+v) *)</span>
  <span class="kw">let</span> os_process_label ops s0 lblopt = (
    <span class="kw">let</span> rs = os_trans ops s0 lblopt <span class="kw">in</span>
    <span class="kw">let</span> _ = <span class="kw">if</span> rs = finset_empty <span class="kw">then</span> failwith <span class="st">&quot;os_process_label: no result state&quot;</span> <span class="kw">else</span> () <span class="kw">in</span>
    <span class="kw">let</span> s&#39; = finset_choose rs <span class="kw">in</span>
    s&#39;)

  <span class="co">(* convenience method to process a list of labels *)</span>
  <span class="kw">let</span> os_process_labels ops s0 lbls = (
    <span class="kw">let</span> f1 = (<span class="kw">fun</span> xs -&gt; <span class="kw">fun</span> lbl -&gt; 
      <span class="kw">let</span> l = last xs <span class="kw">in</span>
      <span class="kw">let</span> (_,_,s) = l <span class="kw">in</span>
      <span class="kw">let</span> s&#39; = os_process_label ops s lbl <span class="kw">in</span>
      xs@[(List<span class="kw">.</span>length xs,lbl,s&#39;)])
    <span class="kw">in</span>
    <span class="kw">let</span> dummy_lbl = <span class="dt">None</span> <span class="kw">in</span>
    List<span class="kw">.</span>fold_left f1 [(0,dummy_lbl,s0)] lbls)
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; os_state&#39; -&gt; os_label <span class="dt">option</span> <span class="dt">list</span> -&gt; (<span class="dt">int</span> * os_label <span class="dt">option</span> * os_state&#39;) <span class="dt">list</span>) = os_process_labels

<span class="kw">end</span>
</code></pre>
<h2 id="fs_spec_everything"><a href="#fs_spec_everything"><code>Fs_spec_everything</code></a></h2>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">
<span class="ot">module</span> Fs_spec_everything = <span class="kw">struct</span>

  <span class="ot">include</span> Fs_prelude
  <span class="ot">include</span> Prelude
<span class="co">(*  include File_utils *)</span>
  <span class="ot">include</span> Fs_types1
<span class="co">(*  include Lift *)</span>
<span class="co">(*  include Common *)</span>
<span class="co">(*  include Fs_ops1 *)</span>
  <span class="ot">include</span> Resolve
  <span class="ot">include</span> Fs_ops2
<span class="co">(*  include Fs_ops3 *)</span>
  <span class="ot">include</span> Fs_transition_system
  <span class="ot">include</span> Os_transition_system

<span class="kw">end</span></code></pre>
<h2 id="debug"><a href="#debug">Debug</a></h2>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* FIXME do we need to generalize this over ops? yes probably *)</span>
<span class="ot">module</span> Debug = <span class="kw">struct</span>
  
  <span class="ot">open</span> Prelude
  <span class="ot">open</span> Fs_types1

<span class="co">(*</span>
<span class="co">  let string_of_entry e = (</span>
<span class="co">    let i = (match e with</span>
<span class="co">    | Inl dref -&gt; (string_of_int (dest_dir_ref dref))</span>
<span class="co">    | Inr iref -&gt; (string_of_int (dest_inode_ref iref)))</span>
<span class="co">    in</span>
<span class="co">    &quot;(&quot;^i^&quot;)&quot;)</span>
<span class="co">*)</span>

  <span class="kw">let</span> <span class="kw">rec</span> string_of_dir ops s0 dirname d0_ref = (
    <span class="kw">let</span> <span class="dt">Names1</span>(ns) = (ops.readdir1 s0 d0_ref).ret2 <span class="kw">in</span>
    <span class="kw">let</span> is_file ops s0 d0_ref n = (
      <span class="kw">let</span> <span class="dt">Some</span>(e) = ops.resolve11 s0 d0_ref n <span class="kw">in</span>
      is_inode_ref_entry e)
    <span class="kw">in</span>
    <span class="kw">let</span> is_dir ops s0 d0_ref n = (not (is_file ops s0 d0_ref n)) <span class="kw">in</span>
    <span class="kw">let</span> this_dir = (String<span class="kw">.</span>concat <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> (List<span class="kw">.</span>map (<span class="kw">fun</span> n -&gt; n) ns)) <span class="kw">in</span>    
    <span class="kw">let</span> this_dir = <span class="kw">if</span> ns &lt;&gt; [] <span class="kw">then</span> this_dir ^ <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> <span class="kw">else</span> this_dir <span class="kw">in</span>
    <span class="kw">let</span> other_dirs = List<span class="kw">.</span>filter (<span class="kw">fun</span> n -&gt; is_dir ops s0 d0_ref n) ns <span class="kw">in</span>
    <span class="kw">let</span> f1 n = (
      <span class="kw">let</span> <span class="dt">Some</span>(e) = ops.resolve11 s0 d0_ref n <span class="kw">in</span>
      <span class="kw">let</span> d1_ref = dest_dir_ref_entry e <span class="kw">in</span>
      string_of_dir ops s0 (dirname ^ <span class="st">&quot;/&quot;</span> ^ n) d1_ref)
    <span class="kw">in</span>
    <span class="kw">let</span> others = List<span class="kw">.</span>map f1 other_dirs <span class="kw">in</span>
    <span class="st">&quot;Directory &quot;</span>^dirname^<span class="st">&quot;:</span><span class="ch">\n</span><span class="st">&quot;</span>
    ^ this_dir
    ^ (String<span class="kw">.</span>concat <span class="st">&quot;&quot;</span> others))
    
  <span class="co">(* assume no cycles *)</span>
  <span class="kw">let</span> string_of_state ops s = (
    <span class="kw">let</span> <span class="dt">Some</span>(d0_ref) = ops.get_root1 s <span class="kw">in</span>
    (string_of_dir ops s <span class="st">&quot;/&quot;</span> d0_ref))

<span class="kw">end</span>

</code></pre>
</body>
</html>
