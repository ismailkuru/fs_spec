<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#interactive-top-level-directives">Interactive top-level directives</a></li>
<li><a href="#fs_spec.ml">fs_spec.ml</a><ul>
<li><a href="#fs_types1">Fs_types1</a></li>
<li><a href="#resolve-names">Resolve names</a></li>
<li><a href="#fs_ops2"><code>Fs_ops2</code></a></li>
<li><a href="#fs_ops3"><code>Fs_ops3</code></a></li>
<li><a href="#transition-system">Transition system</a></li>
<li><a href="#fs_spec_everything"><code>Fs_spec_everything</code></a></li>
<li><a href="#debug">Debug</a></li>
</ul></li>
</ul>
</div>
<h1 id="interactive-top-level-directives"><a href="#interactive-top-level-directives">Interactive top-level directives</a></h1>
<p>Via findlib:</p>
<pre><code>#use &quot;topfind&quot;;;
#require &quot;unix&quot;;;
#require &quot;bigarray&quot;;;
#require &quot;str&quot;;;
(* #cd &quot;/tmp/l/general/research/fs/fs_spec/src&quot;;; *)
#use &quot;fs_prelude.toplevel.ml&quot;;;
#use &quot;fs_spec.toplevel.ml&quot;;;
open Fs_prelude;;
open Fs_spec;;
open Fs_spec_everything;;</code></pre>
<h1 id="fs_spec.ml"><a href="#fs_spec.ml">fs_spec.ml</a></h1>
<h2 id="fs_types1"><a href="#fs_types1">Fs_types1</a></h2>
<p>Types common to all implementations of the basic operations</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">
<span class="ot">open</span> Fs_prelude

<span class="co">(* as an optimization, we expect that each of these refs is actually a ref to a sector *)</span>

<span class="ot">module</span> Fs_types1 = <span class="kw">struct</span>

  <span class="ot">open</span> Prelude

  <span class="kw">type</span> bytes = MyDynArray<span class="kw">.</span>t
  <span class="kw">type</span> name = <span class="dt">string</span> <span class="co">(* shortest component of a filename - doesn&#39;t include /; may be empty; may be . or .. *)</span>

  <span class="kw">type</span> error =
      <span class="dt">E2BIG</span>
    | <span class="dt">EACCES</span>
    | <span class="dt">EAGAIN</span>
    | <span class="dt">EBADF</span>
    | <span class="dt">EBUSY</span>
    | <span class="dt">ECHILD</span>
    | <span class="dt">EDEADLK</span>
    | <span class="dt">EDOM</span>
    | <span class="dt">EEXIST</span>
    | <span class="dt">EFAULT</span>
    | <span class="dt">EFBIG</span>
    | <span class="dt">EINTR</span>
    | <span class="dt">EINVAL</span>
    | <span class="dt">EIO</span>
    | <span class="dt">EISDIR</span>
    | <span class="dt">EMFILE</span>
    | <span class="dt">EMLINK</span>
    | <span class="dt">ENAMETOOLONG</span>
    | <span class="dt">ENFILE</span>
    | <span class="dt">ENODEV</span>
    | <span class="dt">ENOENT</span>
    | <span class="dt">ENOEXEC</span>
    | <span class="dt">ENOLCK</span>
    | <span class="dt">ENOMEM</span>
    | <span class="dt">ENOSPC</span>
    | <span class="dt">ENOSYS</span>
    | <span class="dt">ENOTDIR</span>
    | <span class="dt">ENOTEMPTY</span>
    | <span class="dt">ENOTTY</span>
    | <span class="dt">ENXIO</span>
    | <span class="dt">EPERM</span>
    | <span class="dt">EPIPE</span>
    | <span class="dt">ERANGE</span>
    | <span class="dt">EROFS</span>
    | <span class="dt">ESPIPE</span>
    | <span class="dt">ESRCH</span>
    | <span class="dt">EXDEV</span>
    | <span class="dt">EWOULDBLOCK</span>
    | <span class="dt">EINPROGRESS</span>
    | <span class="dt">EALREADY</span>
    | <span class="dt">ENOTSOCK</span>
    | <span class="dt">EDESTADDRREQ</span>
    | <span class="dt">EMSGSIZE</span>
    | <span class="dt">EPROTOTYPE</span>
    | <span class="dt">ENOPROTOOPT</span>
    | <span class="dt">EPROTONOSUPPORT</span>
    | <span class="dt">ESOCKTNOSUPPORT</span>
    | <span class="dt">EOPNOTSUPP</span>
    | <span class="dt">EPFNOSUPPORT</span>
    | <span class="dt">EAFNOSUPPORT</span>
    | <span class="dt">EADDRINUSE</span>
    | <span class="dt">EADDRNOTAVAIL</span>
    | <span class="dt">ENETDOWN</span>
    | <span class="dt">ENETUNREACH</span>
    | <span class="dt">ENETRESET</span>
    | <span class="dt">ECONNABORTED</span>
    | <span class="dt">ECONNRESET</span>
    | <span class="dt">ENOBUFS</span>
    | <span class="dt">EISCONN</span>
    | <span class="dt">ENOTCONN</span>
    | <span class="dt">ESHUTDOWN</span>
    | <span class="dt">ETOOMANYREFS</span>
    | <span class="dt">ETIMEDOUT</span>
    | <span class="dt">ECONNREFUSED</span>
    | <span class="dt">EHOSTDOWN</span>
    | <span class="dt">EHOSTUNREACH</span>
    | <span class="dt">ELOOP</span>
    | <span class="dt">EOVERFLOW</span>
    | <span class="dt">EUNKNOWNERR</span> <span class="kw">of</span> <span class="dt">int</span>
 
  <span class="co">(* from unix.mli *)</span>
  <span class="kw">type</span> open_flag =
      <span class="dt">O_RDONLY</span>                    <span class="co">(** Open for reading *)</span>
    | <span class="dt">O_WRONLY</span>                    <span class="co">(** Open for writing *)</span>
    | <span class="dt">O_RDWR</span>                      <span class="co">(** Open for reading and writing *)</span>
    | <span class="dt">O_NONBLOCK</span>                  <span class="co">(** Open in non-blocking mode *)</span>
    | <span class="dt">O_APPEND</span>                    <span class="co">(** Open for append *)</span>
    | <span class="dt">O_CREAT</span>                     <span class="co">(** Create if nonexistent *)</span>
    | <span class="dt">O_TRUNC</span>                     <span class="co">(** Truncate to 0 length if existing *)</span>
    | <span class="dt">O_EXCL</span>                      <span class="co">(** Fail if existing *)</span>
    | <span class="dt">O_NOCTTY</span>                    <span class="co">(** Don&#39;t make this dev a controlling tty *)</span>
    | <span class="dt">O_DSYNC</span>                     <span class="co">(** Writes complete as `Synchronised I/O data</span>
<span class="co">                                     integrity completion&#39; *)</span>
    | <span class="dt">O_SYNC</span>                      <span class="co">(** Writes complete as `Synchronised I/O file</span>
<span class="co">                                     integrity completion&#39; *)</span>
    | <span class="dt">O_RSYNC</span>                     <span class="co">(** Reads complete as writes (depending on</span>
<span class="co">                                     O_SYNC/O_DSYNC) *)</span>
    | <span class="dt">O_SHARE_DELETE</span>              <span class="co">(** Windows only: allow the file to be deleted</span>
<span class="co">                                   while still open *)</span>

  <span class="kw">type</span> file_perm = <span class="dt">int</span>


  <span class="kw">type</span> file_kind = 
    <span class="dt">S_REG</span>                       <span class="co">(** Regular file *)</span>
  | <span class="dt">S_DIR</span>                       <span class="co">(** Directory *)</span>
  | <span class="dt">S_LNK</span>                       <span class="co">(** Symbolic link *)</span>


  <span class="co">(* top-level labels, intended to mirror the syscalls, but with functional interface; TODO need to incorporate file descriptors, &quot;current position&quot; etc *)</span>
  <span class="kw">type</span> ty_label = 
    | <span class="dt">LINK</span> <span class="kw">of</span> (<span class="dt">string</span> * <span class="dt">string</span>)
    | <span class="dt">MKDIR</span> <span class="kw">of</span> (<span class="dt">string</span> * file_perm)
    | <span class="dt">OPEN</span> <span class="kw">of</span> (<span class="dt">string</span> * open_flag <span class="dt">list</span>)
    | <span class="dt">READ</span> <span class="kw">of</span> (<span class="dt">string</span> * <span class="dt">int</span> * <span class="dt">int</span>)
    | <span class="dt">READDIR</span> <span class="kw">of</span> <span class="dt">string</span>
    | <span class="dt">RENAME</span> <span class="kw">of</span> (<span class="dt">string</span> * <span class="dt">string</span>)
    | <span class="dt">RMDIR</span> <span class="kw">of</span> <span class="dt">string</span>
    | <span class="dt">STAT</span> <span class="kw">of</span> <span class="dt">string</span>
    | <span class="dt">SYMLINK</span> <span class="kw">of</span> (<span class="dt">string</span> * <span class="dt">string</span>)
    | <span class="dt">TRUNCATE</span> <span class="kw">of</span> (<span class="dt">string</span> * <span class="dt">int</span>)
    | <span class="dt">UNLINK</span> <span class="kw">of</span> <span class="dt">string</span>
    | <span class="dt">WRITE</span> <span class="kw">of</span> (<span class="dt">string</span> * <span class="dt">int</span> * bytes * <span class="dt">int</span>)

  <span class="kw">type</span> file_contents = bytes <span class="co">(* really a map from index to ... *)</span>

  <span class="kw">type</span> ret_value = <span class="dt">None1</span> | <span class="dt">Int1</span> <span class="kw">of</span> <span class="dt">int</span> | <span class="dt">Bytes1</span> <span class="kw">of</span> bytes <span class="co">(* FIXME add init return type *)</span> | <span class="dt">Names1</span> <span class="kw">of</span> name <span class="dt">list</span>
    | <span class="dt">Stats1</span> <span class="kw">of</span> Unix<span class="kw">.</span>LargeFile<span class="kw">.</span>stats
  <span class="kw">let</span> dest_bytes1 (<span class="dt">Bytes1</span> bs) = bs
 
  <span class="co">(* names types; also type name earlier *)</span>
  
  <span class="co">(* following moved from ops parser *)</span>
  <span class="kw">type</span> dirname = <span class="dt">string</span> <span class="dt">list</span>
  <span class="kw">type</span> filename = <span class="dt">string</span> <span class="dt">list</span> <span class="co">(* non-empty *)</span>

  <span class="co">(* the type of parsed paths; what is important is whether the name ends with a slash *)</span>
  <span class="kw">type</span> ty_name_list2 = {
    ns2: name <span class="dt">list</span>;
    ends_with_slash2: <span class="dt">bool</span>; 
  }

  <span class="co">(* we cannot supply Fname from user space: a name /tmp/tmp.txt may refer to a file or a dir *)</span>
  <span class="co">(* resolved name *)</span>
  <span class="co">(* type rname1 = Dname1 of name list | Fordname1 of name list *)</span>
  <span class="co">(* resolved name relative to a state *)</span>
  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref) rname2 = 
    <span class="dt">Dname2</span> <span class="kw">of</span> &#39;dir_ref * ty_name_list2
  | <span class="dt">Fname2</span> <span class="kw">of</span> &#39;inode_ref * ty_name_list2 
  | <span class="dt">None2</span> <span class="kw">of</span> ty_name_list2
  | <span class="dt">Err2</span> <span class="kw">of</span> &#39;inode_ref * ty_name_list2 
  <span class="co">(* invariant: if Fname2 ns, then not (ns.ends_with_slash2) *)</span>
  <span class="co">(* invariant: if Err2 then ns.ends_with_slash2 *)</span>
  <span class="co">(* FIXME since these are resolved, we may want to include the i0_ref and d0_ref *)</span>

  <span class="kw">let</span> is_Err2 x = (<span class="kw">match</span> x <span class="kw">with</span> | <span class="dt">Err2</span> _ -&gt; <span class="kw">true</span> | _ -&gt; <span class="kw">false</span>)

  <span class="kw">let</span> name_list_of_rname2 n = (<span class="kw">match</span> n <span class="kw">with</span> 
    | <span class="dt">Dname2</span> (_,ns) -&gt; ns
    | <span class="dt">Fname2</span> (_,ns) -&gt; ns
    | <span class="dt">None2</span> ns -&gt; ns
    | <span class="dt">Err2</span> (_,ns) -&gt; ns)
 
  <span class="kw">let</span> string_of_names ns = (<span class="st">&quot;/&quot;</span>^(String<span class="kw">.</span>concat <span class="st">&quot;/&quot;</span> ns))

  <span class="kw">let</span> string_of_rname2 n = (
    <span class="kw">let</span> ns = name_list_of_rname2 n <span class="kw">in</span>
    ((String<span class="kw">.</span>concat <span class="st">&quot;/&quot;</span> ns.ns2)^(<span class="kw">if</span> ns.ends_with_slash2 <span class="kw">then</span> <span class="st">&quot;/&quot;</span> <span class="kw">else</span> <span class="st">&quot;&quot;</span>))) <span class="co">(* FIXME shouldn&#39;t this start with / ? *)</span>

  <span class="kw">let</span> is_None2 x = (<span class="kw">match</span> x <span class="kw">with</span> <span class="dt">None2</span> _ -&gt; <span class="kw">true</span> | _ -&gt; <span class="kw">false</span>)




  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref) entry = (&#39;dir_ref,&#39;inode_ref) sum
  <span class="kw">let</span> is_dir_ref_entry = is_Inl
  <span class="kw">let</span> is_inode_ref_entry = is_Inr
  <span class="kw">let</span> dest_dir_ref_entry = dest_Inl
  <span class="kw">let</span> dest_inode_ref_entry = dest_Inr

  <span class="co">(* might like type operators which pick up the type from a compound type eg. &#39;a ty_state_ops = { f1:(fst &#39;a); f2: (fst(snd &#39;a)) } etc *)</span>
  <span class="kw">type</span> (&#39;dir_ref,&#39;dir,&#39;inode_ref,&#39;inode,&#39;state) ty_state_ops = {
    get_init_state: <span class="dt">unit</span> -&gt; &#39;state;
    get_root: &#39;state -&gt; &#39;dir_ref <span class="dt">option</span>;
    lookup_dir: &#39;state -&gt; &#39;dir_ref -&gt; &#39;dir <span class="dt">option</span>;
    lookup_inode: &#39;state -&gt; &#39;inode_ref -&gt; &#39;inode <span class="dt">option</span>;
    update_inds_some: &#39;state -&gt; (&#39;inode_ref * &#39;inode) -&gt; &#39;state;
    resolve1: &#39;state -&gt; &#39;dir_ref -&gt; name -&gt; (&#39;dir_ref,&#39;inode_ref) entry <span class="dt">option</span>;
    update_ents_pointwise: &#39;state -&gt; &#39;dir_ref -&gt; name -&gt; (&#39;dir_ref,&#39;inode_ref) entry <span class="dt">option</span> -&gt; &#39;state;
    new_dir: &#39;state -&gt; &#39;dir_ref -&gt; name -&gt; (&#39;state * (&#39;dir_ref * &#39;dir)); 
    new_inode: &#39;state -&gt; (&#39;state * (&#39;inode_ref * &#39;inode)); <span class="co">(* FIXME is dir linked in or not? yes, see mkdir *)</span>
    get_contents: &#39;inode -&gt; file_contents;
    set_contents: &#39;inode -&gt; file_contents -&gt; &#39;inode;
    get_symlink: &#39;inode -&gt; <span class="dt">bool</span>;
    set_symlink: &#39;inode -&gt; <span class="dt">bool</span> -&gt; &#39;inode;
    dest_inode_ref: &#39;state -&gt; &#39;inode_ref -&gt; <span class="dt">int</span>;
    dest_dir_ref: &#39;state -&gt; &#39;dir_ref -&gt; <span class="dt">int</span>;
    get_entries: &#39;dir -&gt; name <span class="dt">list</span>; <span class="co">(* FIXME &#39;dir -&gt; name list ? *)</span>
  }

  <span class="co">(* FIXME not needed? *)</span>
  <span class="co">(*</span>
<span class="co">  type (&#39;dir_ref,&#39;dir,&#39;inode_ref,&#39;inode,&#39;impl) state = {</span>
<span class="co">    ops3: (&#39;dir_ref,&#39;dir,&#39;inode_ref,&#39;inode,&#39;impl) ty_state_ops;</span>
<span class="co">    s3: &#39;impl</span>
<span class="co">  }</span>
<span class="co">  *)</span>

  <span class="kw">type</span> &#39;impl ty_return2 = {
    state2: &#39;impl;
    ret2: ret_value;
  } 
  <span class="kw">let</span> return s = { state2=s; ret2=None1 }


  <span class="kw">type</span> (&#39;dir_ref,&#39;inode_ref,&#39;impl) ty_ops1 = {
    get_init_state1: <span class="dt">unit</span> -&gt; &#39;impl;
    get_root1: &#39;impl -&gt; &#39;dir_ref <span class="dt">option</span>;
    dest_dir_ref1: &#39;impl -&gt; &#39;dir_ref -&gt; <span class="dt">int</span>;
    dest_inode_ref1: &#39;impl -&gt; &#39;inode_ref -&gt; <span class="dt">int</span>;
    get_symlink1: &#39;impl -&gt; &#39;inode_ref -&gt; <span class="dt">bool</span>;
    link_file1: &#39;impl -&gt; &#39;inode_ref -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2;
    unlink1: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2;
    mkdir1: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2;
    mv1: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2;
    mvdir1: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2;
    read1: &#39;impl -&gt; &#39;inode_ref -&gt; &#39;impl ty_return2;
    readdir1: &#39;impl -&gt; &#39;dir_ref -&gt; &#39;impl ty_return2; <span class="co">(* don&#39;t return . and .. entries *)</span>
    resolve11: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; (&#39;dir_ref,&#39;inode_ref) entry <span class="dt">option</span>;
    rm1: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2; <span class="co">(* FIXME don&#39;t need this and unlink1 *)</span>
    rmdir1: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2; <span class="co">(* FIXME probably don&#39;t need this either *)</span>
    touch1: &#39;impl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;impl ty_return2;
    write1: &#39;impl -&gt; &#39;inode_ref -&gt; bytes -&gt; &#39;impl ty_return2;
    set_symlink1: &#39;impl -&gt; &#39;inode_ref -&gt; <span class="dt">bool</span> -&gt; &#39;impl ty_return2;
  }


<span class="kw">end</span></code></pre>
<h2 id="resolve-names"><a href="#resolve-names">Resolve names</a></h2>
<p>We want to take a string such as <code>/x/y/z/d/</code> and process it:</p>
<ul>
<li>extract the components</li>
<li>record whether the string starts in / (* but maybe vfs ensures all strings start in / *)</li>
<li>record whether the string ends in /</li>
<li>process the string (against the current state) to remove .. and . (providing entries exist; if not return ENOENT; function remove_dot_dotdot) and empty entries</li>
<li>then compare result with the current state to determine whether the string
<ol style="list-style-type: decimal">
<li>ends with a / and matches a dir</li>
<li>ends with a / and matches a file (error)</li>
<li>doesn't end with a slash and matches a file or dir</li>
<li>ends with a slash or not, and doesn't match anything</li>
</ol></li>
</ul>
<p>Proposed processing of last step: Ignoring trailing slash, do we match or not? Yes - check agreement with trailing slash (1) and (2) and (3). No - (4)</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">
<span class="co">(* FIXME tidy this up *)</span>
<span class="ot">module</span> X = <span class="kw">struct</span>

  <span class="ot">open</span> Fs_types1
  
  <span class="co">(* hack to get an abstract state type *)</span>
  <span class="ot">module</span> Y : <span class="kw">sig</span> 
    <span class="kw">type</span> t1
    <span class="kw">type</span> t2
    <span class="kw">type</span> t3
    <span class="kw">type</span> t4
    <span class="kw">type</span> t5
  <span class="kw">end</span> = <span class="kw">struct</span> 
    <span class="kw">type</span> t1 = <span class="dt">int</span>
    <span class="kw">type</span> t2 = <span class="dt">int</span>
    <span class="kw">type</span> t3 = <span class="dt">int</span>
    <span class="kw">type</span> t4 = <span class="dt">int</span>
    <span class="kw">type</span> t5 = <span class="dt">int</span>
  <span class="kw">end</span> 

<span class="kw">end</span>

<span class="ot">module</span> Resolve = <span class="kw">struct</span>
 
  <span class="ot">open</span> Prelude
  <span class="ot">open</span> Fs_types1
<span class="co">(*  open Fs_ops1 *)</span>

  <span class="co">(* for the purposes of type-checking the following defns without spurious type vars *)</span>
  <span class="ot">module</span> XR = <span class="kw">struct</span>
    <span class="co">(* type ty_ops&#39; = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)</span>
    <span class="kw">type</span> ty_ops&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3,X<span class="kw">.</span>Y<span class="kw">.</span>t5) ty_ops1
    <span class="kw">type</span> dir_ref&#39; = X<span class="kw">.</span>Y<span class="kw">.</span>t1
    <span class="kw">type</span> ty_impl&#39; = X<span class="kw">.</span>Y<span class="kw">.</span>t5
    <span class="kw">type</span> inode_ref&#39; = X<span class="kw">.</span>Y<span class="kw">.</span>t3
    <span class="kw">type</span> ty_return&#39; = X<span class="kw">.</span>Y<span class="kw">.</span>t5 ty_return2
    <span class="kw">type</span> rname&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3) rname2
  <span class="kw">end</span>
  <span class="ot">open</span> XR


  <span class="co">(* resolve ns, return a (dir_ref,dir); only used with a resolve *)</span>
  <span class="co">(* these seem to be used as shortcuts for looking up parents of a given path; but we want to ensure some invariants in lists of names; on the other hand, given a rname, to resolve the parent we don&#39;t want to have to go via strings *)</span>
  <span class="kw">let</span> resolve_dir_ref ops s0 ns = (
    <span class="co">(* sofar is the dir_ref we currently got to; starts off as the root *)</span>
    <span class="kw">let</span> <span class="kw">rec</span> f1 sofar ns = (<span class="kw">match</span> ns <span class="kw">with</span> 
      | [] -&gt; (<span class="dt">Some</span> sofar)
      | n::ns -&gt; (
        <span class="kw">let</span> m = ops.resolve11 s0 sofar n <span class="kw">in</span>
        <span class="kw">match</span> m <span class="kw">with</span> | <span class="dt">None</span> -&gt; <span class="dt">None</span> | <span class="dt">Some</span> entry -&gt; 
        <span class="kw">match</span> is_dir_ref_entry entry <span class="kw">with</span> | <span class="kw">false</span> -&gt; <span class="dt">None</span> | <span class="kw">true</span> -&gt;
        <span class="kw">let</span> dir_ref = dest_dir_ref_entry entry <span class="kw">in</span> 
        f1 dir_ref ns))
    <span class="kw">in</span>
    <span class="kw">let</span> <span class="dt">Some</span>(d0_ref) = ops.get_root1 s0 <span class="kw">in</span>
    f1 d0_ref ns)
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; ty_impl&#39; -&gt; name <span class="dt">list</span> -&gt; dir_ref&#39; <span class="dt">option</span>) = resolve_dir_ref

  <span class="co">(* let dir_exists ops s0 ns = (resolve_dir_ref ops s0 ns &lt;&gt; None) *)</span>

  <span class="co">(* want to restrict uses of resolve_dir_ref and resolve_inode_ref to this module *)</span>
  <span class="kw">let</span> get_parent_dir ops s0 nl = (
    resolve_dir_ref ops s0 (butlast nl.ns2))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; ty_impl&#39; -&gt; ty_name_list2 -&gt; dir_ref&#39; <span class="dt">option</span>) = get_parent_dir

  <span class="co">(* ns cannot be empty; FIXME this is only used in resolve *)</span>
  <span class="kw">let</span> resolve_inode_ref ops s0 ns = (
    <span class="kw">let</span> r = resolve_dir_ref ops s0 (butlast ns) <span class="kw">in</span>
    <span class="kw">match</span> r <span class="kw">with</span> | <span class="dt">None</span> -&gt; <span class="dt">None</span> | <span class="dt">Some</span> dir_ref -&gt;
    <span class="kw">let</span> n = last ns <span class="kw">in</span>
    <span class="kw">let</span> m = ops.resolve11 s0 dir_ref n <span class="kw">in</span>
    <span class="kw">match</span> m <span class="kw">with</span> | <span class="dt">None</span> -&gt; <span class="dt">None</span> | <span class="dt">Some</span> entry -&gt; 
    <span class="kw">match</span> is_inode_ref_entry entry <span class="kw">with</span> | <span class="kw">false</span> -&gt; <span class="dt">None</span> | <span class="kw">true</span> -&gt; 
    <span class="kw">let</span> i0_ref = dest_inode_ref_entry entry <span class="kw">in</span> <span class="co">(* assume a file *)</span>
    <span class="dt">Some</span>(i0_ref))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; ty_impl&#39; -&gt; name <span class="dt">list</span> -&gt; inode_ref&#39; <span class="dt">option</span>) = resolve_inode_ref    

  <span class="co">(* let file_exists ops s0 ns = (resolve_inode_ref ops s0 ns &lt;&gt; None) *)</span>

  <span class="co">(* assumes path starts with &#39;/&#39;; throws an exception if not; FIXME do we always know the path starts with &#39;/&#39;? *)</span>

  <span class="co">(* take a string, get components and whether ends in slash *)</span>
  <span class="kw">let</span> process_path1 path = (
    <span class="kw">let</span> p = explode path <span class="kw">in</span>
    <span class="kw">if</span> p = [] <span class="kw">then</span> failwith <span class="st">&quot;process_path1: empty path&quot;</span> <span class="kw">else</span>
    <span class="kw">if</span> List<span class="kw">.</span>hd p &lt;&gt; <span class="st">&quot;/&quot;</span> <span class="kw">then</span> failwith <span class="st">&quot;process_path: doesn&#39;t start with /&quot;</span> <span class="kw">else</span>
    <span class="kw">let</span> p = List<span class="kw">.</span>tl p <span class="kw">in</span>
    <span class="kw">let</span> f1 (ns,cur) c = (<span class="kw">if</span> c=<span class="st">&quot;/&quot;</span> <span class="kw">then</span> (ns@[cur],<span class="st">&quot;&quot;</span>) <span class="kw">else</span> (ns,cur^c)) <span class="kw">in</span>
    <span class="kw">let</span> (ns,cur) = List<span class="kw">.</span>fold_left f1 ([],<span class="st">&quot;&quot;</span>) p <span class="kw">in</span>
    <span class="kw">let</span> ends_with_slash = (cur=<span class="st">&quot;&quot;</span>) <span class="kw">in</span>
    <span class="kw">let</span> ns = (<span class="kw">if</span> ends_with_slash <span class="kw">then</span> ns <span class="kw">else</span> ns@[cur]) <span class="kw">in</span> <span class="co">(* FIXME this logic is wrong? if multiple slashes? *)</span>
    <span class="kw">let</span> ns = List<span class="kw">.</span>filter (<span class="kw">fun</span> n -&gt; n &lt;&gt; <span class="st">&quot;.&quot;</span> &amp;&amp; n &lt;&gt; <span class="st">&quot;&quot;</span>) ns <span class="kw">in</span> <span class="co">(* remove empty entries and &quot;.&quot; entries *)</span>
    { ns2=ns; ends_with_slash2=ends_with_slash })
  <span class="kw">let</span> (_:string -&gt; ty_name_list2) = process_path1

  <span class="co">(* preliminary processing of ns; drop empty components and &quot;.&quot; components, and resolve &quot;..&quot; *)</span>
  <span class="co">(* idempotent *)</span>
  <span class="co">(* FIXME this is only OK if the e.g. d/../x/y/z we have that d exists FIXME do not use! *)</span>
  <span class="kw">let</span> process_dotdot ops s0 nl = (
    <span class="kw">let</span> f1 sofar n = (
      <span class="kw">if</span> (n=<span class="st">&quot;..&quot;</span> &amp;&amp; sofar &lt;&gt; []) <span class="kw">then</span> 
        (butlast sofar) 
      <span class="kw">else</span> <span class="kw">if</span> (n=<span class="st">&quot;..&quot;</span> &amp;&amp; sofar = []) <span class="kw">then</span>
        (failwith <span class="st">&quot;process_dot_dotdot&quot;</span>)
      <span class="kw">else</span>
        (sofar@[n])) 
    <span class="kw">in</span>
    <span class="kw">let</span> ns = List<span class="kw">.</span>fold_left f1 [] nl.ns2 <span class="kw">in</span>
    {nl <span class="kw">with</span> ns2=ns})
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; ty_impl&#39; -&gt; ty_name_list2 -&gt; ty_name_list2) = process_dotdot 

  <span class="co">(* take a state and a ty_name_list2, and check if name exists in state *)</span>
  <span class="kw">let</span> process_path2 ops s0 ns = (
    <span class="co">(* FIXME we need to process .. here as well *)</span>
    <span class="kw">match</span> ns.ends_with_slash2 <span class="kw">with</span> 
    | <span class="kw">true</span> -&gt; (
      <span class="kw">let</span> opt = resolve_dir_ref ops s0 ns.ns2 <span class="kw">in</span>
      <span class="kw">match</span> opt <span class="kw">with</span> 
      | <span class="dt">Some</span>(dir_ref) -&gt; <span class="dt">Dname2</span>(dir_ref<span class="co">(*,dest_Some(ops.lookup_dir s0 dir_ref))*)</span>,ns)
      | <span class="dt">None</span> -&gt; (
        <span class="kw">let</span> opt = resolve_inode_ref ops s0 ns.ns2 <span class="kw">in</span> 
        <span class="kw">match</span> opt <span class="kw">with</span>
        | <span class="dt">None</span> -&gt; <span class="dt">None2</span> ns
          <span class="co">(* following case, ns ends with a slash, but resolves to a file *)</span>
        | <span class="dt">Some</span>(iref) -&gt; <span class="dt">Err2</span>(iref<span class="co">(*,dest_Some(ops.lookup_inode s0 iref))*)</span>,ns)))
    | <span class="kw">false</span> -&gt; (
      <span class="kw">let</span> opt = resolve_dir_ref ops s0 ns.ns2 <span class="kw">in</span>
      <span class="kw">match</span> opt <span class="kw">with</span>
      | <span class="dt">Some</span>(dir_ref) -&gt; <span class="dt">Dname2</span>(dir_ref<span class="co">(*,dest_Some(ops.lookup_dir s0 dir_ref))*)</span>,ns)
      | <span class="dt">None</span> -&gt; (
        <span class="kw">let</span> opt = resolve_inode_ref ops s0 ns.ns2 <span class="kw">in</span>
        <span class="kw">match</span> opt <span class="kw">with</span> 
        | <span class="dt">Some</span>(iref) -&gt; <span class="dt">Fname2</span>(iref<span class="co">(*,dest_Some(ops.lookup_inode s0 iref)*)</span>,ns)
        | <span class="dt">None</span> -&gt; <span class="dt">None2</span> ns)))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; ty_impl&#39; -&gt; ty_name_list2 -&gt; rname&#39;) = process_path2

  <span class="co">(* guarantees: returns option of Fname or Dname  *)</span>
  <span class="kw">let</span> process_path ops s0 path = (
    <span class="kw">let</span> nl = process_path1 path <span class="kw">in</span>
    <span class="kw">let</span> nl = process_dotdot ops s0 nl <span class="kw">in</span>
    <span class="kw">let</span> rpath = process_path2 ops s0 nl <span class="kw">in</span>
    rpath)  
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; ty_impl&#39; -&gt; <span class="dt">string</span> -&gt; rname&#39;) = process_path

  <span class="co">(* FIXME we want subsequent defns to work in terms of rname, and possible ty_name_list2; we want invariants on these *)</span>

  <span class="kw">let</span> <span class="kw">rec</span> list_prefix xs ys = (
    <span class="kw">match</span> (xs,ys) <span class="kw">with</span>
    | ([],_) -&gt; <span class="kw">true</span>
    | (_,[]) -&gt; <span class="kw">false</span>
    | (x::xs,y::ys) -&gt; (
      <span class="kw">if</span> (x=y) <span class="kw">then</span> list_prefix xs ys <span class="kw">else</span> <span class="kw">false</span>))

  <span class="co">(* check if renaming a dir to a subdir of itself *)</span>
  <span class="kw">let</span> subdir nl_src nl_dst = (list_prefix nl_src.ns2 nl_dst.ns2)

<span class="kw">end</span></code></pre>
<h2 id="fs_ops2"><a href="#fs_ops2"><code>Fs_ops2</code></a></h2>
<p>Fs ops is very precise about what each argument is expected to be. Dirnames start and end in <code>/</code>. Filenames must not end in <code>/</code>. We don't check that the target of a <code>mv</code> is empty, or doesn't exist etc. However, at the command line, there is some ambiguity:</p>
<ul>
<li><p>assuming <code>tmp.txt</code> is a file, then <code>mv tmp.txt d</code> will treat <code>d</code> as a file (if no d exists), or as a dir (if d exists and is a dir)</p></li>
<li><p><code>mv tmp.txt d/</code> will treat <code>d/</code> as a dir always</p></li>
</ul>
<p>So some possible sources of ambiguity are:</p>
<ul>
<li><p>is <code>tmp.txt</code> a file or a directory? (if it exists, then it is whatever it is)</p></li>
<li><p>if we mean a dir, we can add a '/', and this makes clear what we mean; if we don't add a '/' then the fs may not know whether we intend a file or directory</p></li>
<li><p>even if we are clear that we mean a dir, there can be multiple interpretations: <code>mv c/ e/</code> renames c to e, providing e doesn't already exist; if e does exist, then c goes into e</p></li>
<li><p><code>mv c/ e/</code> will overwrite a directory <code>e/c</code> if <code>e/c</code> is empty; will fail if <code>e/c</code> is not empty</p></li>
</ul>
<p>At the user level, there is some extra logic which makes commands behave differently eg if the target is absent, or a file, or a directory eg for the command <code>mv src dst</code></p>
<ul>
<li><p>if src is a file, and dst is a dir, then src is moved into dir</p></li>
<li><p>if src if a file and dst is a file, then src is moved over dst (dst is unlinked)</p></li>
<li><p>if src is a dir and dst is a dir, then</p></li>
</ul>
<p>Some criteria:</p>
<ul>
<li><p>src,dst ends in '/'</p></li>
<li><p>src,dst exists/not exists (but how to connect name to entity? the point is that this connection is heuristic in some sense; proposal: given a fordname, check whether a dir exists with that name; if not, attempt to interpret as file)</p></li>
<li><p>src,dst exists and is a file/ is a dir</p></li>
</ul>
<p>Proposed <code>mv</code> processing stages:</p>
<ol style="list-style-type: decimal">
<li><p>if either src or dst is fordname (no trailing /) then try to disambiguate: if directory src exists, then src is a dirname, otherwise filename; from this point onwards, we use &quot;src&quot; to indicate a filename, and &quot;src/&quot; to indicate a dirname</p>
<p><code>mv src dst/</code>: move file src to dst directory; if src doesn't exist, fail; if dst directory doesn't exist, fail</p>
<p><code>mv src/ dst</code>: move directory src to directory dst; dst directory doesn't exist by disambiguation (otherwise the command would have been interpreted as <code>mv src/ dst/</code>); fail if src doesn't exist</p>
<p><code>mv src dst</code>: move file src to file dst; if src doesn't exist, fail</p>
<p><code>mv src/ dst/</code>: if <code>dst</code> exists, then attempt to move dir src to a subdirectory of dst; if <code>dst/src</code> file exists, overwrite; if <code>dst/src</code> dir exists, and is empty, then do the move, otherwise fail</p></li>
</ol>
<p>Note: these options don't even include checking whether src and dst are soft links (which further complicates matters; FIXME we don't deal with soft links at this stage)</p>
<p>For the moment, we content ourselves with the following horrible code...</p>
<p>For <code>Fs_ops2</code> we provide functions from state to Inl of state * err, or Inr of state * ret</p>
<p>--</p>
<p>Invariant: if any exception is raised, the state is not changed</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">
<span class="co">(* FIXME these work in terms of rnames; assumes no Err2 *)</span>
<span class="ot">module</span> Fs_ops2 = <span class="kw">struct</span>
  
  <span class="ot">open</span> Unix <span class="co">(* for st_dev record fields etc *)</span>
  <span class="ot">open</span> LargeFile <span class="co">(* FIXME include stats in Fs_types1? *)</span>

  <span class="ot">open</span> Prelude
  <span class="ot">open</span> Fs_types1
<span class="co">(*  open Fs_ops1 *)</span>
  <span class="co">(* open Resolve *)</span>

  <span class="kw">let</span> get_parent_dir = Resolve<span class="kw">.</span>get_parent_dir
  <span class="kw">let</span> resolve_process_path2 = Resolve<span class="kw">.</span>process_path2
  <span class="kw">let</span> resolve_subdir = Resolve<span class="kw">.</span>subdir

  <span class="co">(* type error = Fs_types1.error *)</span>
  <span class="kw">type</span> (&#39;impl,&#39;a) ty_return3 = ((&#39;impl * Fs_types1<span class="kw">.</span>error, &#39;impl * &#39;a) sum) finset
  <span class="co">(* vars u, v used eg for Mymonad u *)</span>
  <span class="kw">type</span> (&#39;impl,&#39;a) mymonad = <span class="dt">Mymonad</span> <span class="kw">of</span> (&#39;impl -&gt; (&#39;impl,&#39;a) ty_return3)
  <span class="kw">let</span> dest_mymonad (<span class="dt">Mymonad</span> u) = u
  <span class="kw">let</span> return x = <span class="dt">Mymonad</span> (<span class="kw">fun</span> s -&gt; finset_insert (<span class="dt">Inr</span>(s,x)) finset_empty)
  <span class="kw">let</span> (_:&#39;a -&gt; (&#39;impl,&#39;a) mymonad) = return

  <span class="co">(* for the purposes of type-checking the following defns without spurious type vars *)</span>
  <span class="co">(* N.B. these dummy X module defns are interesting because they show what types are used in each module *)</span>
  <span class="ot">module</span> X2 = <span class="kw">struct</span>
    <span class="kw">type</span> &#39;a ty_return3&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t5,&#39;a) ty_return3
    <span class="kw">type</span> &#39;a ty_mymonad&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t5,&#39;a) mymonad
    <span class="kw">type</span> rname2&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3) rname2    
    <span class="co">(* type ty_ops&#39; = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)</span>
    <span class="kw">type</span> ty_ops&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3,X<span class="kw">.</span>Y<span class="kw">.</span>t5) ty_ops1
  <span class="kw">end</span>
  <span class="ot">open</span> X2

  <span class="kw">let</span> bind u f = <span class="dt">Mymonad</span> (<span class="kw">fun</span> s0 -&gt;
    <span class="kw">let</span> u = dest_mymonad u <span class="kw">in</span>
    <span class="kw">let</span> rs = u s0 <span class="kw">in</span>
    <span class="kw">let</span> f1 v = (<span class="kw">match</span> v <span class="kw">with</span> 
      | <span class="dt">Inl</span> x -&gt; (finset_singleton (<span class="dt">Inl</span> x))
      | <span class="dt">Inr</span> (s,x) -&gt; (
        <span class="kw">let</span> v = dest_mymonad (f x) <span class="kw">in</span>
        v s))
    <span class="kw">in</span>
    <span class="kw">let</span> rs&#39; = finset_image f1 rs <span class="kw">in</span>
    <span class="kw">let</span> rs&#39;&#39; = finset_bigunion rs&#39; <span class="kw">in</span>
    rs&#39;&#39;)    
  <span class="kw">let</span> (_: &#39;a ty_mymonad&#39; -&gt; (&#39;a -&gt; &#39;b ty_mymonad&#39;) -&gt; &#39;b ty_mymonad&#39;) = bind

  <span class="co">(* FIXME we also want to bake in that as soon as we have an exception, we will not alter the state further *)</span>

  <span class="kw">let</span> ( &gt;&gt;= ) = bind
  
  <span class="kw">let</span> get_state = <span class="dt">Mymonad</span> (<span class="kw">fun</span> (s) -&gt; finset_singleton(<span class="dt">Inr</span>(s,s)))
  <span class="kw">let</span> put_state s0 = <span class="dt">Mymonad</span> (<span class="kw">fun</span> (s) -&gt; finset_singleton(<span class="dt">Inr</span>(s0,<span class="dt">None1</span>)))
  <span class="kw">let</span> myraise e = <span class="dt">Mymonad</span> (<span class="kw">fun</span> (s) -&gt; finset_singleton(<span class="dt">Inl</span>(s,e)))
  <span class="kw">let</span> maybe_raise e = <span class="dt">Mymonad</span> (<span class="kw">fun</span> (s) -&gt; 
    finset_insert (<span class="dt">Inr</span>(s,())) (finset_singleton(<span class="dt">Inl</span>(s,e))))

  <span class="kw">let</span> choose xs = <span class="dt">Mymonad</span> (<span class="kw">fun</span> s -&gt; finset_image (<span class="kw">fun</span> x -&gt; <span class="dt">Inr</span>(s,x)) xs)

  <span class="co">(* for a deterministic version, choose some particular value *)</span>
  <span class="kw">let</span> choose xs = <span class="dt">Mymonad</span> (<span class="kw">fun</span> s -&gt; finset_singleton(<span class="dt">Inr</span>(s,finset_choose xs)))

  <span class="kw">let</span> do_nothing = <span class="dt">Mymonad</span> (<span class="kw">fun</span> s -&gt; finset_singleton(<span class="dt">Inr</span>(s,())))

  <span class="kw">let</span> run_mymonad (<span class="dt">Mymonad</span> f) s = (f (s))
  <span class="kw">let</span> (_:(&#39;a,&#39;b) mymonad -&gt; &#39;a -&gt; (&#39;a,&#39;b) ty_return3) = run_mymonad
  
  <span class="co">(*  let is_empty_dir (s0:&#39;impl) ns = failwith &quot;FIXME&quot; *)</span>

  <span class="kw">let</span> default_stats = {
    st_dev = 2049; <span class="co">(* device number FIXME 0? *)</span>
    st_ino = 999; <span class="co">(* inode number FIXME change this for particular file etc *)</span>
    st_kind = Unix<span class="kw">.</span><span class="dt">S_DIR;</span> <span class="co">(* FIXME *)</span>
    st_perm = 0o777; <span class="co">(* ugo+rwx *)</span>
    st_nlink = 2; <span class="co">(* FIXME dummy - for dir should be number of entries + 2 *)</span>
    st_uid = 1000; <span class="co">(* FIXME 0? *)</span>
    st_gid = 1000; 
    st_rdev = 0; <span class="co">(* device minor number *)</span>
    st_size = 4096L; <span class="co">(* FIXME dummy *)</span>
    st_atime = 0.;
    st_mtime = 0.;
    st_ctime = 0.
  }

  <span class="kw">let</span> default_file_stats ops s0 i0_ref = { default_stats <span class="kw">with</span>
    st_ino=(ops.dest_inode_ref1 s0 i0_ref);
    st_kind=(
      <span class="kw">if</span> (ops.get_symlink1 s0 i0_ref) <span class="kw">then</span> Unix<span class="kw">.</span><span class="dt">S_LNK</span> <span class="kw">else</span> Unix<span class="kw">.</span><span class="dt">S_REG</span>); <span class="co">(* FIXME we may need our own stats structure *)</span>
    st_size=(
      <span class="kw">let</span> bs = dest_bytes1 ((ops.read1 s0 i0_ref).ret2) <span class="kw">in</span>
      (Int64<span class="kw">.</span>of_int (MyDynArray<span class="kw">.</span>dim bs)))
  }
 
  <span class="kw">let</span> default_dir_stats ops s0 d0_ref = { default_stats <span class="kw">with</span>
    st_ino=(ops.dest_dir_ref1 s0 d0_ref);
    st_kind=Unix.<span class="dt">S_DIR;</span>
    st_size=4096L; <span class="co">(* seems to be default on my system - but changes depending on number of entries? *)</span>
  }

  <span class="co">(* Fs_ops1 returns ty_return3, which apart from read is just a state *)</span>
  <span class="kw">let</span> put_state&#39; r = put_state r.state2

  <span class="co">(* FIXME remove *)</span>
  <span class="kw">let</span> put_state&#39;&#39; f = (put_state&#39; (f ()))

  <span class="kw">let</span> link ops spath dpath = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">match</span> spath <span class="kw">with</span> 
    | <span class="dt">Fname2</span>(i0_ref,ns_src)  -&gt; (
      <span class="kw">match</span> dpath <span class="kw">with</span> 
      | <span class="dt">None2</span> ns_dst -&gt; (
        <span class="kw">let</span> <span class="dt">Some</span>(d0_ref) = get_parent_dir ops s0 ns_dst <span class="kw">in</span>
        <span class="kw">let</span> s0 = ops.link_file1 s0 i0_ref d0_ref (last ns_dst.ns2) <span class="kw">in</span>
        put_state&#39; s0)
      | _ -&gt; (myraise <span class="dt">EEXIST</span>))
    | _ -&gt; (myraise <span class="dt">ENOENT</span>))

  <span class="kw">let</span> mkdir ops rpath perms = (
    <span class="co">(* FIXME deal with perms *)</span>
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">match</span> rpath <span class="kw">with</span> 
    | <span class="dt">None2</span>(ns) -&gt; (
      <span class="kw">let</span> <span class="dt">Some</span>(d0_ref) = get_parent_dir ops s0 ns <span class="kw">in</span>
      <span class="kw">let</span> s0 = ops.mkdir1 s0 d0_ref (last ns.ns2) <span class="kw">in</span>
      put_state&#39; s0)
    | <span class="dt">Dname2</span>(_,_) -&gt; (myraise <span class="dt">EEXIST</span>)
    | <span class="dt">Fname2</span>(_,_) -&gt; (myraise <span class="dt">EEXIST</span>))

  <span class="kw">let</span> open_create ops rpath = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">match</span> rpath <span class="kw">with</span> 
    | <span class="dt">Dname2</span>(_,_) -&gt; (myraise <span class="dt">EEXIST</span>) 
    | <span class="dt">Fname2</span>(_,_) -&gt; (myraise <span class="dt">EEXIST</span>)
    | <span class="dt">None2</span> ns -&gt; (
      <span class="co">(* FIXME for us, open_create should only create files *)</span>
      <span class="kw">if</span> ns.ends_with_slash2 <span class="kw">then</span> 
        myraise <span class="dt">EISDIR</span>
      <span class="co">(* maybe we are trying to create a file &quot;&quot; ie path was empty FIXME where is this from? *)</span>
      <span class="kw">else</span> <span class="kw">if</span> ns.ns2 = [] <span class="kw">then</span> 
        myraise <span class="dt">ENOENT</span>
      <span class="co">(* FIXME need to look at mode *)</span>
      <span class="kw">else</span>
        <span class="kw">let</span> dname = butlast ns.ns2 <span class="kw">in</span>
        <span class="kw">let</span> fname = last ns.ns2 <span class="kw">in</span>
        <span class="co">(* FIXME following is unusual *)</span>
        <span class="kw">let</span> dpath = resolve_process_path2 ops s0 { ns2=dname; ends_with_slash2=false } <span class="kw">in</span>
        <span class="kw">match</span> dpath <span class="kw">with</span>
        | <span class="dt">Dname2</span>(d0_ref,ns) -&gt; (
          <span class="kw">let</span> s0 = ops.touch1 s0 d0_ref fname <span class="kw">in</span>
          put_state&#39; s0)
      | <span class="dt">Fname2</span>(_,_) -&gt; (myraise <span class="dt">ENOTDIR</span>)
      | _ -&gt; (myraise <span class="dt">ENOENT</span>)))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; rname2&#39; -&gt; ret_value ty_mymonad&#39;) = open_create

  <span class="co">(* FIXME the real spec would allow reading less than all the bytes; recall len is maxlen *)</span>
  <span class="kw">let</span> read ops rname2 ofs len = (
    <span class="kw">match</span> rname2 <span class="kw">with</span> 
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>)
    | <span class="dt">Dname2</span>(_,_) -&gt; (myraise <span class="dt">ENOENT</span>)
    | <span class="dt">Fname2</span>(i0_ref,ns) -&gt; (
      get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (
      <span class="kw">let</span> r = ops.read1 s0 i0_ref <span class="kw">in</span> <span class="co">(* FIXME Fs_ops1 may have to take an offset too *)</span>
      (put_state&#39; r) &gt;&gt;= <span class="kw">fun</span> _ -&gt; 
      <span class="co">(* non-deterministically choose the amount of data to write *)</span>
      choose (downto&#39; len 0) &gt;&gt;= <span class="kw">fun</span> len -&gt;
      <span class="kw">let</span> bs = dest_bytes1 r.ret2 <span class="kw">in</span>
      <span class="kw">let</span> len_bs = MyDynArray<span class="kw">.</span>dim bs <span class="kw">in</span>
      <span class="co">(* assume ofs is wellformed *)</span>
      <span class="kw">let</span> len = <span class="kw">if</span> ofs+len &lt;= len_bs <span class="kw">then</span> len <span class="kw">else</span> len_bs - ofs <span class="kw">in</span>
      <span class="co">(* let _ = print_endline (&quot;read len_bs: &quot;^(string_of_int len_bs)^&quot;; len: &quot;^(string_of_int len)^&quot;; ofs: &quot;^(string_of_int ofs)) in *)</span>
      <span class="co">(* let _ = print_endline &quot;before&quot; in *)</span>
      <span class="kw">let</span> bs&#39; = MyDynArray<span class="kw">.</span>sub bs ofs len <span class="kw">in</span>
      <span class="co">(* let _ = print_endline &quot;after&quot; in *)</span>
      return (<span class="dt">Bytes1</span>(bs&#39;))))))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; rname2&#39; -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; ret_value ty_mymonad&#39;) = read

  <span class="co">(* NB doesn&#39;t include . and .. *)</span>
  <span class="kw">let</span> readdir ops rname2 = (
    get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (
    <span class="kw">match</span> rname2 <span class="kw">with</span> 
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>) <span class="co">(* (raise (Unix_error (ENOENT,&quot;readdir&quot;,&quot;/FIXMEreaddir&quot;))) (* FIXME we may need access to the underlying path that was given by the user *) *)</span>
    | <span class="dt">Fname2</span> _ -&gt; (myraise <span class="dt">ENOTDIR</span>) <span class="co">(* (raise (Unix_error (ENOTDIR,&quot;readdir&quot;,&quot;/FIXMEreaddir&quot;))) *)</span>
    | <span class="dt">Dname2</span>(d0_ref,ns) -&gt; (
      <span class="kw">let</span> r = ops.readdir1 s0 d0_ref <span class="kw">in</span>
      (put_state&#39; r) &gt;&gt;= (<span class="kw">fun</span> _ -&gt; (
      return r.ret2))))))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; rname2&#39; -&gt; ret_value ty_mymonad&#39;) = readdir
  <span class="co">(* NB later we may want to also return a state, given access times can cause changes when reading etc *)</span>

  <span class="co">(* FIXME surely a lot of this complexity is because this is the user land behaviour of the mv command - but we want to target the syscall interface *)</span>
  <span class="co">(* FIXME we probably want the containing dirs as well, when doing rename; put this in resolve *)</span>
  <span class="co">(* FIXME rename to subdir of self? *)</span>
  <span class="kw">let</span> rename ops rsrc rdst = (
    get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; 
    <span class="kw">match</span> rsrc <span class="kw">with</span>
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>) <span class="co">(* no src file *)</span>
    | <span class="dt">Err2</span> (_,_) -&gt; (myraise <span class="dt">ENOTDIR</span>)
    | <span class="dt">Fname2</span> (i0_ref,ns_src) -&gt; (
      <span class="kw">match</span> rdst <span class="kw">with</span> 
      | <span class="dt">None2</span> ns_dst -&gt; (
        <span class="co">(* do the move; there is no file ns_dst *)</span>
        <span class="co">(* FIXME check rename to target where parent doesn&#39;t exist *)</span>
        <span class="kw">match</span> get_parent_dir ops s0 ns_dst <span class="kw">with</span>
        | <span class="dt">None</span> -&gt; (myraise <span class="dt">ENOENT</span>) <span class="co">(* parent dir of dst doesn&#39;t exist *)</span>
        | <span class="dt">Some</span>(d1_ref) -&gt; (
          <span class="kw">let</span> <span class="dt">Some</span>(d0_ref) = get_parent_dir ops s0 ns_src <span class="kw">in</span>
          put_state&#39;&#39; (<span class="kw">fun</span> () -&gt; ops.mv1 s0 d0_ref (last ns_src.ns2) d1_ref (last ns_dst.ns2))))
      | <span class="dt">Fname2</span> (i1_ref,ns_dst) -&gt; (
        <span class="co">(* do the move; there is a file name ns_dst *)</span>
        <span class="kw">let</span> <span class="dt">Some</span>(d0_ref) = get_parent_dir ops s0 ns_src <span class="kw">in</span>
        <span class="kw">let</span> <span class="dt">Some</span>(d1_ref) = get_parent_dir ops s0 ns_dst <span class="kw">in</span>
        <span class="kw">if</span> (ns_dst.ns2=ns_src.ns2) <span class="kw">then</span> 
          return <span class="dt">None1</span> 
        <span class="kw">else</span>
          put_state&#39;&#39; (<span class="kw">fun</span> () -&gt; ops.mv1 s0 d0_ref (last ns_src.ns2) d1_ref (last ns_dst.ns2)))
        <span class="co">(* FIXME may want to have putstate return a void value *)</span>
      | <span class="dt">Dname2</span> (d0_ref,ns_dst) -&gt; (
        <span class="co">(* several reasonable options *)</span>
        <span class="co">(* arguably a Linux bug? *)</span>
        (<span class="kw">if</span> (ns_dst.ends_with_slash2) <span class="kw">then</span> 
          maybe_raise <span class="dt">ENOTDIR</span> 
        <span class="kw">else</span> 
          do_nothing) &gt;&gt;= (<span class="kw">fun</span> _ -&gt; 
        <span class="kw">if</span> ((ops.readdir1 s0 d0_ref).ret2&lt;&gt;Names1[]) <span class="kw">then</span> 
          maybe_raise <span class="dt">ENOTEMPTY</span>
        <span class="kw">else</span>
          do_nothing) &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
        myraise <span class="dt">EISDIR</span>))
      | <span class="dt">Err2</span>(_,_) -&gt; (
        myraise <span class="dt">ENOTDIR</span>))
    | <span class="dt">Dname2</span> (d0_ref,ns_src) -&gt; (
      <span class="co">(* directory exists *)</span>
      <span class="kw">match</span> rdst <span class="kw">with</span>
      | <span class="dt">None2</span> ns_dst -&gt; (
        <span class="co">(* do the move; there is no file ns_dst *)</span>
        <span class="kw">let</span> <span class="dt">Some</span>(d0_ref) = get_parent_dir ops s0 ns_src <span class="kw">in</span>
        <span class="kw">match</span> get_parent_dir ops s0 ns_dst <span class="kw">with</span>
        | <span class="dt">None</span> -&gt; (myraise <span class="dt">ENOENT</span>) <span class="co">(* parent dir of dst doesn&#39;t exist *)</span>
        | <span class="dt">Some</span>(d1_ref) -&gt; (
          <span class="kw">if</span> (resolve_subdir ns_src ns_dst) <span class="kw">then</span> 
            myraise <span class="dt">EINVAL</span>
          <span class="kw">else</span>
            put_state&#39;&#39; (<span class="kw">fun</span> () -&gt; ops.mvdir1 s0 d0_ref (last ns_src.ns2) d1_ref (last ns_dst.ns2))))
      | <span class="dt">Err2</span> (_,ns_dst) -&gt; (
        (<span class="kw">if</span> (resolve_subdir ns_src ns_dst) <span class="kw">then</span>
          maybe_raise <span class="dt">EINVAL</span> 
        <span class="kw">else</span> 
          do_nothing) &gt;&gt;= (<span class="kw">fun</span> _ -&gt; 
        myraise <span class="dt">ENOTDIR</span>))
      | <span class="dt">Fname2</span> (_,ns_dst) -&gt; (
        <span class="co">(* check rename to subdir before rename to file; NB there are different reasonable options here *)</span>
        (<span class="kw">if</span> (resolve_subdir ns_src ns_dst) <span class="kw">then</span>
          maybe_raise <span class="dt">EINVAL</span> 
        <span class="kw">else</span> 
          do_nothing) &gt;&gt;= (<span class="kw">fun</span> _ -&gt; 
        myraise <span class="dt">ENOTDIR</span>)) <span class="co">(* arguably this is a bug in linux? *)</span>
      | <span class="dt">Dname2</span> (d1_ref,ns_dst) -&gt; (
        <span class="co">(* if same dir, return silently *)</span>
        <span class="kw">if</span> (d1_ref=d0_ref) <span class="kw">then</span>
          (return <span class="dt">None1</span>)
        <span class="co">(* FIXME check if renaming to a subdir *)</span> <span class="co">(* FIXME following two exceptions should be maybe_raise *)</span>
        <span class="kw">else</span> <span class="kw">if</span> (resolve_subdir ns_src ns_dst) <span class="kw">then</span> 
          (myraise <span class="dt">EINVAL</span>)
        <span class="co">(* FIXME check if dir not empty *)</span>
        <span class="kw">else</span> <span class="kw">if</span> ((ops.readdir1 s0 d1_ref).ret2&lt;&gt;Names1[]) <span class="kw">then</span> 
          (myraise <span class="dt">ENOTEMPTY</span>) 
        <span class="co">(* otherwise target dir is empty; do rename; FIXME presumably root, if empty, can&#39;t be target unless src=root *)</span>
        <span class="co">(* FIXME with the unix backend, we really don&#39;t want to execute this last because we know we are going to raise an error; but we must allow for future stages to raise further exceptions *)</span>
        <span class="kw">else</span>
          <span class="kw">let</span> <span class="dt">Some</span>(d0_ref) = get_parent_dir ops s0 ns_src <span class="kw">in</span>
          <span class="kw">let</span> <span class="dt">Some</span>(d1_ref) = get_parent_dir ops s0 ns_dst <span class="kw">in</span>
          put_state&#39;&#39; (<span class="kw">fun</span> () -&gt; ops.mvdir1 s0 d0_ref (last ns_src.ns2) d1_ref (last ns_dst.ns2))))))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; rname2&#39; -&gt; rname2&#39; -&gt; ret_value ty_mymonad&#39;) = rename      

  <span class="kw">let</span> rmdir ops rpath = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">match</span> rpath <span class="kw">with</span> 
    | <span class="dt">Dname2</span>(_,ns) -&gt; (
      <span class="co">(* FIXME for resolving a file, often useful to have dir ref as well *)</span>
      <span class="kw">let</span> <span class="dt">Some</span>(d0_ref) = get_parent_dir ops s0 ns <span class="kw">in</span>
      <span class="kw">let</span> s0 = ops.unlink1 s0 d0_ref (last ns.ns2) <span class="kw">in</span>
      put_state&#39; s0)
    | <span class="dt">Fname2</span> _ -&gt; (myraise <span class="dt">ENOTDIR</span>)
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>))

  <span class="kw">let</span> stat ops rname2 = (
    get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (
    <span class="co">(* let _ = (print_endline (&quot;stat: &quot;^(string_of_rname2 rname2))) in *)</span>
    <span class="kw">match</span> rname2 <span class="kw">with</span>
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>)  <span class="co">(* (raise (Unix_error (ENOENT,&quot;stat&quot;,&quot;/FIXMEstat&quot;))) *)</span>
    | <span class="dt">Fname2</span>(i0_ref,ns) -&gt; (return (<span class="dt">Stats1</span> (default_file_stats ops s0 i0_ref)))
    | <span class="dt">Dname2</span>(d0_ref,ns) -&gt; (return (<span class="dt">Stats1</span> (default_dir_stats ops s0 d0_ref)))))) <span class="co">(* FIXME remove ops arg from default_dir_stats *)</span>
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; rname2&#39; -&gt; ret_value ty_mymonad&#39;) = stat

  <span class="kw">let</span> truncate ops rpath len = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">match</span> rpath <span class="kw">with</span> 
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>)
    | <span class="dt">Dname2</span>(_,_) -&gt; (myraise <span class="dt">EISDIR</span>) <span class="co">(* FIXME check error messages are sensible *)</span>
    | <span class="dt">Fname2</span>(i0_ref,ns) -&gt; (
      <span class="kw">let</span> r = ops.read1 s0 i0_ref <span class="kw">in</span>
      <span class="kw">let</span> bs = dest_bytes1 r.ret2 <span class="kw">in</span>
      <span class="co">(* create a new array, of length len, with same contents *)</span>
      <span class="kw">let</span> bs&#39; = MyDynArray<span class="kw">.</span>resize bs len <span class="kw">in</span>
      <span class="kw">let</span> s0 = ops.write1 s0 i0_ref bs&#39; <span class="kw">in</span>
      put_state&#39; s0))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; rname2&#39; -&gt; <span class="dt">int</span> -&gt; ret_value ty_mymonad&#39;) = truncate

  <span class="kw">let</span> unlink ops rpath = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">match</span> rpath <span class="kw">with</span> 
    | <span class="dt">None2</span>(_) -&gt; (myraise <span class="dt">ENOENT</span>)
    | <span class="dt">Dname2</span>(_,_) -&gt; (myraise <span class="dt">EISDIR</span>)
    | <span class="dt">Fname2</span>(i0_ref,ns) -&gt; (
      <span class="co">(* FIXME for resolving a file, often useful to have dir ref as well *)</span>
      <span class="kw">let</span> <span class="dt">Some</span>(d0_ref) = get_parent_dir ops s0 ns <span class="kw">in</span>
      <span class="kw">let</span> s0 = ops.unlink1 s0 d0_ref (last ns.ns2) <span class="kw">in</span>
      put_state&#39; s0))

  <span class="co">(* FIXME we need to make this take an offset in order to be usable, also read *)</span>
  <span class="kw">let</span> write ops rname2 ofs bs len = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt; 
    <span class="kw">match</span> rname2 <span class="kw">with</span> 
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>) <span class="co">(* (raise (Unix_error (ENOENT,&quot;read&quot;,&quot;/FIXMEwrite&quot;))) *)</span>
    | <span class="dt">Dname2</span>(_,_) -&gt; (myraise <span class="dt">ENOENT</span>) <span class="co">(* (raise (Unix_error (ENOENT,&quot;read&quot;,&quot;/FIXMEwrite&quot;))) *)</span>
    | <span class="dt">Fname2</span>(i0_ref,ns) -&gt; (
      choose (downto&#39; len 0) &gt;&gt;= <span class="kw">fun</span> len -&gt;
      <span class="kw">let</span> r = ops.read1 s0 i0_ref <span class="kw">in</span>
      <span class="kw">let</span> bs&#39; = dest_bytes1 r.ret2 <span class="kw">in</span>
      <span class="co">(* want to create a new array from bs&#39; and bs *)</span>
      <span class="kw">let</span> bs&#39;&#39; = MyDynArray<span class="kw">.</span>write (bs,0,len) (bs&#39;,ofs) <span class="kw">in</span>
      <span class="kw">let</span> r = ops.write1 s0 i0_ref bs&#39;&#39; <span class="kw">in</span>
      put_state&#39; r &gt;&gt;= <span class="kw">fun</span> _ -&gt; 
      return (<span class="dt">Int1</span> len)))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; rname2&#39; -&gt; <span class="dt">int</span> -&gt; file_contents -&gt; <span class="dt">int</span> -&gt; ret_value ty_mymonad&#39;) = write


<span class="kw">end</span></code></pre>
<h2 id="fs_ops3"><a href="#fs_ops3"><code>Fs_ops3</code></a></h2>
<p>This works in terms of strings; handles Err2 on resolving</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">
<span class="co">(* FIXME check mv if src=dst *)</span>
<span class="ot">module</span> Fs_ops3 = <span class="kw">struct</span> 

  <span class="ot">open</span> Fs_types1
  <span class="ot">open</span> Resolve
  <span class="ot">open</span> Fs_ops2


  <span class="co">(* for the purposes of type-checking the following defns without spurious type vars *)</span>
  <span class="ot">module</span> X3 = <span class="kw">struct</span> 
    <span class="kw">type</span> &#39;a ty_return3&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t5,&#39;a) ty_return3
    <span class="kw">type</span> &#39;a ty_mymonad&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t5,&#39;a) mymonad
    <span class="kw">type</span> rname2&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3) rname2    
    <span class="co">(* type ty_ops&#39; = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)</span>
    <span class="kw">type</span> ty_ops&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3,X<span class="kw">.</span>Y<span class="kw">.</span>t5) ty_ops1
  <span class="kw">end</span>
  <span class="ot">open</span> X3

  <span class="kw">let</span> link ops src dst = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt; 
    <span class="kw">let</span> rsrc = process_path ops s0 src <span class="kw">in</span>
    <span class="kw">let</span> rdst = process_path ops s0 dst <span class="kw">in</span>
    <span class="kw">if</span> (is_Err2 rsrc || is_Err2 rdst) <span class="kw">then</span> (myraise <span class="dt">ENOTDIR</span>) <span class="kw">else</span> Fs_ops2<span class="kw">.</span>link ops rsrc rdst)

  <span class="kw">let</span> mkdir ops path perms = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">let</span> rpath = process_path ops s0 path <span class="kw">in</span>
    <span class="kw">if</span> (is_Err2 rpath) <span class="kw">then</span> (myraise <span class="dt">ENOTDIR</span>) <span class="kw">else</span> Fs_ops2<span class="kw">.</span>mkdir ops rpath perms)

  <span class="co">(* FIXME we have to take care of flags eg O_TRUNC *)</span>
  <span class="co">(* FIXME return is int option - meaning optional file handle? *)</span>
  <span class="co">(* FIXME why is this called fopen (taking an fd?) rather than open? *)</span>
  <span class="co">(* FIXME the mapping between fds and files is handled elsewhere - needs a new part of spec *)</span>
  <span class="kw">let</span> _open ops path flags = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">let</span> rpath = process_path ops s0 path <span class="kw">in</span>
    <span class="kw">match</span> rpath <span class="kw">with</span>
    | <span class="dt">None2</span> _ -&gt; (myraise <span class="dt">ENOENT</span>)
    | <span class="dt">Dname2</span>(_,_) -&gt; (myraise <span class="dt">ENOENT</span>) <span class="co">(* FIXME? can we open a dir? *)</span>
    | _ -&gt; (return <span class="dt">None1</span>))
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; <span class="dt">string</span> -&gt; &#39;a -&gt; ret_value ty_mymonad&#39;) = _open
 
  <span class="co">(* open call returns an fd; but may have side effects; open create is one such call; FIXME what are others? *)</span>
  <span class="kw">let</span> open_create ops path = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">let</span> rpath = process_path ops s0 path <span class="kw">in</span>
    <span class="kw">if</span> (is_Err2 rpath) <span class="kw">then</span> (myraise <span class="dt">ENOTDIR</span>) <span class="kw">else</span> Fs_ops2<span class="kw">.</span>open_create ops rpath)

  <span class="co">(* N.B. for read and write ofs is associated with fd, so presumably &lt; len of file *)</span>
  <span class="kw">let</span> read ops path ofs len = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">let</span> rpath = process_path ops s0 path <span class="kw">in</span>
    <span class="kw">if</span> (is_Err2 rpath) <span class="kw">then</span> (myraise <span class="dt">ENOTDIR</span>) <span class="kw">else</span> Fs_ops2<span class="kw">.</span>read ops rpath ofs len)
  
  <span class="kw">let</span> readdir ops path = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">let</span> rpath = process_path ops s0 path <span class="kw">in</span>
    <span class="kw">if</span> (is_Err2 rpath) <span class="kw">then</span> (myraise <span class="dt">ENOTDIR</span>) <span class="kw">else</span> Fs_ops2<span class="kw">.</span>readdir ops rpath)

  <span class="co">(* FIXME check do_rename against ops2.rename; also check against doc in linux sys programming *)</span>
  <span class="kw">let</span> rename ops src dst = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt; 
    <span class="kw">let</span> rsrc = process_path ops s0 src <span class="kw">in</span>
    <span class="kw">let</span> rdst = process_path ops s0 dst <span class="kw">in</span>
    Fs_ops2<span class="kw">.</span>rename ops rsrc rdst)
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; <span class="dt">string</span> -&gt; <span class="dt">string</span> -&gt; ret_value ty_mymonad&#39;) = rename

  <span class="kw">let</span> rmdir ops path = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">let</span> rpath = process_path ops s0 path <span class="kw">in</span>
    <span class="kw">if</span> (is_Err2 rpath) <span class="kw">then</span> (myraise <span class="dt">ENOTDIR</span>) <span class="kw">else</span> Fs_ops2<span class="kw">.</span>rmdir ops rpath)

  <span class="kw">let</span> stat ops path = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">let</span> rpath = process_path ops s0 path <span class="kw">in</span>
    <span class="kw">if</span> (is_Err2 rpath) <span class="kw">then</span> (myraise <span class="dt">ENOTDIR</span>) <span class="kw">else</span> Fs_ops2<span class="kw">.</span>stat ops rpath)

  <span class="kw">let</span> truncate ops path len = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">let</span> rpath = process_path ops s0 path <span class="kw">in</span>
    <span class="kw">if</span> (is_Err2 rpath) <span class="kw">then</span> (myraise <span class="dt">ENOTDIR</span>) <span class="kw">else</span> Fs_ops2<span class="kw">.</span>truncate ops rpath len)

  <span class="kw">let</span> unlink ops path = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">let</span> rpath = process_path ops s0 path <span class="kw">in</span>
    <span class="kw">if</span> (is_Err2 rpath) <span class="kw">then</span> (myraise <span class="dt">ENOTDIR</span>) <span class="kw">else</span> Fs_ops2<span class="kw">.</span>unlink ops rpath)

  <span class="kw">let</span> write ops path ofs bs len = (
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">let</span> rpath = process_path ops s0 path <span class="kw">in</span>
    <span class="kw">if</span> (is_Err2 rpath) <span class="kw">then</span> (myraise <span class="dt">ENOTDIR</span>) <span class="kw">else</span> Fs_ops2<span class="kw">.</span>write ops rpath ofs bs len)

  <span class="co">(* FIXME this is a hack - should do lots of checking eg src is a dir *)</span>
  <span class="kw">let</span> symlink ops src dst = (
    open_create ops dst &gt;&gt;= <span class="kw">fun</span> _ -&gt; 
    write ops dst 0 (MyDynArray<span class="kw">.</span>of_string src) (String<span class="kw">.</span>length src) &gt;&gt;= <span class="kw">fun</span> _ -&gt; 
    get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">let</span> rpath = process_path ops s0 dst <span class="kw">in</span>
    <span class="kw">let</span> <span class="dt">Fname2</span>(i0_ref,_) = rpath <span class="kw">in</span>
    <span class="kw">let</span> r = ops.set_symlink1 s0 i0_ref <span class="kw">true</span> <span class="kw">in</span>
    put_state&#39; r)
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; <span class="dt">string</span> -&gt; <span class="dt">string</span> -&gt; ret_value ty_mymonad&#39;) = symlink    

<span class="kw">end</span>
</code></pre>
<h2 id="transition-system"><a href="#transition-system">Transition system</a></h2>
<p>The model is of a labelled transition system from state to state, but where each transition may result in a return to userland (of a value or an error). FIXME need to be non-determinisitic eg in write and read behaviour.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">
<span class="ot">module</span> Transition_system = <span class="kw">struct</span>

  <span class="ot">open</span> Prelude 
  <span class="ot">open</span> Fs_types1
  <span class="ot">open</span> Fs_ops2
  <span class="ot">open</span> Fs_ops3

  <span class="ot">module</span> X4 = <span class="kw">struct</span> 
    <span class="co">(* for the purposes of type-checking the following defns without spurious type vars *)</span>
    <span class="co">(* type ty_ops&#39; = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)</span>
    <span class="kw">type</span> ty_ops&#39; = (X<span class="kw">.</span>Y<span class="kw">.</span>t1,X<span class="kw">.</span>Y<span class="kw">.</span>t3,X<span class="kw">.</span>Y<span class="kw">.</span>t5) ty_ops1
    <span class="kw">type</span> state&#39; = X<span class="kw">.</span>Y<span class="kw">.</span>t5
  <span class="kw">end</span>
  <span class="ot">open</span> X4

  <span class="co">(* the transition function takes a state, a label, and returns an updated state with a possible value returned, or an error *)</span>
  <span class="co">(* FIXME readlink is just read, but may want to have a separate label *)</span>
  <span class="kw">let</span> trans ops s0 lbl = (
    <span class="co">(* let _ = print_endline (string_of_label lbl) in *)</span>
    <span class="kw">let</span> m = (<span class="kw">match</span> lbl <span class="kw">with</span> 
      | <span class="dt">LINK</span> (s,d) -&gt; (link ops s d)
      | <span class="dt">MKDIR</span> (s,p) -&gt; (mkdir ops s p)
      | <span class="dt">OPEN</span> (p,fs) -&gt; (
          <span class="kw">if</span> (List<span class="kw">.</span>mem <span class="dt">O_CREAT</span> fs) <span class="kw">then</span> (open_create ops p <span class="co">(* FIXME fs *)</span>) 
          <span class="kw">else</span> (_open ops p fs))
      | <span class="dt">READ</span> (p,i,j) -&gt; (read ops p i j)
      | <span class="dt">READDIR</span> p -&gt; (readdir ops p)
      | <span class="dt">RENAME</span> (s,d) -&gt; (rename ops s d)
      | <span class="dt">RMDIR</span> p -&gt; (rmdir ops p)
      | <span class="dt">STAT</span> p -&gt; (stat ops p)
      | <span class="dt">SYMLINK</span> (s,d) -&gt; (symlink ops s d)
      | <span class="dt">TRUNCATE</span> (p,l) -&gt; (truncate ops p l)
      | <span class="dt">UNLINK</span> p -&gt; (unlink ops p)
      | <span class="dt">WRITE</span> (p,ofs,bs,len) -&gt; (write ops p ofs bs len))
    <span class="kw">in</span>
    <span class="kw">let</span> rs = run_mymonad m s0 <span class="kw">in</span>
    <span class="kw">let</span> f1 ve = (<span class="kw">match</span> ve <span class="kw">with</span>
      | <span class="dt">Inl</span>(s,e) -&gt; (s,<span class="dt">Inl</span> e)
      | <span class="dt">Inr</span>(s,v) -&gt; (s,<span class="dt">Inr</span> v))
    <span class="kw">in</span>
    <span class="kw">let</span> rs = List<span class="kw">.</span>map f1 rs <span class="kw">in</span>
    rs)
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; state&#39; -&gt; ty_label -&gt; (state&#39; * (error,ret_value)sum) finset) = trans
  
  <span class="co">(* convenience method to process a list of labels; always choose first possible result (state,e+v) *)</span>
  <span class="kw">let</span> process_labels ops s0 lbls = (
    <span class="kw">let</span> f1 = (<span class="kw">fun</span> xs -&gt; <span class="kw">fun</span> lbl -&gt; 
      <span class="kw">let</span> l = last xs <span class="kw">in</span>
      <span class="kw">let</span> (_,_,(s,_)) = l <span class="kw">in</span>
      <span class="kw">let</span> rs = trans ops s lbl <span class="kw">in</span>
      <span class="kw">let</span> _ = <span class="kw">if</span> rs = finset_empty <span class="kw">then</span> failwith <span class="st">&quot;process_labels: no result state&quot;</span> <span class="kw">else</span> () <span class="kw">in</span>
      <span class="kw">let</span> (s&#39;,v) = finset_choose rs <span class="kw">in</span>
      xs@[(List<span class="kw">.</span>length xs,lbl,(s&#39;,v))])
    <span class="kw">in</span>
    <span class="kw">let</span> dummy_lbl = <span class="dt">LINK</span>(<span class="st">&quot;dummy lbl&quot;</span>,<span class="st">&quot;dummy lbl&quot;</span>) <span class="kw">in</span>
    <span class="kw">let</span> dummy_error_or_value = <span class="dt">Inr</span> <span class="dt">None1</span> <span class="kw">in</span>
    List<span class="kw">.</span>fold_left f1 [(0,dummy_lbl,(s0,dummy_error_or_value))] lbls)
  <span class="kw">let</span> (_:ty_ops&#39; -&gt; state&#39; -&gt; ty_label <span class="dt">list</span> -&gt; (<span class="dt">int</span> * ty_label * (state&#39; * (error,ret_value)sum)) <span class="dt">list</span>) = process_labels

<span class="kw">end</span></code></pre>
<h2 id="fs_spec_everything"><a href="#fs_spec_everything"><code>Fs_spec_everything</code></a></h2>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">
<span class="ot">module</span> Fs_spec_everything = <span class="kw">struct</span>

  <span class="ot">include</span> Fs_prelude
  <span class="ot">include</span> Prelude
<span class="co">(*  include File_utils *)</span>
  <span class="ot">include</span> Fs_types1
<span class="co">(*  include Lift *)</span>
<span class="co">(*  include Common *)</span>
<span class="co">(*  include Fs_ops1 *)</span>
  <span class="ot">include</span> Resolve
  <span class="ot">include</span> Fs_ops2
  <span class="ot">include</span> Fs_ops3
  <span class="ot">include</span> Transition_system

<span class="kw">end</span></code></pre>
<h2 id="debug"><a href="#debug">Debug</a></h2>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* FIXME do we need to generalize this over ops? yes probably *)</span>
<span class="ot">module</span> Debug = <span class="kw">struct</span>
  
  <span class="ot">open</span> Prelude
  <span class="ot">open</span> Fs_types1

<span class="co">(*</span>
<span class="co">  let string_of_entry e = (</span>
<span class="co">    let i = (match e with</span>
<span class="co">    | Inl dref -&gt; (string_of_int (dest_dir_ref dref))</span>
<span class="co">    | Inr iref -&gt; (string_of_int (dest_inode_ref iref)))</span>
<span class="co">    in</span>
<span class="co">    &quot;(&quot;^i^&quot;)&quot;)</span>
<span class="co">*)</span>

  <span class="kw">let</span> <span class="kw">rec</span> string_of_dir ops s0 dirname d0_ref = (
    <span class="kw">let</span> <span class="dt">Some</span>(d0) = ops.lookup_dir s0 d0_ref <span class="kw">in</span>
    <span class="kw">let</span> ns = ops.get_entries d0 <span class="kw">in</span>
    <span class="kw">let</span> is_file ops s0 d0_ref n = (
      <span class="kw">let</span> <span class="dt">Some</span>(e) = ops.resolve1 s0 d0_ref n <span class="kw">in</span>
      is_inode_ref_entry e)
    <span class="kw">in</span>
    <span class="kw">let</span> is_dir ops s0 d0_ref n = (not (is_file ops s0 d0_ref n)) <span class="kw">in</span>
    <span class="kw">let</span> this_dir = (String<span class="kw">.</span>concat <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> (List<span class="kw">.</span>map (<span class="kw">fun</span> n -&gt; n) ns)) <span class="kw">in</span>    
    <span class="kw">let</span> this_dir = <span class="kw">if</span> ns &lt;&gt; [] <span class="kw">then</span> this_dir ^ <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> <span class="kw">else</span> this_dir <span class="kw">in</span>
    <span class="kw">let</span> other_dirs = List<span class="kw">.</span>filter (<span class="kw">fun</span> n -&gt; is_dir ops s0 d0_ref n) ns <span class="kw">in</span>
    <span class="kw">let</span> f1 n = (
      <span class="kw">let</span> <span class="dt">Some</span>(e) = ops.resolve1 s0 d0_ref n <span class="kw">in</span>
      <span class="kw">let</span> d1_ref = dest_dir_ref_entry e <span class="kw">in</span>
      string_of_dir ops s0 (dirname ^ <span class="st">&quot;/&quot;</span> ^ n) d1_ref)
    <span class="kw">in</span>
    <span class="kw">let</span> others = List<span class="kw">.</span>map f1 other_dirs <span class="kw">in</span>
    <span class="st">&quot;Directory &quot;</span>^dirname^<span class="st">&quot;:</span><span class="ch">\n</span><span class="st">&quot;</span>
    ^ this_dir
    ^ (String<span class="kw">.</span>concat <span class="st">&quot;&quot;</span> others))
    
  <span class="co">(* assume no cycles *)</span>
  <span class="kw">let</span> string_of_state ops s = (
    <span class="kw">let</span> <span class="dt">Some</span>(d0_ref) = ops.get_root s <span class="kw">in</span>
    (string_of_dir ops s <span class="st">&quot;/&quot;</span> d0_ref))

<span class="kw">end</span>

</code></pre>
</body>
</html>
