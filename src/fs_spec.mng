dump_fs: csv encode path names, add command line processing

want to write a script to dump a complete filesystem using shasum

want to implement same for ocaml fs

want to write another script to alpha convert this output (to get a canonical repn of the equiv classes); actually this should be part of dumpfs

@ignore
Hi-lock: (("^@.*" (0 (quote hi-blue-b) t)))
Hi-lock: (("^#+.*" (0 (quote hi-green-b) t)))

@fs_spec.md
# Interactive top-level directives

Via findlib:

    #use "topfind";;
    #require "unix";;
    #require "bigarray";;
    #require "str";;
    (* #cd "/tmp/l/general/research/fs/fs_spec/src";; *)
    #use "fs_prelude.toplevel.ml";;
    #use "fs_spec.toplevel.ml";;
    open Fs_prelude;;
    open Fs_spec;;
    open Fs_spec_everything;;

@tasks issues fs_spec.md
# Tasks

  * sync, datasync

  * expose spec fs via ocaml fuse

  * optimizations  

  * impl

# Issues

Format of the issues file is: prio|cat|desc

(shell-command "soffice /tmp/l/general/research/fs/resources/fs_issues.ods &")

FIXME this probably isn't very clever?


prio|cat|desc
|impl/freelist|"

interaction with freelist in impl; but we don't want to keep writing
the modified freelist to disk every time; if allocation is
deterministic (say, we don't reuse deallocated blocks till latest
time, and there is sufficient space available) then we can play a
similar trick to that with max ref count - just update every 100
allocations or so; we may lose some free space if we crash, but we may
not care about that;

"

|impl/parent_pointers|"

need to have parent pointers in dirs; which requires mutating two
objects atomically when moving;

do we really need parent pointers? any file/dir is accessed via a
path, which presumably gives the parents, so parents could just be
provided by some in-memory cache; an alternative scheme is here:
file:///tmp/l/general/camera_uploads/tmp/2013-03-08_09.55.50.jpg

decision for now: don't include in spec? a dir listing can include
. and .., with obvious meanings; in impl, filenames can be resolved
into dir list and name, so we don't need to deal with .. (except that
a process has a cwd, but this is stored in long format)

"
   
|impl/parent_pointers|"

reference counting is in the spec since files track number of links -
user visible but involves mutating two things atomically; how to deal
with reference counting for files? and dirs?

reference counting for files: without parent pointers, we run into the
problem here:
file:///tmp/l/general/camera_uploads/tmp/2013-03-08_10.22.56.jpg

with parent pointers, we can check whether a file's parent actually
points to the file; if not, we can roll forward to correct the error;
but this check may need to happen every time we check the number of
links, which is quite a lot!
file:///tmp/l/general/camera_uploads/tmp/2013-03-08_10.41.47.jpg so
one option would be to allow link counts to be high, and get fsck to
correct any that are no-longer linked

TEST this issue: crash system in middle of a link file, and check link
counts when restoring system

decision on ref counting: don't do for now, but include in a future
version
"

|spec|change model of names to include trailing slash
|spec|"

note that there are several possible semantics for fsync fd: it syncs
data associated with the fd, or it syncs all data (perhaps written by
other processes) associated with the backing file. We opt for the
latter interpretation, but we should test this, and make a note in the
spec"


|spec|"

does fsync work against file or fd?

need to think about readdir, when other processes are messing about with the directory; do we just want to punt on this?

"

|spec|"

read and write are really against fds - this ensures that even if the
file is renamed etc the read and write are unaffected; the current
fuse interface passes a path to the file to read; would be interesting
to see what fuse does if a process opens a file, and the file is then
moved - is fuse tracking that the filename has changed, and subsequent
reads go to the new file? this seems very messy; we might want to say
that we don't support reading and writing to an fd whilst the file is
renamed; alternatively, the fds have to become part of the spec

does ocamlfuse provide an fd interface to read and write? 

read and write with fds (and readdir) cannot be considered atomic even in non-failure case, so they do interact with other calls e.g. readdir on a directory that is subsequently renamed

fuse allows an additional "struct fuse_file_info *" to be passed into open, and subsequent read calls presumably use this in preference to the path name

also worth noting that fuse can mess with syscalls, which is why we want to run tests directly against the fs

"

|spec|"

probably have to move to fd based interface for open read and write

what happens when open is called on a dir? EISDIR?
"

|test|test whether weak-memory like behaviour is observable (see 2013-04-17)
|test|"

do writes to a file hit the disk in order? (motivation: what a db
might like to assume; against this, there is the fsync command (or
fdatasync) that can enforce these dependencies, so by default the
correct answer is surely no)"

|test/tool_support|"

need a tool to take a list of actions (need pretty print for each
action) and replay against a filesystem"

|theory|"

is there a uniform way to handle partial (mostly disk-backed, but
partly in memory) datastructures? do we want to hold the entire
directory hierarchy (but not the data) in memory at the same time? how
to control the caching of data?"

|theory|"

new idea for persistent objects: graphs, with pointers, acyclic, new
versions etc; the fully persistent implementation (ie all old versions
are accessible) requires writing new versions of all blocks that are
above a modified block; could just have two versions of the pointers
and flick between then when creating new versions (but this requires
that we don't confuse old versions of pointers with new versions);

see notes 2013-04-26"

|tmpfs|add logging layer in fuse interface
|tmpfs|. and .. entries in dir list
|tmpfs|link with a real block layer (see 2013-04-02)
|tmpfs|need options eg to turn tracing on and off

@fs_prelude.md
# fs_prelude.ml
## Prelude

The initial code for `MyDynArray` is a hacky attempt to implement
dynamic arrays. Later I wanted functional arrays (no update in place)
which I tacked on. TODO this all needs to be redone. We want a
functional interface and an efficient implementation that assumes
linear usage (ie updates in place). We should also check that uses are
linear.

@fs_prelude.ml

(* some basic list defns *)

(* downto n m = [n;n-1;...;m] *)
let rec downto' n m = (if n < m then [] else n::(downto' (n-1) m))


(* sets as lists *)
module Finset = struct

  type 'a finset = 'a list

  let empty_finset = []

  let finset_empty = []

  let finset_diff xs1 xs2 = (
    let f1 a x = (if (not (List.mem x xs2)) then x::a else a) in
    List.fold_left f1 [] xs1)
    
  let finset_subset xs1 xs2 = (finset_diff xs1 xs2 = empty_finset)

  let finset_equal xs1 xs2 = ((finset_subset xs1 xs2) && (finset_subset xs2 xs1))

  let finset_mem x xs = (List.mem x xs)

  let finset_insert x xs = (if List.mem x xs then xs else x::xs)

  let finset_partition = List.partition

  let finset_bigunion = List.concat

  let finset_singleton x = finset_insert x finset_empty

  let finset_image f x = List.map f x

  let finset_choose xs = (
    if xs = finset_empty then failwith "finset_choose: empty finset" else List.hd xs)

end

include Finset

module Fmap = struct

  type ('dom,'cod) fmap = ('dom * 'cod) list
  
  let fmap_remove m a = (List.filter (fun (a',_) -> a' <> a) m)
  let fmap_update m (a,b) = (a,b)::(fmap_remove m a)
  let fmap_lookup m a = try Some(List.assoc a m) with _ -> None
  let fmap_dom m = List.map fst m
  let fmap_empty = []

end

include Fmap  


(* dynamic arrays: resize an array to a target size, using doubling *)
module MyDynArray1 = struct
  
  module A = Bigarray.Array1
  
  type myfusebuffer = (char, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t
  
  type t = myfusebuffer (* keep abstract? *)
  
  (* let get_array (da:t) = (da:myfusebuffer) *)

  (* FIXME hopefully this works with 0 length arrays *)
  (* target <= resize' target cur *)
  let rec resize' target cur = (
    let cur = (if cur=0 then 1 else cur) in
    if target <= cur then cur else resize' target (2*cur))
  
  (* resize an array so that it is at least as big as n; invariant: minsize <= dim (resize da minsize) *)
  let resize da minsize = (
    let cur = Bigarray.Array1.dim da in
    let newsize = resize' minsize cur in
    if (newsize = cur) then da else (
      let newbuf = A.create (A.kind da) (A.layout da) newsize in
      let _ = A.blit da (A.sub newbuf 0 (A.dim da)) in
      newbuf))
      
end

module type MYDYNARRAY = sig

  type myfusebuffer = (char, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t

  type t

  val of_array : myfusebuffer -> t

  val of_string : string -> t

  val to_array: t -> myfusebuffer

  val to_string: t -> string

  val repn: t -> int * myfusebuffer

  val create : unit -> t

  val dim : t -> int

  val resize : t -> int -> t

  val get: t -> int -> char

  val set: t -> int -> char -> t

  val blit : t * int * int -> t * int -> t

  (* FIXME don't need if have to_array etc? *)
  (* val blit_array1: t * int * int -> myfusebuffer * int -> int *)

  val sub: t -> int -> int -> t

  (* copy bytes from arr1 to arr2, giving a new array *)
  val write: (t*int*int) -> (t*int) -> t

end


(* like an array, but the array is potentially larger than the data we need to store, so we also keep track of the length of the data *)
module MyDynArray2 = struct

  type myfusebuffer = (char, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t

  module A = Bigarray.Array1

  (* i is the length of the dynamic array, given some implementation; invariant (i,arr): i <= dim arr *)
  type t = int * MyDynArray1.t

  let repn (i,arr) = (i,arr)

  let dim (i,arr) = i

  let resize (i,arr) j = (j,MyDynArray1.resize arr j)

  let of_array arr = (A.dim arr,arr)

  (* convenience only; don't use in production code *)
  let of_string bs = (
    let arr = (Array.init (String.length bs) (String.get bs)) in
    let contents : myfusebuffer = A.of_array Bigarray.char Bigarray.c_layout arr in
    of_array contents)

  (* FIXME we could return the underlying array directly, with a sub *)
  let to_array (i,arr1) = (
    let arr2 = A.create Bigarray.char Bigarray.c_layout i in
    let _ = A.blit (A.sub arr1 0 i) arr2 in
    arr2)

  let to_string (i,arr1) = (
    let s = String.create i in
    let _ = 
      for j=0 to i-1 do
        String.set s j (A.get arr1 j)
      done
    in
    s)

  let create () = (
    let arr = A.create Bigarray.char Bigarray.c_layout 4096 in
    let _ = A.fill arr '\x00' in
    (0, arr))

  let get (i,arr) j = (if j<i then A.get arr j else raise (Invalid_argument "MyDynArray2: get, index out of bounds"))

  let set (i,arr) j c = (
    let arr = (if j > A.dim arr then (MyDynArray1.resize arr j) else (arr)) in
    let i = (if j >= i then j+1 else i) in
    let _ = A.set arr j c in
    (i,arr))

  (* assumes ofs1+len1<i (sim with the other ops) ; resizes if necessary, ie may not mutate in place! *)
  let blit ((i1,arr1),ofs1,len1) ((i2,arr2),ofs2) = (
    let size2 = ofs2+len1 in
    let (i2,arr2) = (
      if (i2 < size2) then (size2,MyDynArray1.resize arr2 size2) else (i2,arr2))
    in
    let _ = A.blit (A.sub arr1 ofs1 len1) (A.sub arr2 ofs2 len1) in
    (i2,arr2))

  (* arr2 is a buffer eg that we are reading to; we return the number of bytes copied *)
  (* assumes ofs1+len1 < i1 *)
  (*
  let blit_array1 ((i1,arr1),ofs1,len1) (arr2,ofs2) = (
    let len = min len1 (A.dim arr2 - ofs2) in
    let _ = A.blit (A.sub arr1 ofs1 len) (A.sub arr2 ofs2 len) in
    len)
  *)

  (* FIXME we need a module representing arrays, but where the ops act functionally ie they return a new array every time *)
  (* FIXME decide what the functional interface to arrays should be; maybe we should mutate and assume arrays are used linearly? *)
  (* behaves as functional call *)
  let sub (i,arr) ofs len = (
    let arr2 = A.sub arr ofs len in
    (A.dim arr2,arr2))
 
  let copy (i,arr) = (
    let arr' = create () in
    let _ = blit ((i,arr),0,i) (arr',0) in
    arr')

  (* behaves as functional call *)
  let write ((i2,arr2),ofs2,len2) (arr1,ofs1)  = (
    let arr2 = blit ((i2,arr2),ofs2,len2) (arr1,ofs1) in
    arr2)
   
end

module MyDynArray = (MyDynArray2 : MYDYNARRAY)

@test mydynarray

let arr = MyDynArray.create ()
let arr = MyDynArray.write (MyDynArray.of_string "hello",0,5) (arr,0)
let true = ("hello" = MyDynArray.to_string arr)

let _ = MyDynArray.to_string (MyDynArray.of_string "hello")

@fs_prelude.ml

module Prelude = struct

  module type MYSET = sig
    type elt 
    type t
    val add : elt -> t -> t
    val choose : t -> elt
    val diff : t -> t -> t
    val elements : t -> elt list
    val empty : t
    val filter : (elt -> bool) -> t -> t
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val from_list : elt list -> t
    val is_empty : t -> bool
    val list_union : elt list -> t -> t
    val map : (elt -> elt) -> t -> t
    val maximal_less_than : elt -> t -> elt option
    val mem : elt -> t -> bool
    val remove : elt -> t -> t
    val split : elt -> t -> t * bool * t
    val union : t -> t -> t
  end
  
  module MySet_Make = functor (Ord:Set.OrderedType) -> (struct
    include Set.Make(Ord)
    let maximal_less_than e s = (
      let (smaller,_,larger) = split e s in
      if (is_empty smaller) then None else (Some(max_elt smaller)))
    let rec itlist f l b =
      match l with
        [] -> b
      | (h::t) -> f h (itlist f t b)
    let list_union xs s =
      itlist (fun x -> fun s -> (*Set_earley_item.*)add x s) xs s
    let map f s =
      let f1 x s = (*Set_earley_item.*)add (f x) s in
      (*Set_earley_item.*)fold f1 s (*Set_earley_item.*)empty
    let from_list elts = 
      let f1 elt s = add elt s in
      itlist f1 elts empty
  end : MYSET with type elt = Ord.t)  

  module type MYMAP = sig
    type key
    type value
    type ty_map
    val empty : ty_map
    val add : key -> value -> ty_map -> ty_map
    val remove:key -> ty_map -> ty_map
    val find2 : key -> ty_map -> value
    val bindings : ty_map -> (key * value) list
  end

  (* argument to Map functor *)
  (* FIXME what if we insert a default value? we may want to remove the k,v in the map; but this requires that we can check that a value is a default *)
  module type MAPINPUT = sig
      type key
      type value
      val compare : key -> key -> int
      val default: value
      val is_default: value -> bool
  end
  
  module MyMap = functor (MapInput:MAPINPUT) -> (struct
    module Ord = struct
        type t = MapInput.key
        let compare = MapInput.compare
    end
    include Map.Make(Ord)
    type value=MapInput.value
    type ty_map=MapInput.value t
    let add k v m = (
      if MapInput.is_default v then remove k m else add k v m)
    let find2 k m =
      if (mem k m) then (find k m) else MapInput.default
  end : (MYMAP with type key = MapInput.key and type value = MapInput.value))

  (* basic library functions *)
  
  type ('a,'b) sum = Inl of 'a | Inr of 'b
  
  let is_Inl x = (match x with | Inl x -> true | _ -> false)
  let is_Inr x = (match x with | Inr x -> true | _ -> false)

  let dest_Inl x = (match x with | Inl x -> x | _ -> failwith "dest_Inl")
  let dest_Inr x = (match x with | Inr x -> x | _ -> failwith "dest_Inr")
  
  (* FIXME change names of predefined combinators to reflect use of not_epsilon (i.e. default is epsilon) *)
  
  let rec itlist f l b =
    match l with
      [] -> b
    | (h::t) -> f h (itlist f t b);;
  
  let rec mem x lis =
    match lis with
      [] -> false
    | (h::t) -> Pervasives.compare x h = 0 or mem x t;;
  
  let insert x l =
    if mem x l then l else x::l;;
  
  let union l1 l2 = itlist insert l1 l2;;
  
  let unions l = itlist union l [];;
  
  
  let ($) f g x = f(g x)
  
  (*
  let read_file_as_string fn = 
    let f = open_in fn in
    let s = ref "" in
    let _ = try (while(true) do s := (!s) ^ (input_line f) ^ "\n" done) with _ -> () in
    let _ = close_in f in
    !s
  *)
  
  let lines fname = 
    let lines = ref [] in
    let chan = if fname="-" then Pervasives.stdin else open_in fname in
    try
      while true; do
        lines := input_line chan :: !lines
      done; []
    with End_of_file ->
      close_in chan;
      List.rev !lines
  
  let read_file_as_string fn = 
    let ls = lines fn in
    ((String.concat "\n" ls)^"\n")
  
  (* get a list with no duplicates; inefficient? FIXME do we mean List.memq? *)
  let unique_f res e = if List.mem e res then res else e::res
  
  (* this is insertion sort; alternatives? *)
  let unique = fun e -> List.fold_left unique_f [] e
  
  let is_Some x = x <> None
  
  let dest_Some x = match x with Some y -> y | _ -> failwith "dest_Some"

  let rec allpairs f l1 l2 =
    match l1 with
     h1::t1 ->  itlist (fun x a -> f h1 x :: a) l2 (allpairs f t1 l2)
     | [] -> []

  let rec last l =
    match l with
      [x] -> x
    | (h::t) -> last t
    | [] -> failwith "last";;
  
  let rec butlast l =
    match l with
      [_] -> []
    | (h::t) -> h::(butlast t)
    | [] -> failwith "butlast";;


  let implode l = itlist (^) l "";;
  
  let explode s =
    let rec exap n l =
        if n < 0 then l else
        exap (n - 1) ((String.sub s n 1)::l) in
    exap (String.length s - 1) [];;

  (* from http://rosettacode.org/wiki/Read_entire_file#OCaml ; when does memory mapping occur? before Unix.close? or does it continually refer to the file on disk? *)

  type myfusebuffer = (char, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t

  (* tr notes: if filename is empty, the mapping fails; so in this case, we do something special *)
  let read_file_as_array filename = (
    let fd = Unix.openfile filename [Unix.O_RDONLY] 0o640 in
    let len = Unix.lseek fd 0 Unix.SEEK_END in
    let _ = Unix.lseek fd 0 Unix.SEEK_SET in
    let shared = false in  (* modifications are done in memory only *)
    let bstr = (if len=0 then (
      Bigarray.Array1.create Bigarray.char Bigarray.c_layout 0
    ) else (
      Bigarray.Array1.map_file fd
        Bigarray.char Bigarray.c_layout shared len))
    in
    Unix.close fd;
    (bstr))
  let (_:string -> myfusebuffer) = read_file_as_array

  (* FIXME probably doesn't work if arr length 0 *)
  let write_array_as_file arr filename = (
    let fd = Unix.openfile filename [Unix.O_RDWR;Unix.O_CREAT;Unix.O_TRUNC] 0o640 in
    let len = Bigarray.Array1.dim arr in
    let _ = Unix.lseek fd 0 Unix.SEEK_SET in
    let shared = true in  (* modifications are done in memory only *)
    let bstr = (Bigarray.Array1.map_file fd
                  Bigarray.char Bigarray.c_layout shared len)
    in
    let _ = Bigarray.Array1.blit arr bstr in 
    let _ = Unix.close fd in
    ())
  let (_:myfusebuffer -> string -> unit) = write_array_as_file

  module My_stream = struct 

    open Bigarray

    (* FIXME scons is at front; snoc is at back; change scons to snoc *)
    (* ('a,'b) stream_ops is the type of streams implemented using type 'a, with vals in 'b *)
    type ('a,'b) stream_ops = { dest_strm:'a -> (unit,'b*'a)sum; snc: ('b*'a) -> 'a }
    (* the following is just for packaging streams into a single value; don't expect ops to change! *)
    type ('a,'b) stream = { impl: 'a; ops: ('a,'b) stream_ops }

    let is_snil s = (match s.ops.dest_strm s.impl with 
      | Inl () -> true
      | _ -> false)

    let dest_stream s = (
      let Inr(v,impl) = s.ops.dest_strm s.impl in
      (v,{s with impl=impl}))

    let snoc (c,s) = (
      let impl = s.ops.snc (c,s.impl) in
      {s with impl=impl})
  
    (* lists as streams *)
    type 'a list_stream = ('a list,'a) stream
    let list_stream_ops = {
      dest_strm=(fun x -> match x with
        | [] -> (Inl ())
        | x::xs -> Inr(x,xs));
      snc=(fun (x,xs) -> xs@[x])
    }
  
    let rec stream_takeall s = (match is_snil s with 
      | true -> []
      | false -> (
        let (c,s) = dest_stream s in
        c::(stream_takeall s)))
    let (_:('a,'b)stream -> 'b list) = stream_takeall


    (* representing streams of characters using a string; impl is a string and an index *)
    let chars_of_string_ops = {
      dest_strm=(fun (s,i) -> (
        if i=String.length s then Inl()
        else Inr(String.get s i,(s,i+1))
      ));
      snc=(fun (c,(s,i)) -> (s^(String.make 1 c),i))
    }
    let chars_of_string s = {impl=(s,0); ops=chars_of_string_ops}
    let (_:string -> (string*int,char) stream) = chars_of_string
  
    (* more efficient - a char stream is a string between a low and high index *)
    let chars_of_string_ops = {
      dest_strm=(fun (s,l,h) -> (
        if l=h then Inl()
        else Inr(String.get s l,(s,(l+1),h))
      ));
      snc=(fun (c,(s,l,h)) -> (
        let s = (if (h=String.length s) then (
          (* need to reallocate *)
          let _ = if 0=String.length s then failwith "chars_of_string_ops: s length 0" else () in
          let s' = String.make ((2*(String.length s))) '\x00' in
          let _ = String.blit s 0 s' 0 (String.length s) in
          s')
          else s)
        in
        let _ = String.set s h c in
        (s,l,h+1)))
    }
    let chars_of_string s = (
      (* backing strings must be non-empty if we are multiplying length by 2 when resizing *)
      if s = "" then {impl=("..",0,0); ops=chars_of_string_ops}
      else {impl=(s,0,String.length s); ops=chars_of_string_ops})
    let (_:string -> (string*int*int,char) stream) = chars_of_string
  
    (* to avoid using stream_takeall, we allow to get the stream contents directly from the impl *)
    let chars_of_string_takeall s = (
      let (s,l,h) = s.impl in
      String.sub s l (h-l))
    let (_:(string*int*int,char) stream -> string) = chars_of_string_takeall
  

    (* FIXME these stream types should be in the stream module *)
    (* also want to deal with arrays particularly myfusebuffer; at the moment only need to read; use dynarray? *)
    let chars_of_array_ops = {
      dest_strm=(fun (s,l,h) -> 
        if l=h then Inl()
        else Inr(Array1.get s l,(s,(l+1),h)));
      snc=(fun _ -> failwith "chars_of_array_ops")
    }
    let chars_of_array s = (
      (* backing strings must be non-empty if we are multiplying length by 2 when resizing *)
      (* we never scons, so we don't need to worry about 0 length array *)
      {impl=(s,0,Array1.dim s); ops=chars_of_array_ops})
    let (_:myfusebuffer -> (myfusebuffer*int*int,char) stream) = chars_of_array

    let chars_of_dynarray_ops = {
      dest_strm=(fun (s,l,h) -> 
        if l=h then Inl()
        else Inr(MyDynArray.get s l,(s,(l+1),h)));
      snc=(fun (c,(s,l,h)) -> 
        let s = MyDynArray.set s h c in
        (s,l,h+1))
    }
    let chars_of_dynarray s = (
      {impl=(s,0,MyDynArray.dim s); ops=chars_of_dynarray_ops})
    let (_:MyDynArray.t -> (MyDynArray.t*int*int,char) stream) = chars_of_dynarray
  
  end

  include My_stream
  
end




(* based partially on http://ocaml-batteries-team.github.io/batteries-included/hdoc/BatBase64.html *)
(* following for encoding binary data into human readable string *)
(* FIXME should probably perform some basic checks on the input - at the momemnt we fail if input is not wellformed *)
(* FIXME maybe pad, so output is a multiple of 4 bytes - this is what eg the base64 command line tool does; this requires an extra character to indicate "no data"; this is the "padding" referred to in the wikipedia article on base64 *)
module Encode = struct

  open Prelude

  let rec string_of_chars cs = (match cs with | [] -> "" | c::cs -> (String.make 1 c)^(string_of_chars cs))

  (* from batteries *)
  type encoding_table = char array (* length 64, take a number from 0-63 and give a char *)
  type decoding_table = int array

  type safe_char = (* subtype of *) char (* should be one of the chars below *)

  type bits_6 = int (* only bottom 6 bits may be non zero *)
  type bits_8 = int
  
  let chars = [|
          'A';'B';'C';'D';'E';'F';'G';'H';'I';'J';'K';'L';'M';'N';'O';'P';
          'Q';'R';'S';'T';'U';'V';'W';'X';'Y';'Z';'a';'b';'c';'d';'e';'f';
          'g';'h';'i';'j';'k';'l';'m';'n';'o';'p';'q';'r';'s';'t';'u';'v';
          'w';'x';'y';'z';'0';'1';'2';'3';'4';'5';'6';'7';'8';'9';'+';'/'
  |]
  
  let make_decoding_table tbl =
          if Array.length tbl <> 64 then failwith "make_decoding_table";
          let d = Array.make 256 (-1) in
          for i = 0 to 63 do
                  Array.unsafe_set d (int_of_char (Array.unsafe_get tbl i)) i;
          done;
          d
  
  let inv_chars = make_decoding_table chars
  
  (* data contains at least 32 bits? what are the assumptions on data? *)
  (* count is number of bits in data that are valid; valid bits are count-1,count-2,...,0 *)
  let rec encode (sofar,data,count,input) = (
    (* try and output a char if possible *)
    if (count >= 6) then (
      (* at least 6 bits in data - output an encoded char *)
      let d = (data asr (count - 6)) land 63 in
      let c = (Array.unsafe_get chars d) in
      encode ((snoc (c,sofar)),data,count-6,input)
    ) else (
      match is_snil input with
      | true -> (
        (* tricky case - less that 6 bits available *)
        if (count > 0) then 
          let d = (data lsl (6-count)) land 63 in
          let c = (Array.unsafe_get chars d) in
          snoc (c,sofar)
        else
          sofar)
      | false -> (
        let (c,input) = dest_stream input in
        let data = (data lsl 8) lor (Char.code c) in
        let count = count + 8 in
        encode (sofar,data,count,input))))

  let encode_string s = (
    let cs = encode ((chars_of_string ""),0,0,chars_of_string s) in
    chars_of_string_takeall cs)
  let (_:string->string) = encode_string
  
  (* the data is decoded bits *)
  let rec decode (sofar,data,count,input) = (
    if (count >= 8) then (
      (* at least 8 bits in data *)
      let d = (data asr (count - 8)) land 0xFF in
      let c = Char.chr d in
      decode (snoc (c,sofar),data,count-8,input)
    ) else (
      match is_snil input with 
      | true -> (
        (* assume the data is 0 padding bytes, so discard *)
        sofar)
      | false -> (
        let (c,input) = dest_stream input in
        let d = Array.unsafe_get inv_chars (Char.code c) in
        let data = (data lsl 6) lor d in
        decode (sofar,data,count+6,input))))
 
  let decode_string s = (
    let cs = decode ((chars_of_string ""),0,0,chars_of_string s) in
    chars_of_string_takeall cs)
  let (_:string->string) = decode_string

  let encode_array s = (
    let cs = encode ((chars_of_string ""),0,0,chars_of_array s) in
    let cs = stream_takeall cs in
    string_of_chars cs)
  let (_:myfusebuffer->string) = encode_array
  
    
  (* test 
  let _ = encode_string "Man is distinguished"
  let _ = encode_string "Man is distinguis"
  let _ = decode_string "TWFuIGlzIGRpc3Rpbmd1aXN"
  *)

  (* further fiddling *)
  (*
  let bits_6_of_8 = (
    let is_snil=(fun (s,data,count) -> (count=0) && (s.ops.is_snil s.impl)) in
    let rec dest_scons=(fun (s,data,count) -> (
      if count >= 6 then (
        (* at least 6 bits in data - output an encoded char *)
        let d = (data asr (count - 6)) land 63 in
        (d,(s,data,count-6))
      ) else (
        match s.ops.is_snil s.impl with
        | true -> (
          (* tricky case - less that 6 bits available *)
          (* this is only called if not is_snil, which implies that count > 0 *)       
          let d = (data lsl (6-count)) land 63 in
          (d,(s,data,0)))
        | false -> (
          let (c,s_impl) = s.ops.dest_scons s.impl in
          let s = {s with impl=s_impl} in
          let data = (data lsl 8) lor (Char.code c) in
          let count = count + 8 in
          dest_scons (s,data,count)))))
    in
    let scons=(fun _ -> failwith "bits_6_of_8") in
    let ops = { is_snil; dest_scons; scons } in
    fun s -> { impl=(s,0,0); ops=ops })
  let (_:('a,char)stream -> (('a,char)stream*int*int,bits_6)stream) = bits_6_of_8

  let encode_6 = (
    let is_snil=(fun s -> s.ops.is_snil s.impl) in
    let dest_scons=(fun s -> 
      let (i,s_impl) = s.ops.dest_scons s.impl in
      let s = {s with impl=s_impl} in
      let c = (Array.unsafe_get chars i) in
      (c,s)) 
    in
    let scons=(fun _ -> failwith "encode_6") in
    let ops = { is_snil; dest_scons; scons } in
    fun s -> {impl = s; ops=ops})
  let (_:('a,bits_6)stream -> (('a,bits_6)stream,safe_char) stream) = encode_6
  (* FIXME might be nice to have record notation for types, rather than pairs *)
  *)

  (* test 
  let s = chars_of_string "Man"
  let s2 = bits_6_of_8 s
  let s3 = encode_6 s2 
  let _ = stream_takeall s3  
  *)

end



@test streams

let int_stream_ops = (
   let is_snil=(fun _ -> false) in
   let rec dest_scons=(fun i -> (i,i+1)) in
   { is_snil; dest_scons; scons=(fun _ -> failwith "int_stream_ops") })

let int_stream = { impl=0; ops=int_stream_ops }

let rec take n s = (if n = 0 then [] else 
   let (c,impl) = s.ops.dest_scons s.impl in
   c::(take (n-1) {s with impl=impl}))

let _ = take 10 int_stream

let _ = stream_takeall (chars_of_string "hello")


@test mydynarray

module A = Bigarray.Array1

let tmp = A.create Bigarray.char Bigarray.c_layout 4096

let tmp2 = A.of_array Bigarray.char Bigarray.c_layout [| 'h';'e';'l';'l';'o' |]

let _ = A.blit (A.sub tmp2 0 5) (A.sub tmp 0 5)

let tmp3 = MyDynArray.create ()

let _ = MyDynArray.dim tmp3

let tmp3 = MyDynArray.blit ((MyDynArray.of_array tmp2),0,5) (tmp3,0)

let _ = MyDynArray.dim tmp3

let tmp4 = A.create Bigarray.char Bigarray.c_layout 4096

let _ = MyDynArray.blit_array1 (tmp3,0,5) (tmp4,0)

let _ = A.get tmp4 4

@fs_spec.md
# fs_spec.ml
## Fs_types1

Types common to all implementations of the basic operations

@fs_spec.ml

open Fs_prelude

(* as an optimization, we expect that each of these refs is actually a ref to a sector *)

module Fs_types1 = struct

  open Prelude

  type bytes = MyDynArray.t
  type name = string (* shortest component of a filename - doesn't include /; may be empty; may be . or .. *)

  type error =
      E2BIG
    | EACCES
    | EAGAIN
    | EBADF
    | EBUSY
    | ECHILD
    | EDEADLK
    | EDOM
    | EEXIST
    | EFAULT
    | EFBIG
    | EINTR
    | EINVAL
    | EIO
    | EISDIR
    | EMFILE
    | EMLINK
    | ENAMETOOLONG
    | ENFILE
    | ENODEV
    | ENOENT
    | ENOEXEC
    | ENOLCK
    | ENOMEM
    | ENOSPC
    | ENOSYS
    | ENOTDIR
    | ENOTEMPTY
    | ENOTTY
    | ENXIO
    | EPERM
    | EPIPE
    | ERANGE
    | EROFS
    | ESPIPE
    | ESRCH
    | EXDEV
    | EWOULDBLOCK
    | EINPROGRESS
    | EALREADY
    | ENOTSOCK
    | EDESTADDRREQ
    | EMSGSIZE
    | EPROTOTYPE
    | ENOPROTOOPT
    | EPROTONOSUPPORT
    | ESOCKTNOSUPPORT
    | EOPNOTSUPP
    | EPFNOSUPPORT
    | EAFNOSUPPORT
    | EADDRINUSE
    | EADDRNOTAVAIL
    | ENETDOWN
    | ENETUNREACH
    | ENETRESET
    | ECONNABORTED
    | ECONNRESET
    | ENOBUFS
    | EISCONN
    | ENOTCONN
    | ESHUTDOWN
    | ETOOMANYREFS
    | ETIMEDOUT
    | ECONNREFUSED
    | EHOSTDOWN
    | EHOSTUNREACH
    | ELOOP
    | EOVERFLOW
    | EUNKNOWNERR of int
 
  (* from unix.mli *)
  type open_flag =
      O_RDONLY                    (** Open for reading *)
    | O_WRONLY                    (** Open for writing *)
    | O_RDWR                      (** Open for reading and writing *)
    | O_NONBLOCK                  (** Open in non-blocking mode *)
    | O_APPEND                    (** Open for append *)
    | O_CREAT                     (** Create if nonexistent *)
    | O_TRUNC                     (** Truncate to 0 length if existing *)
    | O_EXCL                      (** Fail if existing *)
    | O_NOCTTY                    (** Don't make this dev a controlling tty *)
    | O_DSYNC                     (** Writes complete as `Synchronised I/O data
                                     integrity completion' *)
    | O_SYNC                      (** Writes complete as `Synchronised I/O file
                                     integrity completion' *)
    | O_RSYNC                     (** Reads complete as writes (depending on
                                     O_SYNC/O_DSYNC) *)
    | O_SHARE_DELETE              (** Windows only: allow the file to be deleted
                                   while still open *)

  type file_perm = int


  type file_kind = 
    S_REG                       (** Regular file *)
  | S_DIR                       (** Directory *)
  | S_LNK                       (** Symbolic link *)


  


  (* top-level labels, intended to mirror the syscalls, but with functional interface; TODO need to incorporate file descriptors, "current position" etc *)
  type ty_label = 
    | LINK of (string * string)
    | MKDIR of (string * file_perm)
    | OPEN of (string * open_flag list)
    | READ of (string * int * int)
    | READDIR of string
    | RENAME of (string * string)
    | RMDIR of string
    | STAT of string
    | SYMLINK of (string * string)
    | TRUNCATE of (string * int)
    | UNLINK of string
    | WRITE of (string * int * bytes * int)

  type file_contents = bytes (* really a map from index to ... *)

  type ret_value = None1 | Int1 of int | Bytes1 of bytes (* FIXME add init return type *) | Names1 of name list
    | Stats1 of Unix.LargeFile.stats
  let dest_bytes1 (Bytes1 bs) = bs
 
  (* names types; also type name earlier *)
  
  (* following moved from ops parser *)
  type dirname = string list
  type filename = string list (* non-empty *)

  (* the type of parsed paths; what is important is whether the name ends with a slash *)
  type ty_name_list2 = {
    ns2: name list;
    ends_with_slash2: bool; 
  }

  (* we cannot supply Fname from user space: a name /tmp/tmp.txt may refer to a file or a dir *)
  (* resolved name *)
  (* type rname1 = Dname1 of name list | Fordname1 of name list *)
  (* resolved name relative to a state *)
  type ('dir_ref,'inode_ref) rname2 = 
    Dname2 of 'dir_ref * ty_name_list2
  | Fname2 of 'inode_ref * ty_name_list2 
  | None2 of ty_name_list2
  | Err2 of 'inode_ref * ty_name_list2 
  (* invariant: if Fname2 ns, then not (ns.ends_with_slash2) *)
  (* invariant: if Err2 then ns.ends_with_slash2 *)
  (* FIXME since these are resolved, we may want to include the i0_ref and d0_ref *)

  let is_Err2 x = (match x with | Err2 _ -> true | _ -> false)

  let name_list_of_rname2 n = (match n with 
    | Dname2 (_,ns) -> ns
    | Fname2 (_,ns) -> ns
    | None2 ns -> ns
    | Err2 (_,ns) -> ns)
 
  let string_of_names ns = ("/"^(String.concat "/" ns))

  let string_of_rname2 n = (
    let ns = name_list_of_rname2 n in
    ((String.concat "/" ns.ns2)^(if ns.ends_with_slash2 then "/" else ""))) (* FIXME shouldn't this start with / ? *)

  let is_None2 x = (match x with None2 _ -> true | _ -> false)




  type ('dir_ref,'inode_ref) entry = ('dir_ref,'inode_ref) sum
  let is_dir_ref_entry = is_Inl
  let is_inode_ref_entry = is_Inr
  let dest_dir_ref_entry = dest_Inl
  let dest_inode_ref_entry = dest_Inr

  (* might like type operators which pick up the type from a compound type eg. 'a ty_state_ops = { f1:(fst 'a); f2: (fst(snd 'a)) } etc *)
  type ('dir_ref,'dir,'inode_ref,'inode,'state) ty_state_ops = {
    get_init_state: unit -> 'state;
    get_root: 'state -> 'dir_ref option;
    lookup_dir: 'state -> 'dir_ref -> 'dir option;
    lookup_inode: 'state -> 'inode_ref -> 'inode option;
    update_inds_some: 'state -> ('inode_ref * 'inode) -> 'state;
    resolve1: 'state -> 'dir_ref -> name -> ('dir_ref,'inode_ref) entry option;
    update_ents_pointwise: 'state -> 'dir_ref -> name -> ('dir_ref,'inode_ref) entry option -> 'state;
    new_dir: 'state -> 'dir_ref -> name -> ('state * ('dir_ref * 'dir)); 
    new_inode: 'state -> ('state * ('inode_ref * 'inode)); (* FIXME is dir linked in or not? yes, see mkdir *)
    get_contents: 'inode -> file_contents;
    set_contents: 'inode -> file_contents -> 'inode;
    get_symlink: 'inode -> bool;
    set_symlink: 'inode -> bool -> 'inode;
    dest_inode_ref: 'state -> 'inode_ref -> int;
    dest_dir_ref: 'state -> 'dir_ref -> int;
    get_entries: 'dir -> name list; (* FIXME 'dir -> name list ? *)
  }

  (* FIXME not needed? *)
  (*
  type ('dir_ref,'dir,'inode_ref,'inode,'impl) state = {
    ops3: ('dir_ref,'dir,'inode_ref,'inode,'impl) ty_state_ops;
    s3: 'impl
  }
  *)

  type 'impl ty_return2 = {
    state2: 'impl;
    ret2: ret_value;
  } 
  let return s = { state2=s; ret2=None1 }


  type ('dir_ref,'inode_ref,'impl) ty_ops1 = {
    get_init_state1: unit -> 'impl;
    get_root1: 'impl -> 'dir_ref option;
    dest_dir_ref1: 'impl -> 'dir_ref -> int;
    dest_inode_ref1: 'impl -> 'inode_ref -> int;
    get_symlink1: 'impl -> 'inode_ref -> bool;
    link_file1: 'impl -> 'inode_ref -> 'dir_ref -> name -> 'impl ty_return2;
    unlink1: 'impl -> 'dir_ref -> name -> 'impl ty_return2;
    mkdir1: 'impl -> 'dir_ref -> name -> 'impl ty_return2;
    mv1: 'impl -> 'dir_ref -> name -> 'dir_ref -> name -> 'impl ty_return2;
    mvdir1: 'impl -> 'dir_ref -> name -> 'dir_ref -> name -> 'impl ty_return2;
    read1: 'impl -> 'inode_ref -> 'impl ty_return2;
    readdir1: 'impl -> 'dir_ref -> 'impl ty_return2; (* don't return . and .. entries *)
    resolve11: 'impl -> 'dir_ref -> name -> ('dir_ref,'inode_ref) entry option;
    rm1: 'impl -> 'dir_ref -> name -> 'impl ty_return2; (* FIXME don't need this and unlink1 *)
    rmdir1: 'impl -> 'dir_ref -> name -> 'impl ty_return2; (* FIXME probably don't need this either *)
    touch1: 'impl -> 'dir_ref -> name -> 'impl ty_return2;
    write1: 'impl -> 'inode_ref -> bytes -> 'impl ty_return2;
    set_symlink1: 'impl -> 'inode_ref -> bool -> 'impl ty_return2;
  }


end

@fs_spec.md
## Resolve names

We want to take a string such as `/x/y/z/d/` and process it:

  * extract the components 
  * record whether the string starts in / (* but maybe vfs ensures all strings start in / *)
  * record whether the string ends in /
  * process the string (against the current state) to remove .. and . (providing entries exist; if not return ENOENT; function remove_dot_dotdot) and empty entries
  * then compare result with the current state to determine whether the string
      (1) ends with a / and matches a dir
      (2) ends with a / and matches a file (error)
      (3) doesn't end with a slash and matches a file or dir
      (4) ends with a slash or not, and doesn't match anything

Proposed processing of last step: Ignoring trailing slash, do we match or not? Yes - check agreement with trailing slash (1) and (2) and (3). No - (4)

@fs_spec.ml

(* FIXME tidy this up *)
module X = struct

  open Fs_types1
  
  (* hack to get an abstract state type *)
  module Y : sig 
    type t1
    type t2
    type t3
    type t4
    type t5
  end = struct 
    type t1 = int
    type t2 = int
    type t3 = int
    type t4 = int
    type t5 = int
  end 

end

module Resolve = struct
 
  open Prelude
  open Fs_types1
(*  open Fs_ops1 *)

  (* for the purposes of type-checking the following defns without spurious type vars *)
  module XR = struct
    (* type ty_ops' = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)
    type ty_ops' = (X.Y.t1,X.Y.t3,X.Y.t5) ty_ops1
    type dir_ref' = X.Y.t1
    type ty_impl' = X.Y.t5
    type inode_ref' = X.Y.t3
    type ty_return' = X.Y.t5 ty_return2
    type rname' = (X.Y.t1,X.Y.t3) rname2
  end
  open XR


  (* resolve ns, return a (dir_ref,dir); only used with a resolve *)
  (* these seem to be used as shortcuts for looking up parents of a given path; but we want to ensure some invariants in lists of names; on the other hand, given a rname, to resolve the parent we don't want to have to go via strings *)
  let rec resolve_dir_ref_f1 ops s0 sofar ns = (match ns with 
      | [] -> (Some sofar)
      | n::ns -> (
        let m = ops.resolve11 s0 sofar n in
        match m with | None -> None | Some entry -> 
        match is_dir_ref_entry entry with | false -> None | true ->
        let dir_ref = dest_dir_ref_entry entry in 
        resolve_dir_ref_f1 ops s0 dir_ref ns))

  let resolve_dir_ref ops s0 ns = (
    (* sofar is the dir_ref we currently got to; starts off as the root *)
    (* FIXME separate out nested rec defns, so easier to transport to HOL backend *)
    let f1 = resolve_dir_ref_f1 ops s0 in
    let d0_ref = dest_Some(ops.get_root1 s0) in (* FIXME prefer dest_Some to let Some(x) = for HOL backend *)
    f1 d0_ref ns)
  let (_:ty_ops' -> ty_impl' -> name list -> dir_ref' option) = resolve_dir_ref

  (* let dir_exists ops s0 ns = (resolve_dir_ref ops s0 ns <> None) *)

  (* want to restrict uses of resolve_dir_ref and resolve_inode_ref to this module *)
  (* FIXME check this is never used on the root directory, or get_parent_dir root = root, or maybe return None *)
  let get_parent_dir ops s0 nl = (
    resolve_dir_ref ops s0 (butlast nl.ns2))
  let (_:ty_ops' -> ty_impl' -> ty_name_list2 -> dir_ref' option) = get_parent_dir

  (* ns cannot be empty; FIXME this is only used in resolve *)
  let resolve_inode_ref ops s0 ns = (
    let r = resolve_dir_ref ops s0 (butlast ns) in
    match r with | None -> None | Some dir_ref ->
    let n = last ns in
    let m = ops.resolve11 s0 dir_ref n in
    match m with | None -> None | Some entry -> 
    match is_inode_ref_entry entry with | false -> None | true -> 
    let i0_ref = dest_inode_ref_entry entry in (* assume a file *)
    Some(i0_ref))
  let (_:ty_ops' -> ty_impl' -> name list -> inode_ref' option) = resolve_inode_ref    

  (* let file_exists ops s0 ns = (resolve_inode_ref ops s0 ns <> None) *)

  (* assumes path starts with '/'; throws an exception if not; FIXME do we always know the path starts with '/'? *)

  (* take a string, get components and whether ends in slash *)
  let process_path1 path = (
    let p = explode path in
    if p = [] then failwith "process_path1: empty path" else
    if List.hd p <> "/" then failwith "process_path: doesn't start with /" else
    let p = List.tl p in
    let f1 (ns,cur) c = (if c="/" then (ns@[cur],"") else (ns,cur^c)) in
    let (ns,cur) = List.fold_left f1 ([],"") p in
    let ends_with_slash = (cur="") in
    let ns = (if ends_with_slash then ns else ns@[cur]) in (* FIXME this logic is wrong? if multiple slashes? *)
    let ns = List.filter (fun n -> n <> "." && n <> "") ns in (* remove empty entries and "." entries *)
    { ns2=ns; ends_with_slash2=ends_with_slash })
  let (_:string -> ty_name_list2) = process_path1

  (* preliminary processing of ns; drop empty components and "." components, and resolve ".." *)
  (* idempotent *)
  (* FIXME this is only OK if the e.g. d/../x/y/z we have that d exists FIXME do not use! *)
  let process_dotdot ops s0 nl = (
    let f1 sofar n = (
      if ((n="..") && sofar <> []) then 
        (butlast sofar) 
      else if ((n="..") && (sofar = [])) then
        (failwith "process_dot_dotdot")
      else
        (sofar@[n])) 
    in
    let ns = List.fold_left f1 [] nl.ns2 in
    {nl with ns2=ns})
  let (_:ty_ops' -> ty_impl' -> ty_name_list2 -> ty_name_list2) = process_dotdot 

  (* take a state and a ty_name_list2, and check if name exists in state *)
  let process_path2 ops s0 ns = (
    (* FIXME we need to process .. here as well *)
    match ns.ends_with_slash2 with 
    | true -> (
      let opt = resolve_dir_ref ops s0 ns.ns2 in
      match opt with 
      | Some(dir_ref) -> Dname2(dir_ref(*,dest_Some(ops.lookup_dir s0 dir_ref))*),ns)
      | None -> (
        let opt = resolve_inode_ref ops s0 ns.ns2 in 
        match opt with
        | None -> None2 ns
          (* following case, ns ends with a slash, but resolves to a file *)
        | Some(iref) -> Err2(iref(*,dest_Some(ops.lookup_inode s0 iref))*),ns)))
    | false -> (
      let opt = resolve_dir_ref ops s0 ns.ns2 in
      match opt with
      | Some(dir_ref) -> Dname2(dir_ref(*,dest_Some(ops.lookup_dir s0 dir_ref))*),ns)
      | None -> (
        let opt = resolve_inode_ref ops s0 ns.ns2 in
        match opt with 
        | Some(iref) -> Fname2(iref(*,dest_Some(ops.lookup_inode s0 iref)*),ns)
        | None -> None2 ns)))
  let (_:ty_ops' -> ty_impl' -> ty_name_list2 -> rname') = process_path2

  (* guarantees: returns option of Fname or Dname  *)
  let process_path ops s0 path = (
    let nl = process_path1 path in
    let nl = process_dotdot ops s0 nl in
    let rpath = process_path2 ops s0 nl in
    rpath)  
  let (_:ty_ops' -> ty_impl' -> string -> rname') = process_path

  (* FIXME we want subsequent defns to work in terms of rname, and possible ty_name_list2; we want invariants on these *)

  let rec list_prefix xs ys = (
    match (xs,ys) with
    | ([],_) -> true
    | (_,[]) -> false
    | (x::xs,y::ys) -> (
      if (x=y) then list_prefix xs ys else false))

  (* check if renaming a dir to a subdir of itself *)
  let subdir nl_src nl_dst = (list_prefix nl_src.ns2 nl_dst.ns2)

end

@fs_spec.md
## `Fs_ops2`

Fs ops is very precise about what each argument is expected to be. Dirnames start and end in `/`. Filenames must not end in `/`. We don't check that the target of a `mv` is empty, or doesn't exist etc. However, at the command line, there is some ambiguity:

  * assuming `tmp.txt` is a file, then `mv tmp.txt d` will treat `d` as a file (if no d exists), or as a dir (if d exists and is a dir)

  * `mv tmp.txt d/` will treat `d/` as a dir always

So some possible sources of ambiguity are:
 
  * is `tmp.txt` a file or a directory? (if it exists, then it is whatever it is)

  * if we mean a dir, we can add a '/', and this makes clear what we mean; if we don't add a '/' then the fs may not know whether we intend a file or directory

  * even if we are clear that we mean a dir, there can be multiple interpretations: `mv c/ e/` renames c to e, providing e doesn't already exist; if e does exist, then c goes into e

  * `mv c/ e/` will overwrite a directory `e/c` if `e/c` is empty; will fail if `e/c` is not empty

At the user level, there is some extra logic which makes commands behave differently eg if the target is absent, or a file, or a directory eg for the command `mv src dst`

  * if src is a file, and dst is a dir, then src is moved into dir

  * if src if a file and dst is a file, then src is moved over dst (dst is unlinked)

  * if src is a dir and dst is a dir, then 

Some criteria: 

  * src,dst ends in '/'

  * src,dst exists/not exists  (but how to connect name to entity? the point is that this connection is heuristic in some sense; proposal: given a fordname, check whether a dir exists with that name; if not, attempt to interpret as file)

  * src,dst exists and is a file/ is a dir


Proposed `mv` processing stages:

 1. if either src or dst is fordname (no trailing /) then try to disambiguate: if directory src exists, then src is a dirname, otherwise filename; from this point onwards, we use "src" to indicate a filename, and "src/" to indicate a dirname

    `mv src dst/`: move file src to dst directory; if src doesn't exist, fail; if dst directory doesn't exist, fail

    `mv src/ dst`: move directory src to directory dst; dst directory doesn't exist by disambiguation (otherwise the command would have been interpreted as `mv src/ dst/`); fail if src doesn't exist

    `mv src dst`: move file src to file dst; if src doesn't exist, fail

    `mv src/ dst/`: if `dst` exists, then attempt to move dir src to a subdirectory of dst; if `dst/src` file exists, overwrite; if `dst/src` dir exists, and is empty, then do the move, otherwise fail


Note: these options don't even include checking whether src and dst are soft links (which further complicates matters; FIXME we don't deal with soft links at this stage)

For the moment, we content ourselves with the following horrible code...

For `Fs_ops2` we provide functions from state to Inl of state * err, or Inr of state * ret

--

Invariant: if any exception is raised, the state is not changed

@fs_spec.ml

(* FIXME these work in terms of rnames; assumes no Err2 *)
module Fs_ops2 = struct
  
  open Unix (* for st_dev record fields etc *)
  open LargeFile (* FIXME include stats in Fs_types1? *)

  open Prelude
  open Fs_types1
(*  open Fs_ops1 *)
  (* open Resolve *)

  let get_parent_dir = Resolve.get_parent_dir
  let resolve_process_path2 = Resolve.process_path2
  let resolve_subdir = Resolve.subdir

  (* type error = Fs_types1.error *)
  type ('impl,'a) ty_return3 = (('impl * Fs_types1.error, 'impl * 'a) sum) finset
  (* vars u, v used eg for Mymonad u *)
  type ('impl,'a) mymonad = Mymonad of ('impl -> ('impl,'a) ty_return3)
  let dest_mymonad (Mymonad u) = u
  let return x = Mymonad (fun s -> finset_insert (Inr(s,x)) finset_empty)
  let (_:'a -> ('impl,'a) mymonad) = return

  (* for the purposes of type-checking the following defns without spurious type vars *)
  (* N.B. these dummy X module defns are interesting because they show what types are used in each module *)
  module X2 = struct
    type 'a ty_return3' = (X.Y.t5,'a) ty_return3
    type 'a ty_mymonad' = (X.Y.t5,'a) mymonad
    type rname2' = (X.Y.t1,X.Y.t3) rname2    
    (* type ty_ops' = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)
    type ty_ops' = (X.Y.t1,X.Y.t3,X.Y.t5) ty_ops1
  end
  open X2

  let bind u f = Mymonad (fun s0 ->
    let u = dest_mymonad u in
    let rs = u s0 in
    let f1 v = (match v with 
      | Inl x -> (finset_singleton (Inl x))
      | Inr (s,x) -> (
        let v = dest_mymonad (f x) in
        v s))
    in
    let rs' = finset_image f1 rs in
    let rs'' = finset_bigunion rs' in
    rs'')    
  let (_: 'a ty_mymonad' -> ('a -> 'b ty_mymonad') -> 'b ty_mymonad') = bind

  (* FIXME we also want to bake in that as soon as we have an exception, we will not alter the state further *)

  let ( >>= ) = bind
  
  let get_state = Mymonad (fun (s) -> finset_singleton(Inr(s,s)))
  let put_state s0 = Mymonad (fun (s) -> finset_singleton(Inr(s0,None1)))
  let myraise e = Mymonad (fun (s) -> finset_singleton(Inl(s,e)))
  let maybe_raise e = Mymonad (fun (s) -> 
    finset_insert (Inr(s,())) (finset_singleton(Inl(s,e))))

  let choose xs = Mymonad (fun s -> finset_image (fun x -> Inr(s,x)) xs)

  (* for a deterministic version, choose some particular value *)
  let choose xs = Mymonad (fun s -> finset_singleton(Inr(s,finset_choose xs)))

  let do_nothing = Mymonad (fun s -> finset_singleton(Inr(s,())))

  let run_mymonad (Mymonad f) s = (f (s))
  let (_:('a,'b) mymonad -> 'a -> ('a,'b) ty_return3) = run_mymonad
  
  (*  let is_empty_dir (s0:'impl) ns = failwith "FIXME" *)

  let default_stats = {
    st_dev = 2049; (* device number FIXME 0? *)
    st_ino = 999; (* inode number FIXME change this for particular file etc *)
    st_kind = Unix.S_DIR; (* FIXME *)
    st_perm = 0o777; (* ugo+rwx *)
    st_nlink = 2; (* FIXME dummy - for dir should be number of entries + 2 *)
    st_uid = 1000; (* FIXME 0? *)
    st_gid = 1000; 
    st_rdev = 0; (* device minor number *)
    st_size = 4096L; (* FIXME dummy *)
    st_atime = 0.;
    st_mtime = 0.;
    st_ctime = 0.
  }

  let default_file_stats ops s0 i0_ref = { default_stats with
    st_ino=(ops.dest_inode_ref1 s0 i0_ref);
    st_kind=(
      if (ops.get_symlink1 s0 i0_ref) then Unix.S_LNK else Unix.S_REG); (* FIXME we may need our own stats structure *)
    st_size=(
      let bs = dest_bytes1 ((ops.read1 s0 i0_ref).ret2) in
      (Int64.of_int (MyDynArray.dim bs)))
  }
 
  let default_dir_stats ops s0 d0_ref = { default_stats with
    st_ino=(ops.dest_dir_ref1 s0 d0_ref);
    st_kind=Unix.S_DIR;
    st_size=4096L; (* seems to be default on my system - but changes depending on number of entries? *)
  }

  (* Fs_ops1 returns ty_return3, which apart from read is just a state *)
  let put_state' r = put_state r.state2

  (* FIXME remove *)
  let put_state'' f = (put_state' (f ()))

  let link ops spath dpath = (
    get_state >>= fun s0 ->
    match spath with 
    | Fname2(i0_ref,ns_src)  -> (
      match dpath with 
      | None2 ns_dst -> (
        match (get_parent_dir ops s0 ns_dst) with (* FIXME what if ns_dst.ns2 = [] *)
        | None -> (myraise ENOENT)
        | Some(d0_ref) -> (
          let s0 = ops.link_file1 s0 i0_ref d0_ref (last ns_dst.ns2) in
          put_state' s0))
      | Err2(_,_) -> (
        (maybe_raise EEXIST) >>= fun _ -> (* arguably linux bug *)
        myraise ENOTDIR)
      | _ -> (myraise EEXIST))
    | Dname2(_,_) -> (
      (match dpath with
        | None2 ns_dst -> (
          match (get_parent_dir ops s0 ns_dst) with (* FIXME what if ns_dst.ns2 = [] *)
          | None -> (maybe_raise ENOENT)
          | _ -> do_nothing)
        | Err2 (_,_) -> (maybe_raise EEXIST)  (* arguably a linux bug - prefer ENOTDIR? *)
        | _ -> (maybe_raise EEXIST)) >>= (fun _ ->
      myraise EPERM))
    | Err2(_,_) -> (myraise ENOTDIR)
    | _ -> (myraise ENOENT))

  let mkdir ops rpath perms = (
    (* FIXME deal with perms *)
    get_state >>= fun s0 ->
    match rpath with 
    | None2(ns) -> (
      match (get_parent_dir ops s0 ns) with (* FIXME what if ns_dst.ns2 = [] *)
      | None -> (myraise ENOENT)
      | Some(d0_ref) -> (
        let s0 = ops.mkdir1 s0 d0_ref (last ns.ns2) in
        put_state' s0))
    | Dname2(_,_) -> (myraise EEXIST)
    | Fname2(_,_) -> (myraise EEXIST))

  let open_create ops rpath = (
    get_state >>= fun s0 ->
    match rpath with 
    | Dname2(_,_) -> (myraise EEXIST) 
    | Fname2(_,_) -> (myraise EEXIST)
    | None2 ns -> (
      (* FIXME for us, open_create should only create files *)
      if ns.ends_with_slash2 then 
        myraise EISDIR
      (* maybe we are trying to create a file "" ie path was empty FIXME where is this from? *)
      else if ns.ns2 = [] then 
        myraise ENOENT
      (* FIXME need to look at mode *)
      else
        let dname = butlast ns.ns2 in
        let fname = last ns.ns2 in
        (* FIXME following is unusual *)
        let dpath = resolve_process_path2 ops s0 { ns2=dname; ends_with_slash2=false } in
        match dpath with
        | Dname2(d0_ref,ns) -> (
          let s0 = ops.touch1 s0 d0_ref fname in
          put_state' s0)
      | Fname2(_,_) -> (myraise ENOTDIR)
      | _ -> (myraise ENOENT)))
  let (_:ty_ops' -> rname2' -> ret_value ty_mymonad') = open_create

  (* FIXME the real spec would allow reading less than all the bytes; recall len is maxlen *)
  let read ops rname2 ofs len = (
    match rname2 with 
    | None2 _ -> (myraise ENOENT)
    | Dname2(_,_) -> (myraise ENOENT)
    | Fname2(i0_ref,ns) -> (
      get_state >>= (fun s0 -> (
      let r = ops.read1 s0 i0_ref in (* FIXME Fs_ops1 may have to take an offset too *)
      (put_state' r) >>= fun _ -> 
      (* non-deterministically choose the amount of data to write *)
      choose (downto' len 0) >>= fun len ->
      let bs = dest_bytes1 r.ret2 in
      let len_bs = MyDynArray.dim bs in
      (* assume ofs is wellformed *)
      let len = if ofs+len <= len_bs then len else len_bs - ofs in
      (* let _ = print_endline ("read len_bs: "^(string_of_int len_bs)^"; len: "^(string_of_int len)^"; ofs: "^(string_of_int ofs)) in *)
      (* let _ = print_endline "before" in *)
      let bs' = MyDynArray.sub bs ofs len in
      (* let _ = print_endline "after" in *)
      return (Bytes1(bs'))))))
  let (_:ty_ops' -> rname2' -> int -> int -> ret_value ty_mymonad') = read

  (* NB doesn't include . and .. *)
  let readdir ops rname2 = (
    get_state >>= (fun s0 -> (
    match rname2 with 
    | None2 _ -> (myraise ENOENT) (* (raise (Unix_error (ENOENT,"readdir","/FIXMEreaddir"))) (* FIXME we may need access to the underlying path that was given by the user *) *)
    | Fname2 _ -> (myraise ENOTDIR) (* (raise (Unix_error (ENOTDIR,"readdir","/FIXMEreaddir"))) *)
    | Dname2(d0_ref,ns) -> (
      let r = ops.readdir1 s0 d0_ref in
      (put_state' r) >>= (fun _ -> (
      return r.ret2))))))
  let (_:ty_ops' -> rname2' -> ret_value ty_mymonad') = readdir
  (* NB later we may want to also return a state, given access times can cause changes when reading etc *)

  (* FIXME surely a lot of this complexity is because this is the user land behaviour of the mv command - but we want to target the syscall interface *)
  (* FIXME we probably want the containing dirs as well, when doing rename; put this in resolve *)
  (* FIXME rename to subdir of self? *)
  let rename ops rsrc rdst = (
    get_state >>= (fun s0 -> 
    match rsrc with
    | None2 _ -> (myraise ENOENT) (* no src file *)
    | Err2 (_,_) -> (
      (* target may have ENOENT path *)
      (match rdst with 
      | None2 ns_dst -> (
        match get_parent_dir ops s0 ns_dst with
        | None -> (maybe_raise ENOENT) (* parent dir of dst doesn't exist *)
        | Some _ -> do_nothing)
      | _ -> do_nothing) >>= fun _ -> (
      myraise ENOTDIR))
    | Fname2 (i0_ref,ns_src) -> (
      match rdst with 
      | None2 ns_dst -> (
        (* do the move; there is no file ns_dst *)
        (* FIXME check rename to target where parent doesn't exist *)
        match get_parent_dir ops s0 ns_dst with
        | None -> (myraise ENOENT) (* parent dir of dst doesn't exist *)
        | Some(d1_ref) -> (
          let Some(d0_ref) = get_parent_dir ops s0 ns_src in
          put_state'' (fun () -> ops.mv1 s0 d0_ref (last ns_src.ns2) d1_ref (last ns_dst.ns2))))
      | Fname2 (i1_ref,ns_dst) -> (
        (* do the move; there is a file name ns_dst *)
        let Some(d0_ref) = get_parent_dir ops s0 ns_src in
        let Some(d1_ref) = get_parent_dir ops s0 ns_dst in
        if (ns_dst.ns2=ns_src.ns2) then 
          return None1 
        else
          put_state'' (fun () -> ops.mv1 s0 d0_ref (last ns_src.ns2) d1_ref (last ns_dst.ns2)))
        (* FIXME may want to have putstate return a void value *)
      | Dname2 (d0_ref,ns_dst) -> (
        (* several reasonable options *)
        (if (ns_dst.ends_with_slash2) then 
          maybe_raise ENOTDIR         (* arguably a Linux bug? not posix? *)
        else 
          do_nothing) >>= (fun _ -> 
        if ((ops.readdir1 s0 d0_ref).ret2<>Names1[]) then 
          maybe_raise ENOTEMPTY       (* arguably a Linux bug? not posix? *)
        else
          do_nothing) >>= (fun _ ->
        myraise EISDIR))
      | Err2(_,_) -> (
        myraise ENOTDIR))
    | Dname2 (d0_ref,ns_src) -> (
      (* directory exists *)
      match rdst with
      | None2 ns_dst -> (
        (* do the move; there is no file ns_dst *)
        let Some(d0_ref) = get_parent_dir ops s0 ns_src in
        match get_parent_dir ops s0 ns_dst with
        | None -> (myraise ENOENT) (* parent dir of dst doesn't exist *)
        | Some(d1_ref) -> (
          if (resolve_subdir ns_src ns_dst) then 
            myraise EINVAL
          else
            put_state'' (fun () -> ops.mvdir1 s0 d0_ref (last ns_src.ns2) d1_ref (last ns_dst.ns2))))
      | Err2 (_,ns_dst) -> (
        (if (resolve_subdir ns_src ns_dst) then
          maybe_raise EINVAL 
        else 
          do_nothing) >>= (fun _ -> 
        myraise ENOTDIR))
      | Fname2 (_,ns_dst) -> (
        (* check rename to subdir before rename to file; NB there are different reasonable options here *)
        (if (resolve_subdir ns_src ns_dst) then
          maybe_raise EINVAL 
        else 
          do_nothing) >>= (fun _ -> 
        myraise ENOTDIR)) (* arguably this is a bug in linux? *)
      | Dname2 (d1_ref,ns_dst) -> (
        (* if same dir, return silently *)
        if (d1_ref=d0_ref) then
          (return None1)
        (* FIXME check if renaming to a subdir *) (* FIXME following two exceptions should be maybe_raise *)
        else if (resolve_subdir ns_src ns_dst) then 
          (myraise EINVAL)
        (* FIXME check if dir not empty *)
        else if ((ops.readdir1 s0 d1_ref).ret2<>Names1[]) then 
          (myraise ENOTEMPTY)          (* arguably a Linux bug? not posix? *)
        (* otherwise target dir is empty; do rename; FIXME presumably root, if empty, can't be target unless src=root *)
        (* FIXME with the unix backend, we really don't want to execute this last because we know we are going to raise an error; but we must allow for future stages to raise further exceptions *)
        else
          let Some(d0_ref) = get_parent_dir ops s0 ns_src in
          let Some(d1_ref) = get_parent_dir ops s0 ns_dst in
          put_state'' (fun () -> ops.mvdir1 s0 d0_ref (last ns_src.ns2) d1_ref (last ns_dst.ns2))))))
  let (_:ty_ops' -> rname2' -> rname2' -> ret_value ty_mymonad') = rename      

  let rmdir ops rpath = (
    get_state >>= fun s0 ->
    match rpath with 
    | Dname2(d0_ref,ns) -> (
      if ((ops.readdir1 s0 d0_ref).ret2<>Names1[]) then
        (myraise ENOTEMPTY)
      else
        let Some(d1_ref) = get_parent_dir ops s0 ns in
        let s0 = ops.unlink1 s0 d1_ref (last ns.ns2) in
        put_state' s0)
    | Fname2 _ -> (myraise ENOTDIR)
    | None2 _ -> (myraise ENOENT))

  let stat ops rname2 = (
    get_state >>= (fun s0 -> (
    (* let _ = (print_endline ("stat: "^(string_of_rname2 rname2))) in *)
    match rname2 with
    | None2 _ -> (myraise ENOENT)  (* (raise (Unix_error (ENOENT,"stat","/FIXMEstat"))) *)
    | Fname2(i0_ref,ns) -> (return (Stats1 (default_file_stats ops s0 i0_ref)))
    | Dname2(d0_ref,ns) -> (return (Stats1 (default_dir_stats ops s0 d0_ref)))))) (* FIXME remove ops arg from default_dir_stats *)
  let (_:ty_ops' -> rname2' -> ret_value ty_mymonad') = stat

  let truncate ops rpath len = (
    get_state >>= fun s0 ->
    match rpath with 
    | None2 _ -> (myraise ENOENT)
    | Dname2(_,_) -> (myraise EISDIR) (* FIXME check error messages are sensible *)
    | Fname2(i0_ref,ns) -> (
      let r = ops.read1 s0 i0_ref in
      let bs = dest_bytes1 r.ret2 in
      (* create a new array, of length len, with same contents *)
      let bs' = MyDynArray.resize bs len in
      let s0 = ops.write1 s0 i0_ref bs' in
      put_state' s0))
  let (_:ty_ops' -> rname2' -> int -> ret_value ty_mymonad') = truncate

  let unlink ops rpath = (
    get_state >>= fun s0 ->
    match rpath with 
    | None2(_) -> (myraise ENOENT)
    | Dname2(_,_) -> (myraise EISDIR)
    | Fname2(i0_ref,ns) -> (
      (* FIXME for resolving a file, often useful to have dir ref as well *)
      let Some(d0_ref) = get_parent_dir ops s0 ns in
      let s0 = ops.unlink1 s0 d0_ref (last ns.ns2) in
      put_state' s0))

  (* FIXME we need to make this take an offset in order to be usable, also read *)
  let write ops rname2 ofs bs len = (
    get_state >>= fun s0 -> 
    match rname2 with 
    | None2 _ -> (myraise ENOENT) (* (raise (Unix_error (ENOENT,"read","/FIXMEwrite"))) *)
    | Dname2(_,_) -> (myraise ENOENT) (* (raise (Unix_error (ENOENT,"read","/FIXMEwrite"))) *)
    | Fname2(i0_ref,ns) -> (
      choose (downto' len 0) >>= fun len ->
      let r = ops.read1 s0 i0_ref in
      let bs' = dest_bytes1 r.ret2 in
      (* want to create a new array from bs' and bs *)
      let bs'' = MyDynArray.write (bs,0,len) (bs',ofs) in
      let r = ops.write1 s0 i0_ref bs'' in
      put_state' r >>= fun _ -> 
      return (Int1 len)))
  let (_:ty_ops' -> rname2' -> int -> file_contents -> int -> ret_value ty_mymonad') = write


end

@fs_spec.md
## `Fs_ops3`

This works in terms of strings; handles Err2 on resolving 

@fs_spec.ml

(* FIXME check mv if src=dst *)
module Fs_ops3 = struct 

  open Fs_types1
  open Resolve
  open Fs_ops2


  (* for the purposes of type-checking the following defns without spurious type vars *)
  module X3 = struct 
    type 'a ty_return3' = (X.Y.t5,'a) ty_return3
    type 'a ty_mymonad' = (X.Y.t5,'a) mymonad
    type rname2' = (X.Y.t1,X.Y.t3) rname2    
    (* type ty_ops' = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)
    type ty_ops' = (X.Y.t1,X.Y.t3,X.Y.t5) ty_ops1
  end
  open X3

  let link ops src dst = (
    get_state >>= fun s0 -> 
    let rsrc = process_path ops s0 src in
    let rdst = process_path ops s0 dst in
    Fs_ops2.link ops rsrc rdst)

  let mkdir ops path perms = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.mkdir ops rpath perms)

  (* FIXME we have to take care of flags eg O_TRUNC *)
  (* FIXME return is int option - meaning optional file handle? *)
  (* FIXME why is this called fopen (taking an fd?) rather than open? *)
  (* FIXME the mapping between fds and files is handled elsewhere - needs a new part of spec *)
  let _open ops path flags = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    match rpath with
    | None2 _ -> (myraise ENOENT)
    | Dname2(_,_) -> (myraise ENOENT) (* FIXME? can we open a dir? *)
    | _ -> (return None1))
  let (_:ty_ops' -> string -> 'a -> ret_value ty_mymonad') = _open
 
  (* open call returns an fd; but may have side effects; open create is one such call; FIXME what are others? *)
  let open_create ops path = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.open_create ops rpath)

  (* N.B. for read and write ofs is associated with fd, so presumably < len of file *)
  let read ops path ofs len = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.read ops rpath ofs len)
  
  let readdir ops path = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.readdir ops rpath)

  (* FIXME check do_rename against ops2.rename; also check against doc in linux sys programming *)
  let rename ops src dst = (
    get_state >>= fun s0 -> 
    let rsrc = process_path ops s0 src in
    let rdst = process_path ops s0 dst in
    Fs_ops2.rename ops rsrc rdst)
  let (_:ty_ops' -> string -> string -> ret_value ty_mymonad') = rename

  let rmdir ops path = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.rmdir ops rpath)

  let stat ops path = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.stat ops rpath)

  let truncate ops path len = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.truncate ops rpath len)

  let unlink ops path = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.unlink ops rpath)

  let write ops path ofs bs len = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.write ops rpath ofs bs len)

  (* FIXME this is a hack - should do lots of checking eg src is a dir *)
  let symlink ops src dst = (
    open_create ops dst >>= fun _ -> 
    write ops dst 0 (MyDynArray.of_string src) (String.length src) >>= fun _ -> 
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 dst in
    let Fname2(i0_ref,_) = rpath in
    let r = ops.set_symlink1 s0 i0_ref true in
    put_state' r)
  let (_:ty_ops' -> string -> string -> ret_value ty_mymonad') = symlink    

end


@fs_spec.md
## Transition system

The model is of a labelled transition system from state to state, but
where each transition may result in a return to userland (of a value
or an error). FIXME need to be non-determinisitic eg in write and read
behaviour.

@fs_spec.ml

module Transition_system = struct

  open Prelude 
  open Fs_types1
  open Fs_ops2
  open Fs_ops3

  module X4 = struct 
    (* for the purposes of type-checking the following defns without spurious type vars *)
    (* type ty_ops' = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)
    type ty_ops' = (X.Y.t1,X.Y.t3,X.Y.t5) ty_ops1
    type state' = X.Y.t5
  end
  open X4

  (* the transition function takes a state, a label, and returns an updated state with a possible value returned, or an error *)
  (* FIXME readlink is just read, but may want to have a separate label *)
  let trans ops s0 lbl = (
    (* let _ = print_endline (string_of_label lbl) in *)
    let m = (match lbl with 
      | LINK (s,d) -> (link ops s d)
      | MKDIR (s,p) -> (mkdir ops s p)
      | OPEN (p,fs) -> (
          if (List.mem O_CREAT fs) then (open_create ops p (* FIXME fs *)) 
          else (_open ops p fs))
      | READ (p,i,j) -> (read ops p i j)
      | READDIR p -> (readdir ops p)
      | RENAME (s,d) -> (rename ops s d)
      | RMDIR p -> (rmdir ops p)
      | STAT p -> (stat ops p)
      | SYMLINK (s,d) -> (symlink ops s d)
      | TRUNCATE (p,l) -> (truncate ops p l)
      | UNLINK p -> (unlink ops p)
      | WRITE (p,ofs,bs,len) -> (write ops p ofs bs len))
    in
    let rs = run_mymonad m s0 in
    let f1 ve = (match ve with
      | Inl(s,e) -> (s,Inl e)
      | Inr(s,v) -> (s,Inr v))
    in
    let rs = List.map f1 rs in
    rs)
  let (_:ty_ops' -> state' -> ty_label -> (state' * (error,ret_value)sum) finset) = trans

  (* convenience method to process a label; always choose first possible result (state,e+v) *)
  let process_label ops s0 lbl = (
    let rs = trans ops s0 lbl in
    let _ = if rs = finset_empty then failwith "process_label: no result state" else () in
    let (s',v) = finset_choose rs in
    (s',v))
  
  (* convenience method to process a list of labels *)
  let process_labels ops s0 lbls = (
    let f1 = (fun xs -> fun lbl -> 
      let l = last xs in
      let (_,_,(s,_)) = l in
      let (s',v) = process_label ops s lbl in
      xs@[(List.length xs,lbl,(s',v))])
    in
    let dummy_lbl = LINK("dummy lbl","dummy lbl") in
    let dummy_error_or_value = Inr None1 in
    List.fold_left f1 [(0,dummy_lbl,(s0,dummy_error_or_value))] lbls)
  let (_:ty_ops' -> state' -> ty_label list -> (int * ty_label * (state' * (error,ret_value)sum)) list) = process_labels

end

@fs_spec.md
## `Fs_spec_everything`
@fs_spec.ml

module Fs_spec_everything = struct

  include Fs_prelude
  include Prelude
(*  include File_utils *)
  include Fs_types1
(*  include Lift *)
(*  include Common *)
(*  include Fs_ops1 *)
  include Resolve
  include Fs_ops2
  include Fs_ops3
  include Transition_system

end

@fs_spec.md
## Debug
@fs_spec.ml
(* FIXME do we need to generalize this over ops? yes probably *)
module Debug = struct
  
  open Prelude
  open Fs_types1

(*
  let string_of_entry e = (
    let i = (match e with
    | Inl dref -> (string_of_int (dest_dir_ref dref))
    | Inr iref -> (string_of_int (dest_inode_ref iref)))
    in
    "("^i^")")
*)

  let rec string_of_dir ops s0 dirname d0_ref = (
    let Some(d0) = ops.lookup_dir s0 d0_ref in
    let ns = ops.get_entries d0 in
    let is_file ops s0 d0_ref n = (
      let Some(e) = ops.resolve1 s0 d0_ref n in
      is_inode_ref_entry e)
    in
    let is_dir ops s0 d0_ref n = (not (is_file ops s0 d0_ref n)) in
    let this_dir = (String.concat "\n" (List.map (fun n -> n) ns)) in    
    let this_dir = if ns <> [] then this_dir ^ "\n" else this_dir in
    let other_dirs = List.filter (fun n -> is_dir ops s0 d0_ref n) ns in
    let f1 n = (
      let Some(e) = ops.resolve1 s0 d0_ref n in
      let d1_ref = dest_dir_ref_entry e in
      string_of_dir ops s0 (dirname ^ "/" ^ n) d1_ref)
    in
    let others = List.map f1 other_dirs in
    "Directory "^dirname^":\n"
    ^ this_dir
    ^ (String.concat "" others))
    
  (* assume no cycles *)
  let string_of_state ops s = (
    let Some(d0_ref) = ops.get_root s in
    (string_of_dir ops s "/" d0_ref))

end



@test write

let s0 = state0
let s = s0
let lbl = OPEN("/tmp.txt",[O_CREAT])
let (s,Inr _) = trans s lbl
let lbl = WRITE("/tmp.txt",0,MyDynArray.of_string "hello",5)
let (s,Inr _) = trans s lbl
let lbl = READ("/tmp.txt",0,5)
let (s,Inr(Bytes1(bs))) = trans s lbl
let _ = MyDynArray.to_string bs


@test rename

open Fs_spec_everything;;

let s0 = DummyFs.state0
let s = s0
let (s,Inr _) = trans s (OPEN("/tom.txt",[O_CREAT]))
let _ = print_endline (string_of_state s)
let (s,Inr _) = trans s (RENAME("/tom.txt","/jen.txt"))
let _ = print_endline (string_of_state s)

let s0 = DummyFs.state0
let s = s0
let (s,Inr _) = trans s (OPEN("/tom.txt",[O_CREAT]))
let _ = print_endline (string_of_state s)
let r = Fs_ops1.mv s (Dir_ref 0,get_dir s (Dir_ref 0)) "tom.txt" (Dir_ref 0,get_dir s (Dir_ref 0)) "jen.txt"
let s = r.state2
let _ = print_endline (string_of_state s)




@test symlink

let s0 = DummyFs.state0
let s = s0
let (s,Inr _) = trans s (SYMLINK("tom.txt","/jen.txt"))


@test include

module A = struct
  type t = int
end

module B = struct
  type t = A.t
end

module C = struct
  include A 
  include B
end

(* fix: since these are only for type checking, we simply need to wrap them in a module defn and open them, rather than declaring them; the names of the dummy modules must be unique *)

module A = struct
  module D = struct end
end

module B = struct
  module D = struct end
end

module C = struct
  include A 
  include B
end


@fs_spec_extras.ml

(* interactive:

    #require "sha";;

*)

open Fs_prelude
open Fs_spec

module Extra_ops = struct

  open Prelude
  open Fs_types1

  let process_label = Transition_system.process_label

(*
  let kind_of_inode ops s0 i0 = (
    if (ops.get_symlink i0) then S_LNK else S_REG)
*)


  let kind_of_inode_ref ops s0 i0_ref = (
      if (ops.get_symlink1 s0 i0_ref) then S_LNK else S_REG)

  let kind_of_entry ops s0 e = (
    match e with 
    | Inl _ -> S_DIR
    | Inr i0_ref -> (
      kind_of_inode_ref ops s0 i0_ref))

  let kind_of_path ops s0 p = (
    let rn = Resolve.process_path ops s0 p in
    match rn with
    | Dname2(_,_) -> S_DIR
    | Fname2(i0_ref,_) -> (kind_of_inode_ref ops s0 i0_ref)
    | _ -> (failwith ("kind_of_path, absent path: "^p)))

  let kind_of_name ops s0 d0_ref name = (
    let Some(e) = ops.resolve11 s0 d0_ref name in
    kind_of_entry ops s0 e)

  (* return a list of paths; p should point to a dir *)
  let ls_path ops s0 p = (
    let rn = Resolve.process_path ops s0 p in
    let Dname2(d0_ref,_) = rn in
    let ns = name_list_of_rname2 rn in
    let p = string_of_names ns.ns2 in
    let p = if p = "/" then "" else p in
    let Names1(es) = (ops.readdir1 s0 d0_ref).ret2 in
    let r = List.map (fun n -> p^"/"^n) es in
    r)

  let rec find_path ops s0 p = (
    let xs = ls_path ops s0 p in
    let ds = List.filter (fun p -> kind_of_path ops s0 p = S_DIR) xs in
    (* let xs = List.filter (fun p -> kind_of_path ops s0 p <> S_DIR) xs in *)
    let xs' = List.concat (List.map (find_path ops s0) ds) in
    xs@xs')

  let read_all ops s0 p = (
    let (_,Inr(Stats1(s))) = process_label ops s0 (STAT p) in
    let len = s.Unix.LargeFile.st_size in
    let (_,Inr(Bytes1 bs)) = process_label ops s0 (READ(p,0,(* FIXME *)Int64.to_int len)) in
    bs)

  let inode_of_path ops s0 p = (
    let (_,Inr(Stats1(s))) = process_label ops s0 (STAT p) in
    s.Unix.LargeFile.st_ino)

end


(* FIXME shouldn't this work with ops? *) (* FIXME try and remove this *)
module File_utils2 = struct 

  open Unix

  type path = string list
  
  (* in this module, filenames (lists of strings) are absolute *)
  let string_of_longfname s = "/" ^ (String.concat "/" s)
  
  (* our operations on filesystems can be parameterized in terms of ls and readlink *)
  type 'a fs_ops = {
    ls4: 'a -> path -> path list;
    kind4: 'a -> path -> file_kind;
    readlink4: 'a -> path -> string;
    inode4: 'a -> path -> int
  }
 
  let is_dir ops s d = (ops.kind4 s d = S_DIR)
    
  let is_link ops s f = (ops.kind4 s f = S_LNK)

  let is_file ops s f = (ops.kind4 s f = S_REG)
      
  (* FIXME make tail recursive, alphabetical etc *)
  let rec find ops s d = 
    let ss = ops.ls4 s d in
    let ds = List.filter (is_dir ops s) ss in
    (List.concat (List.map (find ops s) ds))@ss (* order: want leaves first *)

end

(* FIXME shouldn't this work with ops? *) (* FIXME try and remove this *)
module Unix_utils = struct

  open File_utils2
  
  let string_of_path = File_utils2.string_of_longfname
  let path_of_string s = Str.split (Str.regexp "/") s

  (* return a list of list of strings - a long filename is a list of dirs and a filename *)
  let ls d = (
    let lines = ref [] in
    let h = Unix.opendir (string_of_path d) in
    try
      while true; do
        lines := Unix.readdir h :: !lines
      done; []
    with End_of_file ->
      Unix.closedir h;
      let fs = List.map (fun s -> d@[s]) (List.filter (fun s -> not (s="." || s = "..")) (List.rev !lines)) in
      List.sort Pervasives.compare fs)
  let (_:string list -> string list list) = ls

  let kind f = (
    let open Unix.LargeFile in
    let stats = lstat (string_of_path f) in
    match stats.st_kind with 
    | Unix.S_DIR -> Unix.S_DIR
    | Unix.S_REG -> Unix.S_REG
    | Unix.S_LNK -> Unix.S_LNK
    | _ -> (failwith ("Unknown file type for file: "^(string_of_path f)))) 

  let inode f = (
    let open Unix.LargeFile in
    let stats = lstat (string_of_path f) in
    stats.st_ino)
  
  let readlink f = (
    let s = Unix.readlink (string_of_path f) in
    (* path_of_string *) s)

  let unix_ops = {
    ls4=(fun _ -> ls);
    kind4=(fun _ -> kind);
    readlink4=(fun _ -> readlink);
    inode4=(fun _ -> inode)
  }

  let is_file = File_utils2.is_file unix_ops ()
    
  let find = File_utils2.find unix_ops ()

end


(* interactive:

    #use "local_resources/p3_lib.toplevel.ml";;
    #use "local_resources/mycsv.toplevel.ml";;

*)

(* FIXME shouldn't this work with ops? *) (* FIXME try and remove this *)
module Unix_dump_fs = struct

  open Unix
  open Unix_utils
  open Mycsv
  open Sha1
 
  let sha1_of_file fname = Sha1.to_hex (Sha1.file_fast fname)

  let sha1_of_string s = Sha1.to_hex (Sha1.string s)

  let records_of_path s = (
    let p = path_of_string s in
    let fs = find p in
    let f1 f = (
      let s = string_of_path f in
      let k = kind f in
      match k with 
      | S_REG -> [s;"F";(string_of_int (inode f));(sha1_of_file s)]
      | S_DIR -> [s;"D"]
      | S_LNK -> [s;"L";(readlink f)]
      | _ -> failwith "main")
    in
    let ss = List.map f1 fs in
    ss)

(*
  let fs = find ["tmp";"a"]
  let fs = List.filter is_file fs 
  let _ = List.map (fun f -> (string_of_path f,inode_of_file f, sha1_of_file (string_of_path f))) fs

  let _ = sha1_of_file "/mnt/sda7/tom/downloads/ubuntu/xubuntu-12.04.2-desktop-i386.iso"

  let fs = find ["tmp"]

  let _ = sha1_of_file "/tmp/a/tom.txt"
  let _ = sha1_of_file "/tmp/a/jen.txt"
*)

end


module Dump_fs = struct

  open Prelude
  open Fs_types1
  open Sha1
 
  let sha1_of_string s = Sha1.to_hex (Sha1.string s)

  (* sha1 of contents of file *)
  let sha1_of_path ops s0 p = (
    let bs = Extra_ops.read_all ops s0 p in
    let s = MyDynArray.to_string bs in
    sha1_of_string s)

  let find = Extra_ops.find_path
  let kind = Extra_ops.kind_of_path
  let inode_of_path = Extra_ops.inode_of_path

  (* we need to maintain a map of inodes that we have already seen, so we can update them as we go; we maintain a counter c from 1, and insert (inode,c++) into map when meeting new inode *)
  (* note this ordering is sensitive to the order of the paths ps! *)
  let get_normalized_inodes ops s0 ps = (
    let f1 (c,m,sofar) p = (
      (* check whether p's inode has already been seen *)
      let i = inode_of_path ops s0 p in
      match (fmap_lookup m i) with
      | None -> (
        let m' = fmap_update m (i,c) in
        (c+1,m',fmap_update sofar (p,c)))
      | Some i' -> (
        (c,m,fmap_update sofar (p,i'))))
    in
    let (_,_,ips) = List.fold_left f1 (1,fmap_empty,fmap_empty) ps in
    ips)

  let records_of_path ops s0 s = (
    let ps = find ops s0 s in
    let fps = List.filter (fun p -> Extra_ops.kind_of_path ops s0 p = S_REG) ps in
    let inodes_map = get_normalized_inodes ops s0 fps in
    let f1 p = (
      let k = kind ops s0 p in
      match k with 
      | S_REG -> [p;"F";(string_of_int (dest_Some (fmap_lookup inodes_map p)));(sha1_of_path ops s0 p)]
      | S_DIR -> [p;"D"]
      | S_LNK -> [p;"L";(MyDynArray.to_string (Extra_ops.read_all ops s0 p))]
      | _ -> failwith "main")
    in
    let ss = List.map f1 ps in
    ss)

  (* convert to csv data *)
  let dump_of_path ops s0 p = (
    let open Mycsv in
    let rs = records_of_path ops s0 p in
    let params = { sep="|"; outsep="|"; newline="\n"; dquote="\"" } in
    let s = String.concat "" (List.map (format params None1 rs) rs) in
    s)


(*

  #use "unix_impl.toplevel.ml";;
  let ops = Unix_impl.Unix_impl_everything.ops1
  let s0 = Unix_impl.Unix_impl_everything.state0
  let _ = records_of_path ops s0 "/"
  let _ = print_endline(dump_of_path ops s0 "/")
 
*)

end


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ignore
# Local variables

Local Variables:
mode: tuareg
mode: hi-lock
mode: outline-minor
outline-regexp: "@\\|#+"
End:

