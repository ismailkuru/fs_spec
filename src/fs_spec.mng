Hi-lock: (("^@.*" (0 (quote hi-blue-b) t)))
Hi-lock: (("^#+.*" (0 (quote hi-green-b) t)))

@fs_spec.md
# Interactive top-level directives

Via findlib:

    #use "topfind";;
    #require "unix";;
    #require "bigarray";;
    #require "str";;
    (* #cd "/tmp/l/general/research/fs/fs_spec/src";; *)
    #use "fs_prelude.toplevel.ml";;
    #use "fs_spec.toplevel.ml";;
    open Fs_prelude;;
    open Fs_spec;;
    open Fs_spec_everything;;

@tasks issues fs_spec.md
# Tasks

  * sync, datasync

  * expose spec fs via ocaml fuse

  * optimizations  

  * impl

# Issues

Format of the issues file is: prio|cat|desc

(shell-command "soffice /tmp/l/general/research/fs/resources/fs_issues.ods &")

FIXME this probably isn't very clever?


prio|cat|desc
|impl/freelist|"

interaction with freelist in impl; but we don't want to keep writing
the modified freelist to disk every time; if allocation is
deterministic (say, we don't reuse deallocated blocks till latest
time, and there is sufficient space available) then we can play a
similar trick to that with max ref count - just update every 100
allocations or so; we may lose some free space if we crash, but we may
not care about that;

"

|impl/parent_pointers|"

need to have parent pointers in dirs; which requires mutating two
objects atomically when moving;

do we really need parent pointers? any file/dir is accessed via a
path, which presumably gives the parents, so parents could just be
provided by some in-memory cache; an alternative scheme is here:
file:///tmp/l/general/camera_uploads/tmp/2013-03-08_09.55.50.jpg

decision for now: don't include in spec? a dir listing can include
. and .., with obvious meanings; in impl, filenames can be resolved
into dir list and name, so we don't need to deal with .. (except that
a process has a cwd, but this is stored in long format)

"
   
|impl/parent_pointers|"

reference counting is in the spec since files track number of links -
user visible but involves mutating two things atomically; how to deal
with reference counting for files? and dirs?

reference counting for files: without parent pointers, we run into the
problem here:
file:///tmp/l/general/camera_uploads/tmp/2013-03-08_10.22.56.jpg

with parent pointers, we can check whether a file's parent actually
points to the file; if not, we can roll forward to correct the error;
but this check may need to happen every time we check the number of
links, which is quite a lot!
file:///tmp/l/general/camera_uploads/tmp/2013-03-08_10.41.47.jpg so
one option would be to allow link counts to be high, and get fsck to
correct any that are no-longer linked

TEST this issue: crash system in middle of a link file, and check link
counts when restoring system

decision on ref counting: don't do for now, but include in a future
version
"

|spec|change model of names to include trailing slash
|spec|"

note that there are several possible semantics for fsync fd: it syncs
data associated with the fd, or it syncs all data (perhaps written by
other processes) associated with the backing file. We opt for the
latter interpretation, but we should test this, and make a note in the
spec"


|spec|"

does fsync work against file or fd?

need to think about readdir, when other processes are messing about with the directory; do we just want to punt on this?

"

|spec|"

read and write are really against fds - this ensures that even if the
file is renamed etc the read and write are unaffected; the current
fuse interface passes a path to the file to read; would be interesting
to see what fuse does if a process opens a file, and the file is then
moved - is fuse tracking that the filename has changed, and subsequent
reads go to the new file? this seems very messy; we might want to say
that we don't support reading and writing to an fd whilst the file is
renamed; alternatively, the fds have to become part of the spec

does ocamlfuse provide an fd interface to read and write? 

read and write with fds (and readdir) cannot be considered atomic even in non-failure case, so they do interact with other calls e.g. readdir on a directory that is subsequently renamed

fuse allows an additional "struct fuse_file_info *" to be passed into open, and subsequent read calls presumably use this in preference to the path name

also worth noting that fuse can mess with syscalls, which is why we want to run tests directly against the fs

"

|spec|"

probably have to move to fd based interface for open read and write

what happens when open is called on a dir? EISDIR?
"

|test|test whether weak-memory like behaviour is observable (see 2013-04-17)
|test|"

do writes to a file hit the disk in order? (motivation: what a db
might like to assume; against this, there is the fsync command (or
fdatasync) that can enforce these dependencies, so by default the
correct answer is surely no)"

|test/tool_support|"

need a tool to take a list of actions (need pretty print for each
action) and replay against a filesystem"

|theory|"

is there a uniform way to handle partial (mostly disk-backed, but
partly in memory) datastructures? do we want to hold the entire
directory hierarchy (but not the data) in memory at the same time? how
to control the caching of data?"

|theory|"

new idea for persistent objects: graphs, with pointers, acyclic, new
versions etc; the fully persistent implementation (ie all old versions
are accessible) requires writing new versions of all blocks that are
above a modified block; could just have two versions of the pointers
and flick between then when creating new versions (but this requires
that we don't confuse old versions of pointers with new versions);

see notes 2013-04-26"

|tmpfs|add logging layer in fuse interface
|tmpfs|. and .. entries in dir list
|tmpfs|link with a real block layer (see 2013-04-02)
|tmpfs|need options eg to turn tracing on and off

@fs_prelude.md
# fs_prelude.ml
## Prelude

The initial code for `MyDynArray` is a hacky attempt to implement
dynamic arrays. Later I wanted functional arrays (no update in place)
which I tacked on. TODO this all needs to be redone. We want a
functional interface and an efficient implementation that assumes
linear usage (ie updates in place). We should also check that uses are
linear.

@fs_prelude.ml

(* some basic list defns *)

(* downto n m = [n;n-1;...;m] *)
let rec downto' n m = (if n < m then [] else n::(downto' (n-1) m))


(* sets as lists *)
module Finset = struct

  type 'a finset = 'a list

  let empty_finset = []

  let finset_empty = []

  let finset_diff xs1 xs2 = (
    let f1 a x = (if (not (List.mem x xs2)) then x::a else a) in
    List.fold_left f1 [] xs1)
    
  let finset_subset xs1 xs2 = (finset_diff xs1 xs2 = empty_finset)

  let finset_equal xs1 xs2 = ((finset_subset xs1 xs2) && (finset_subset xs2 xs1))

  let finset_mem x xs = (List.mem x xs)

  let finset_union xs1 xs2 = xs1 @ xs2

  let finset_insert x xs = (if List.mem x xs then xs else x::xs)

  let finset_partition = List.partition

  let finset_bigunion = List.concat (* do we want to remove duplicates? FIXME do our finsets have duplicates? *)

  let finset_singleton x = finset_insert x finset_empty

  let finset_image f x = List.map f x

  let finset_choose xs = (
    if xs = finset_empty then failwith "finset_choose: empty finset" else List.hd xs)

end

include Finset

module Fmap = struct

  type ('dom,'cod) fmap = ('dom * 'cod) list
  
  let fmap_remove m a = (List.filter (fun (a',_) -> a' <> a) m)
  let fmap_update m (a,b) = (a,b)::(fmap_remove m a)
  let fmap_lookup m a = try Some(List.assoc a m) with _ -> None
  let fmap_dom m = List.map fst m
  let fmap_empty = []

end

include Fmap  


(* dynamic arrays: resize an array to a target size, using doubling *)
module MyDynArray1 = struct
  
  module A = Bigarray.Array1
  
  type myfusebuffer = (char, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t
  
  type t = myfusebuffer (* keep abstract? *)
  
  (* let get_array (da:t) = (da:myfusebuffer) *)

  (* FIXME hopefully this works with 0 length arrays *)
  (* target <= resize' target cur *)
  let rec resize' target cur = (
    let cur = (if cur=0 then 1 else cur) in
    if target <= cur then cur else resize' target (2*cur))
  
  (* resize an array so that it is at least as big as n; invariant: minsize <= dim (resize da minsize) *)
  let resize da minsize = (
    let cur = Bigarray.Array1.dim da in
    let newsize = resize' minsize cur in
    if (newsize = cur) then da else (
      let newbuf = A.create (A.kind da) (A.layout da) newsize in
      let _ = A.blit da (A.sub newbuf 0 (A.dim da)) in
      newbuf))
      
end

module type MYDYNARRAY = sig

  type myfusebuffer = (char, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t

  type t

  val of_array : myfusebuffer -> t

  val of_string : string -> t

  val to_array: t -> myfusebuffer

  val to_string: t -> string

  val repn: t -> int * myfusebuffer

  val create : unit -> t

  val dim : t -> int

  val resize : t -> int -> t

  val get: t -> int -> char

  val set: t -> int -> char -> t

  val blit : t * int * int -> t * int -> t

  (* FIXME don't need if have to_array etc? *)
  (* val blit_array1: t * int * int -> myfusebuffer * int -> int *)

  val sub: t -> int -> int -> t

  (* copy bytes from arr1 to arr2, giving a new array *)
  val write: (t*int*int) -> (t*int) -> t

end


(* like an array, but the array is potentially larger than the data we need to store, so we also keep track of the length of the data *)
module MyDynArray2 = struct

  type myfusebuffer = (char, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t

  module A = Bigarray.Array1

  (* i is the length of the dynamic array, given some implementation; invariant (i,arr): i <= dim arr *)
  type t = int * MyDynArray1.t

  type mynewtypefixme = int

  let repn (i,arr) = (i,arr)

  let dim (i,arr) = i

  let resize (i,arr) j = (j,MyDynArray1.resize arr j)

  let of_array arr = (A.dim arr,arr)

  (* convenience only; don't use in production code *)
  let of_string bs = (
    let arr = (Array.init (String.length bs) (String.get bs)) in
    let contents : myfusebuffer = A.of_array Bigarray.char Bigarray.c_layout arr in
    of_array contents)

  (* FIXME we could return the underlying array directly, with a sub *)
  let to_array (i,arr1) = (
    let arr2 = A.create Bigarray.char Bigarray.c_layout i in
    let _ = A.blit (A.sub arr1 0 i) arr2 in
    arr2)

  let to_string (i,arr1) = (
    let s = String.create i in
    let _ = 
      for j=0 to i-1 do
        String.set s j (A.get arr1 j)
      done
    in
    s)

  let create () = (
    let arr = A.create Bigarray.char Bigarray.c_layout 4096 in
    let _ = A.fill arr '\x00' in
    (0, arr))

  let get (i,arr) j = (if j<i then A.get arr j else raise (Invalid_argument "MyDynArray2: get, index out of bounds"))

  let set (i,arr) j c = (
    let arr = (if j > A.dim arr then (MyDynArray1.resize arr j) else (arr)) in
    let i = (if j >= i then j+1 else i) in
    let _ = A.set arr j c in
    (i,arr))

  (* assumes ofs1+len1<i (sim with the other ops) ; resizes if necessary, ie may not mutate in place! *)
  let blit ((i1,arr1),ofs1,len1) ((i2,arr2),ofs2) = (
    let size2 = ofs2+len1 in
    let (i2,arr2) = (
      if (i2 < size2) then (size2,MyDynArray1.resize arr2 size2) else (i2,arr2))
    in
    let _ = A.blit (A.sub arr1 ofs1 len1) (A.sub arr2 ofs2 len1) in
    (i2,arr2))

  (* arr2 is a buffer eg that we are reading to; we return the number of bytes copied *)
  (* assumes ofs1+len1 < i1 *)
  (*
  let blit_array1 ((i1,arr1),ofs1,len1) (arr2,ofs2) = (
    let len = min len1 (A.dim arr2 - ofs2) in
    let _ = A.blit (A.sub arr1 ofs1 len) (A.sub arr2 ofs2 len) in
    len)
  *)

  (* FIXME we need a module representing arrays, but where the ops act functionally ie they return a new array every time *)
  (* FIXME decide what the functional interface to arrays should be; maybe we should mutate and assume arrays are used linearly? *)
  (* behaves as functional call *)
  let sub (i,arr) ofs len = (
    let arr2 = A.sub arr ofs len in
    (A.dim arr2,arr2))
 
  let copy (i,arr) = (
    let arr' = create () in
    let _ = blit ((i,arr),0,i) (arr',0) in
    arr')

  (* behaves as functional call *)
  let write ((i2,arr2),ofs2,len2) (arr1,ofs1)  = (
    let arr2 = blit ((i2,arr2),ofs2,len2) (arr1,ofs1) in
    arr2)
   
end

module MyDynArray = (MyDynArray2 : MYDYNARRAY)

@test mydynarray

let arr = MyDynArray.create ()
let arr = MyDynArray.write (MyDynArray.of_string "hello",0,5) (arr,0)
let true = ("hello" = MyDynArray.to_string arr)

let _ = MyDynArray.to_string (MyDynArray.of_string "hello")

@fs_prelude.ml

module Prelude = struct

  module type MYSET = sig
    type elt 
    type t
    val add : elt -> t -> t
    val choose : t -> elt
    val diff : t -> t -> t
    val elements : t -> elt list
    val empty : t
    val filter : (elt -> bool) -> t -> t
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val from_list : elt list -> t
    val is_empty : t -> bool
    val list_union : elt list -> t -> t
    val map : (elt -> elt) -> t -> t
    val maximal_less_than : elt -> t -> elt option
    val mem : elt -> t -> bool
    val remove : elt -> t -> t
    val split : elt -> t -> t * bool * t
    val union : t -> t -> t
  end
  
  module MySet_Make = functor (Ord:Set.OrderedType) -> (struct
    include Set.Make(Ord)
    let maximal_less_than e s = (
      let (smaller,_,larger) = split e s in
      if (is_empty smaller) then None else (Some(max_elt smaller)))
    let rec itlist f l b =
      match l with
        [] -> b
      | (h::t) -> f h (itlist f t b)
    let list_union xs s =
      itlist (fun x -> fun s -> (*Set_earley_item.*)add x s) xs s
    let map f s =
      let f1 x s = (*Set_earley_item.*)add (f x) s in
      (*Set_earley_item.*)fold f1 s (*Set_earley_item.*)empty
    let from_list elts = 
      let f1 elt s = add elt s in
      itlist f1 elts empty
  end : MYSET with type elt = Ord.t)  

  module type MYMAP = sig
    type key
    type value
    type ty_map
    val empty : ty_map
    val add : key -> value -> ty_map -> ty_map
    val remove:key -> ty_map -> ty_map
    val find2 : key -> ty_map -> value
    val bindings : ty_map -> (key * value) list
  end

  (* argument to Map functor *)
  (* FIXME what if we insert a default value? we may want to remove the k,v in the map; but this requires that we can check that a value is a default *)
  module type MAPINPUT = sig
      type key
      type value
      val compare : key -> key -> int
      val default: value
      val is_default: value -> bool
  end
  
  module MyMap = functor (MapInput:MAPINPUT) -> (struct
    module Ord = struct
        type t = MapInput.key
        let compare = MapInput.compare
    end
    include Map.Make(Ord)
    type value=MapInput.value
    type ty_map=MapInput.value t
    let add k v m = (
      if MapInput.is_default v then remove k m else add k v m)
    let find2 k m =
      if (mem k m) then (find k m) else MapInput.default
  end : (MYMAP with type key = MapInput.key and type value = MapInput.value))

  (* basic library functions *)
  
  type ('a,'b) sum = Inl of 'a | Inr of 'b
  
  let is_Inl x = (match x with | Inl x -> true | _ -> false)
  let is_Inr x = (match x with | Inr x -> true | _ -> false)

  let dest_Inl x = (match x with | Inl x -> x | _ -> failwith "dest_Inl")
  let dest_Inr x = (match x with | Inr x -> x | _ -> failwith "dest_Inr")
  
  (* FIXME change names of predefined combinators to reflect use of not_epsilon (i.e. default is epsilon) *)
  
  let rec itlist f l b =
    match l with
      [] -> b
    | (h::t) -> f h (itlist f t b);;
  
  let rec mem x lis =
    match lis with
      [] -> false
    | (h::t) -> Pervasives.compare x h = 0 or mem x t;;
  
  let insert x l =
    if mem x l then l else x::l;;
  
  let union l1 l2 = itlist insert l1 l2;;
  
  let unions l = itlist union l [];;
  
  
  let ($) f g x = f(g x)
  
  (*
  let read_file_as_string fn = 
    let f = open_in fn in
    let s = ref "" in
    let _ = try (while(true) do s := (!s) ^ (input_line f) ^ "\n" done) with _ -> () in
    let _ = close_in f in
    !s
  *)
  
  let lines fname = 
    let lines = ref [] in
    let chan = if fname="-" then Pervasives.stdin else open_in fname in
    try
      while true; do
        lines := input_line chan :: !lines
      done; []
    with End_of_file ->
      close_in chan;
      List.rev !lines
  
  let read_file_as_string fn = 
    let ls = lines fn in
    ((String.concat "\n" ls)^"\n")
  
  (* get a list with no duplicates; inefficient? FIXME do we mean List.memq? *)
  let unique_f res e = if List.mem e res then res else e::res
  
  (* this is insertion sort; alternatives? *)
  let unique = fun e -> List.fold_left unique_f [] e
  
  let is_Some x = x <> None
  
  let dest_Some x = match x with Some y -> y | _ -> failwith "dest_Some"

  let rec allpairs f l1 l2 =
    match l1 with
     h1::t1 ->  itlist (fun x a -> f h1 x :: a) l2 (allpairs f t1 l2)
     | [] -> []

  let rec last l =
    match l with
      [x] -> x
    | (h::t) -> last t
    | [] -> failwith "last";;
  
  let rec butlast l =
    match l with
      [_] -> []
    | (h::t) -> h::(butlast t)
    | [] -> failwith "butlast";;


  let implode l = itlist (^) l "";;
  
  let explode s =
    let rec exap n l =
        if n < 0 then l else
        exap (n - 1) ((String.sub s n 1)::l) in
    exap (String.length s - 1) [];;

  (* from http://rosettacode.org/wiki/Read_entire_file#OCaml ; when does memory mapping occur? before Unix.close? or does it continually refer to the file on disk? *)

  type myfusebuffer = (char, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t

  (* tr notes: if filename is empty, the mapping fails; so in this case, we do something special *)
  let read_file_as_array filename = (
    let fd = Unix.openfile filename [Unix.O_RDONLY] 0o640 in
    let len = Unix.lseek fd 0 Unix.SEEK_END in
    let _ = Unix.lseek fd 0 Unix.SEEK_SET in
    let shared = false in  (* modifications are done in memory only *)
    let bstr = (if len=0 then (
      Bigarray.Array1.create Bigarray.char Bigarray.c_layout 0
    ) else (
      Bigarray.Array1.map_file fd
        Bigarray.char Bigarray.c_layout shared len))
    in
    Unix.close fd;
    (bstr))
  let (_:string -> myfusebuffer) = read_file_as_array

  (* FIXME probably doesn't work if arr length 0 *)
  let write_array_as_file arr filename = (
    let fd = Unix.openfile filename [Unix.O_RDWR;Unix.O_CREAT;Unix.O_TRUNC] 0o640 in
    let len = Bigarray.Array1.dim arr in
    let _ = Unix.lseek fd 0 Unix.SEEK_SET in
    let shared = true in  (* modifications are done in memory only *)
    let bstr = (Bigarray.Array1.map_file fd
                  Bigarray.char Bigarray.c_layout shared len)
    in
    let _ = Bigarray.Array1.blit arr bstr in 
    let _ = Unix.close fd in
    ())
  let (_:myfusebuffer -> string -> unit) = write_array_as_file

  module My_stream = struct 

    open Bigarray

    (* FIXME scons is at front; snoc is at back; change scons to snoc *)
    (* ('a,'b) stream_ops is the type of streams implemented using type 'a, with vals in 'b *)
    type ('a,'b) stream_ops = { dest_strm:'a -> (unit,'b*'a)sum; snc: ('b*'a) -> 'a }
    (* the following is just for packaging streams into a single value; don't expect ops to change! *)
    type ('a,'b) stream = { impl: 'a; ops: ('a,'b) stream_ops }

    let is_snil s = (match s.ops.dest_strm s.impl with 
      | Inl () -> true
      | _ -> false)

    let dest_stream s = (
      let Inr(v,impl) = s.ops.dest_strm s.impl in
      (v,{s with impl=impl}))

    let snoc (c,s) = (
      let impl = s.ops.snc (c,s.impl) in
      {s with impl=impl})
  
    (* lists as streams *)
    type 'a list_stream = ('a list,'a) stream
    let list_stream_ops = {
      dest_strm=(fun x -> match x with
        | [] -> (Inl ())
        | x::xs -> Inr(x,xs));
      snc=(fun (x,xs) -> xs@[x])
    }
  
    let rec stream_takeall s = (match is_snil s with 
      | true -> []
      | false -> (
        let (c,s) = dest_stream s in
        c::(stream_takeall s)))
    let (_:('a,'b)stream -> 'b list) = stream_takeall


    (* representing streams of characters using a string; impl is a string and an index *)
    let chars_of_string_ops = {
      dest_strm=(fun (s,i) -> (
        if i=String.length s then Inl()
        else Inr(String.get s i,(s,i+1))
      ));
      snc=(fun (c,(s,i)) -> (s^(String.make 1 c),i))
    }
    let chars_of_string s = {impl=(s,0); ops=chars_of_string_ops}
    let (_:string -> (string*int,char) stream) = chars_of_string
  
    (* more efficient - a char stream is a string between a low and high index *)
    let chars_of_string_ops = {
      dest_strm=(fun (s,l,h) -> (
        if l=h then Inl()
        else Inr(String.get s l,(s,(l+1),h))
      ));
      snc=(fun (c,(s,l,h)) -> (
        let s = (if (h=String.length s) then (
          (* need to reallocate *)
          let _ = if 0=String.length s then failwith "chars_of_string_ops: s length 0" else () in
          let s' = String.make ((2*(String.length s))) '\x00' in
          let _ = String.blit s 0 s' 0 (String.length s) in
          s')
          else s)
        in
        let _ = String.set s h c in
        (s,l,h+1)))
    }
    let chars_of_string s = (
      (* backing strings must be non-empty if we are multiplying length by 2 when resizing *)
      if s = "" then {impl=("..",0,0); ops=chars_of_string_ops}
      else {impl=(s,0,String.length s); ops=chars_of_string_ops})
    let (_:string -> (string*int*int,char) stream) = chars_of_string
  
    (* to avoid using stream_takeall, we allow to get the stream contents directly from the impl *)
    let chars_of_string_takeall s = (
      let (s,l,h) = s.impl in
      String.sub s l (h-l))
    let (_:(string*int*int,char) stream -> string) = chars_of_string_takeall
  

    (* FIXME these stream types should be in the stream module *)
    (* also want to deal with arrays particularly myfusebuffer; at the moment only need to read; use dynarray? *)
    let chars_of_array_ops = {
      dest_strm=(fun (s,l,h) -> 
        if l=h then Inl()
        else Inr(Array1.get s l,(s,(l+1),h)));
      snc=(fun _ -> failwith "chars_of_array_ops")
    }
    let chars_of_array s = (
      (* backing strings must be non-empty if we are multiplying length by 2 when resizing *)
      (* we never scons, so we don't need to worry about 0 length array *)
      {impl=(s,0,Array1.dim s); ops=chars_of_array_ops})
    let (_:myfusebuffer -> (myfusebuffer*int*int,char) stream) = chars_of_array

    let chars_of_dynarray_ops = {
      dest_strm=(fun (s,l,h) -> 
        if l=h then Inl()
        else Inr(MyDynArray.get s l,(s,(l+1),h)));
      snc=(fun (c,(s,l,h)) -> 
        let s = MyDynArray.set s h c in
        (s,l,h+1))
    }
    let chars_of_dynarray s = (
      {impl=(s,0,MyDynArray.dim s); ops=chars_of_dynarray_ops})
    let (_:MyDynArray.t -> (MyDynArray.t*int*int,char) stream) = chars_of_dynarray
  
  end

  include My_stream
  
end




(* based partially on http://ocaml-batteries-team.github.io/batteries-included/hdoc/BatBase64.html *)
(* following for encoding binary data into human readable string *)
(* FIXME should probably perform some basic checks on the input - at the momemnt we fail if input is not wellformed *)
(* FIXME maybe pad, so output is a multiple of 4 bytes - this is what eg the base64 command line tool does; this requires an extra character to indicate "no data"; this is the "padding" referred to in the wikipedia article on base64 *)
module Encode = struct

  open Prelude

  let rec string_of_chars cs = (match cs with | [] -> "" | c::cs -> (String.make 1 c)^(string_of_chars cs))

  (* from batteries *)
  type encoding_table = char array (* length 64, take a number from 0-63 and give a char *)
  type decoding_table = int array

  type safe_char = (* subtype of *) char (* should be one of the chars below *)

  type bits_6 = int (* only bottom 6 bits may be non zero *)
  type bits_8 = int
  
  let chars = [|
          'A';'B';'C';'D';'E';'F';'G';'H';'I';'J';'K';'L';'M';'N';'O';'P';
          'Q';'R';'S';'T';'U';'V';'W';'X';'Y';'Z';'a';'b';'c';'d';'e';'f';
          'g';'h';'i';'j';'k';'l';'m';'n';'o';'p';'q';'r';'s';'t';'u';'v';
          'w';'x';'y';'z';'0';'1';'2';'3';'4';'5';'6';'7';'8';'9';'+';'/'
  |]
  
  let make_decoding_table tbl =
          if Array.length tbl <> 64 then failwith "make_decoding_table";
          let d = Array.make 256 (-1) in
          for i = 0 to 63 do
                  Array.unsafe_set d (int_of_char (Array.unsafe_get tbl i)) i;
          done;
          d
  
  let inv_chars = make_decoding_table chars
  
  (* data contains at least 32 bits? what are the assumptions on data? *)
  (* count is number of bits in data that are valid; valid bits are count-1,count-2,...,0 *)
  let rec encode (sofar,data,count,input) = (
    (* try and output a char if possible *)
    if (count >= 6) then (
      (* at least 6 bits in data - output an encoded char *)
      let d = (data asr (count - 6)) land 63 in
      let c = (Array.unsafe_get chars d) in
      encode ((snoc (c,sofar)),data,count-6,input)
    ) else (
      match is_snil input with
      | true -> (
        (* tricky case - less that 6 bits available *)
        if (count > 0) then 
          let d = (data lsl (6-count)) land 63 in
          let c = (Array.unsafe_get chars d) in
          snoc (c,sofar)
        else
          sofar)
      | false -> (
        let (c,input) = dest_stream input in
        let data = (data lsl 8) lor (Char.code c) in
        let count = count + 8 in
        encode (sofar,data,count,input))))

  let encode_string s = (
    let cs = encode ((chars_of_string ""),0,0,chars_of_string s) in
    chars_of_string_takeall cs)
  let (_:string->string) = encode_string
  
  (* the data is decoded bits *)
  let rec decode (sofar,data,count,input) = (
    if (count >= 8) then (
      (* at least 8 bits in data *)
      let d = (data asr (count - 8)) land 0xFF in
      let c = Char.chr d in
      decode (snoc (c,sofar),data,count-8,input)
    ) else (
      match is_snil input with 
      | true -> (
        (* assume the data is 0 padding bytes, so discard *)
        sofar)
      | false -> (
        let (c,input) = dest_stream input in
        let d = Array.unsafe_get inv_chars (Char.code c) in
        let data = (data lsl 6) lor d in
        decode (sofar,data,count+6,input))))
 
  let decode_string s = (
    let cs = decode ((chars_of_string ""),0,0,chars_of_string s) in
    chars_of_string_takeall cs)
  let (_:string->string) = decode_string

  let encode_array s = (
    let cs = encode ((chars_of_string ""),0,0,chars_of_array s) in
    let cs = stream_takeall cs in
    string_of_chars cs)
  let (_:myfusebuffer->string) = encode_array
  
    
  (* test 
  let _ = encode_string "Man is distinguished"
  let _ = encode_string "Man is distinguis"
  let _ = decode_string "TWFuIGlzIGRpc3Rpbmd1aXN"
  *)

  (* further fiddling *)
  (*
  let bits_6_of_8 = (
    let is_snil=(fun (s,data,count) -> (count=0) && (s.ops.is_snil s.impl)) in
    let rec dest_scons=(fun (s,data,count) -> (
      if count >= 6 then (
        (* at least 6 bits in data - output an encoded char *)
        let d = (data asr (count - 6)) land 63 in
        (d,(s,data,count-6))
      ) else (
        match s.ops.is_snil s.impl with
        | true -> (
          (* tricky case - less that 6 bits available *)
          (* this is only called if not is_snil, which implies that count > 0 *)       
          let d = (data lsl (6-count)) land 63 in
          (d,(s,data,0)))
        | false -> (
          let (c,s_impl) = s.ops.dest_scons s.impl in
          let s = {s with impl=s_impl} in
          let data = (data lsl 8) lor (Char.code c) in
          let count = count + 8 in
          dest_scons (s,data,count)))))
    in
    let scons=(fun _ -> failwith "bits_6_of_8") in
    let ops = { is_snil; dest_scons; scons } in
    fun s -> { impl=(s,0,0); ops=ops })
  let (_:('a,char)stream -> (('a,char)stream*int*int,bits_6)stream) = bits_6_of_8

  let encode_6 = (
    let is_snil=(fun s -> s.ops.is_snil s.impl) in
    let dest_scons=(fun s -> 
      let (i,s_impl) = s.ops.dest_scons s.impl in
      let s = {s with impl=s_impl} in
      let c = (Array.unsafe_get chars i) in
      (c,s)) 
    in
    let scons=(fun _ -> failwith "encode_6") in
    let ops = { is_snil; dest_scons; scons } in
    fun s -> {impl = s; ops=ops})
  let (_:('a,bits_6)stream -> (('a,bits_6)stream,safe_char) stream) = encode_6
  (* FIXME might be nice to have record notation for types, rather than pairs *)
  *)

  (* test 
  let s = chars_of_string "Man"
  let s2 = bits_6_of_8 s
  let s3 = encode_6 s2 
  let _ = stream_takeall s3  
  *)

end



@test streams

let int_stream_ops = (
   let is_snil=(fun _ -> false) in
   let rec dest_scons=(fun i -> (i,i+1)) in
   { is_snil; dest_scons; scons=(fun _ -> failwith "int_stream_ops") })

let int_stream = { impl=0; ops=int_stream_ops }

let rec take n s = (if n = 0 then [] else 
   let (c,impl) = s.ops.dest_scons s.impl in
   c::(take (n-1) {s with impl=impl}))

let _ = take 10 int_stream

let _ = stream_takeall (chars_of_string "hello")


@test mydynarray

module A = Bigarray.Array1

let tmp = A.create Bigarray.char Bigarray.c_layout 4096

let tmp2 = A.of_array Bigarray.char Bigarray.c_layout [| 'h';'e';'l';'l';'o' |]

let _ = A.blit (A.sub tmp2 0 5) (A.sub tmp 0 5)

let tmp3 = MyDynArray.create ()

let _ = MyDynArray.dim tmp3

let tmp3 = MyDynArray.blit ((MyDynArray.of_array tmp2),0,5) (tmp3,0)

let _ = MyDynArray.dim tmp3

let tmp4 = A.create Bigarray.char Bigarray.c_layout 4096

let _ = MyDynArray.blit_array1 (tmp3,0,5) (tmp4,0)

let _ = A.get tmp4 4

@fs_spec.md
# fs_spec.ml
## Fs_types1

Types common to all implementations of the basic operations

@fs_spec.ml

open Fs_prelude

(* as an optimization, we expect that each of these refs is actually a ref to a sector *)

module Fs_types1 = struct

  open Prelude

  type num = int (* FIXME; also fix uses of type int below to be num where appropriate *)

  type bytes = MyDynArray.t
  type name = string (* shortest component of a filename - doesn't include /; may be empty; may be . or .. *)

  type error =
      E2BIG
    | EACCES
    | EAGAIN
    | EBADF
    | EBUSY
    | ECHILD
    | EDEADLK
    | EDOM
    | EEXIST
    | EFAULT
    | EFBIG
    | EINTR
    | EINVAL
    | EIO
    | EISDIR
    | EMFILE
    | EMLINK
    | ENAMETOOLONG
    | ENFILE
    | ENODEV
    | ENOENT
    | ENOEXEC
    | ENOLCK
    | ENOMEM
    | ENOSPC
    | ENOSYS
    | ENOTDIR
    | ENOTEMPTY
    | ENOTTY
    | ENXIO
    | EPERM
    | EPIPE
    | ERANGE
    | EROFS
    | ESPIPE
    | ESRCH
    | EXDEV
    | EWOULDBLOCK
    | EINPROGRESS
    | EALREADY
    | ENOTSOCK
    | EDESTADDRREQ
    | EMSGSIZE
    | EPROTOTYPE
    | ENOPROTOOPT
    | EPROTONOSUPPORT
    | ESOCKTNOSUPPORT
    | EOPNOTSUPP
    | EPFNOSUPPORT
    | EAFNOSUPPORT
    | EADDRINUSE
    | EADDRNOTAVAIL
    | ENETDOWN
    | ENETUNREACH
    | ENETRESET
    | ECONNABORTED
    | ECONNRESET
    | ENOBUFS
    | EISCONN
    | ENOTCONN
    | ESHUTDOWN
    | ETOOMANYREFS
    | ETIMEDOUT
    | ECONNREFUSED
    | EHOSTDOWN
    | EHOSTUNREACH
    | ELOOP
    | EOVERFLOW
    | EUNKNOWNERR of int
 
  (* from unix.mli *)
  type open_flag =
      O_RDONLY                    (** Open for reading *)
    | O_WRONLY                    (** Open for writing *)
    | O_RDWR                      (** Open for reading and writing *)
    | O_NONBLOCK                  (** Open in non-blocking mode *)
    | O_APPEND                    (** Open for append *)
    | O_CREAT                     (** Create if nonexistent *)
    | O_TRUNC                     (** Truncate to 0 length if existing *)
    | O_EXCL                      (** Fail if existing *)
    | O_NOCTTY                    (** Don't make this dev a controlling tty *)
    | O_DSYNC                     (** Writes complete as `Synchronised I/O data
                                     integrity completion' *)
    | O_SYNC                      (** Writes complete as `Synchronised I/O file
                                     integrity completion' *)
    | O_RSYNC                     (** Reads complete as writes (depending on
                                     O_SYNC/O_DSYNC) *)
    | O_SHARE_DELETE              (** Windows only: allow the file to be deleted
                                   while still open *)

  type file_perm = int


  type file_kind = 
    S_REG                       (** Regular file *)
  | S_DIR                       (** Directory *)
  | S_LNK                       (** Symbolic link *)


  


  (* top-level labels, intended to mirror the syscalls, but with functional interface; TODO need to incorporate file descriptors, "current position" etc *)
  type ty_label = 
    | LINK of (string * string)
    | MKDIR of (string * file_perm)
    | OPEN of (string * open_flag list)
    | READ of (string * int * int)
    | READDIR of string
    | RENAME of (string * string)
    | RMDIR of string
    | STAT of string
    | SYMLINK of (string * string)
    | TRUNCATE of (string * int)
    | UNLINK of string
    | WRITE of (string * int * bytes * int)


  type file_contents = bytes (* really a map from index to ... *)

  type ret_value = None1 | Int1 of int | Bytes1 of bytes (* FIXME add init return type *) | Names1 of name list
    | Stats1 of Unix.LargeFile.stats
  let dest_bytes1 (Bytes1 bs) = bs
 
  (* names types; also type name earlier *)
  
  (* following moved from ops parser *)
  type dirname = string list
  type filename = string list (* non-empty *)

  type ('dir_ref,'inode_ref) entry = ('dir_ref,'inode_ref) sum
  let is_dir_ref_entry = is_Inl
  let is_inode_ref_entry = is_Inr
  let dest_dir_ref_entry = dest_Inl
  let dest_inode_ref_entry = dest_Inr

  (* break the string into components *)
  type ty_name_list = {
    ns2: name list; (* invariant: not [] *)
  }
  (* let ends_with_slash nl = nl.ends_with_slash2 *)

  (* process . and .. and empty entries relative to a cwd *)
  type ('dir_ref) ty_realpath1 = {
    cwd3: 'dir_ref; (* cwd for process *)
    nl3: ty_name_list; (* the original string *)
    ns3: name list; (* invariant: not []; first entry is empty; no . and .. entries; no further empty entries (absolute paths) *)
    (* FIXME we don't need e3  if we are interested in paths *)                                  
                                  (* e3: (('dir_ref,'inode_ref) entry,name)sum (* inr means that the path might target a non-existent file or directory, but everything else resolved *) *)
  }
  type ('dir_ref,'inode_ref) ty_realpath = OK1 of ('dir_ref) ty_realpath1 | Err1 of (error * ty_name_list)
                       
  (* resolved name relative to a state *)
  type ('dir_ref,'inode_ref) res_name = 
    Dname2 of ('dir_ref * ('dir_ref) ty_realpath1)
  | Fname2 of ('dir_ref * name * 'inode_ref * ('dir_ref) ty_realpath1)
  | None2 of ('dir_ref * name * ('dir_ref) ty_realpath1)
  | Err2 of (error * ty_name_list)
  (* invariant: if Fname2 ns, then not (ns.ends_with_slash2) *)
  (* invariant: if Err2 then ns.ends_with_slash2 *)
  (* FIXME since these are resolved, we may want to include the i0_ref and d0_ref *)

  let is_Err2 x = (match x with | Err2 _ -> true | _ -> false)

  let name_list_of_res_name n = (match n with 
    | Dname2 (_,rp) -> rp.nl3
    | Fname2 (_,_,_,rp) -> rp.nl3
    | None2 (_,_,rp) -> rp.nl3
    | Err2 (_,nl) -> nl)

  type ('dir_ref,'inode_ref) ty_fs_label = 
      FS_LINK of (('dir_ref,'inode_ref) res_name * ('dir_ref,'inode_ref) res_name)
    | FS_MKDIR of (('dir_ref,'inode_ref) res_name * file_perm)
    | FS_OPEN of (('dir_ref,'inode_ref) res_name * open_flag list)
    | FS_READ of (('dir_ref,'inode_ref) res_name * int * int)
    | FS_READDIR of ('dir_ref,'inode_ref) res_name
    | FS_RENAME of (('dir_ref,'inode_ref) res_name * ('dir_ref,'inode_ref) res_name)
    | FS_RMDIR of ('dir_ref,'inode_ref) res_name
    | FS_STAT of ('dir_ref,'inode_ref) res_name
    | FS_SYMLINK of (('dir_ref,'inode_ref) res_name * string)
    | FS_TRUNCATE of (('dir_ref,'inode_ref) res_name * int)
    | FS_UNLINK of ('dir_ref,'inode_ref) res_name
    | FS_WRITE of (('dir_ref,'inode_ref) res_name * int * bytes * int)


  (*
  let is_None2 x = (match x with None2 _ -> true | _ -> false)
  *)


  type 'impl ty_return2 = {
    state2: 'impl;
    ret2: ret_value;
  } 
  let return_state s = { state2=s; ret2=None1 }


  type ('dir_ref,'inode_ref,'impl) ty_ops1 = {
    get_init_state1: unit -> 'impl;
    get_parent1: 'impl -> 'dir_ref -> ('dir_ref * name) option; (* if root, parent is none; possibly disconnected dirs can also have no parent *)
    get_root1: 'impl -> 'dir_ref option;
    dest_dir_ref1: 'impl -> 'dir_ref -> int;
    dest_inode_ref1: 'impl -> 'inode_ref -> int;
    get_symlink1: 'impl -> 'inode_ref -> bool;
    link_file1: 'impl -> 'inode_ref -> 'dir_ref -> name -> 'impl ty_return2;
    unlink1: 'impl -> 'dir_ref -> name -> 'impl ty_return2;
    mkdir1: 'impl -> 'dir_ref -> name -> 'impl ty_return2;
    mv1: 'impl -> 'dir_ref -> name -> 'dir_ref -> name -> 'impl ty_return2;
    mvdir1: 'impl -> 'dir_ref -> name -> 'dir_ref -> name -> 'impl ty_return2;
    read1: 'impl -> 'inode_ref -> 'impl ty_return2;
    readdir1: 'impl -> 'dir_ref -> 'impl ty_return2; (* don't return . and .. entries *)
    resolve11: 'impl -> 'dir_ref -> name -> ('dir_ref,'inode_ref) entry option; (* resolves normal entries; use get_parent for .. *)
    rm1: 'impl -> 'dir_ref -> name -> 'impl ty_return2; (* FIXME don't need this and unlink1 *)
    rmdir1: 'impl -> 'dir_ref -> name -> 'impl ty_return2; (* FIXME probably don't need this either *)
    touch1: 'impl -> 'dir_ref -> name -> 'impl ty_return2;
    write1: 'impl -> 'inode_ref -> bytes -> 'impl ty_return2;
    set_symlink1: 'impl -> 'inode_ref -> bool -> 'impl ty_return2;
  }

  (* calls to the fs take place in a process context *)
  type ('dir_ref,'impl) fs_state_process_state = {
    cwd4: 'dir_ref;
    fs_state4: 'impl
  }
    


  (* modelling the host *)

  (* process ids *)
  type ty_pid = Pid of num

  (* a process can only make a single call into OS (so, no threads); process is blocked until return *)
  type os_label = 
      OS_CALL of (ty_pid * ty_label)
    | OS_RETURN of (ty_pid * (error,ret_value) sum)
    | OS_CREATE of ty_pid
    | OS_DESTROY of ty_pid


  (* file descriptors *)
  type ty_fd = FD of num

  (* dir handles *)
  type ty_dh = DH of num

  (* FIXME check this in linux kernel docs; also, surely once it is closed we can just remove it, so we don't need this flag? *)
  type fd_open_closed_state = FD_OPEN | FD_CLOSED

  type dh_open_closed_state = DH_OPEN | DH_CLOSED



  type ('inode_ref) fd_state = {
    open_or_closed: fd_open_closed_state;
    inode_ref2: 'inode_ref;
    offset: num
  }

  type ('dir_ref) dh_state = {
    open_or_closed: dh_open_closed_state;
    dir_ref2: 'dir_ref;
    offset: num
  }

  type ('dir_ref,'inode_ref) ty_pid_run_state = RUNNING | BLOCKED_CALL of ('dir_ref,'inode_ref) ty_fs_label | PENDING_RETURN of ((error,ret_value) sum)

  type ('dir_ref,'inode_ref) per_process_state = {
    (* root3: 'dir_ref; *) (* process root directory; FIXME not currently implemented *)
    cwd: 'dir_ref; (* FIXME rename this *)
    fd_table: (ty_fd,('inode_ref) fd_state) fmap;
    dh_table: (ty_dh,('dir_ref) dh_state) fmap;
    pid_run_state: ('dir_ref,'inode_ref) ty_pid_run_state
  }

  type ('dir_ref,'inode_ref,'impl) ty_os_state = {
    pid_table: (ty_pid,('dir_ref,'inode_ref) per_process_state) fmap;
    fs_state: 'impl (* FIXME index this fieldname *)
  }



end

@fs_spec.md
## Resolve names

Update: we first process the string to give a list of entries; /a/b/c -> ["";"a";"b";"c"]; /a/b/c/ -> ["";"a";"b";"c";""]; a/b/c -> ["a";"b";"c"]; note that [] is not in the range of this function; the empty string "" maps to [""]. We keep this first list because we may need to examine it at some points. 

FIXME we need to distinguish between a null string and an empty string

what about a relative path that is empty? in this case, it appears that this is returned as an error ENOENT (so the CWD is not appended in this case)

interestingly if you delete /tmp/d1 and a process is still in d1, the PWD for that process is /tmp/d1; and in /proc/pid/cwd it says "/tmp/d1 (deleted)"


@fs_spec.ml

(* FIXME tidy this up *)
module X = struct

  open Fs_types1
  
  (* hack to get an abstract state type *)
  module Y : sig 
    type t1
    type t2
    type t3
    type t4
    type t5
  end = struct 
    type t1 = int
    type t2 = int
    type t3 = int
    type t4 = int
    type t5 = int
  end 

end

module Resolve = struct
 
  open Prelude
  open Fs_types1
(*  open Fs_ops1 *)

  (* for the purposes of type-checking the following defns without spurious type vars *)
  module XR = struct
    (* type ty_ops' = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)
    type ty_ops' = (X.Y.t1,X.Y.t3,X.Y.t5) ty_ops1
    type dir_ref' = X.Y.t1
    type ty_impl' = X.Y.t5
    type inode_ref' = X.Y.t3
    type ty_return' = X.Y.t5 ty_return2
    type rname' = (X.Y.t1,X.Y.t3) res_name
    type entry' = (dir_ref',inode_ref') entry
  end
  open XR

  (* we introduce a local type to record the result of trying to resolve a path *)
  type ('a,'b) ok_or_err = Ok3 of 'a | Err3 of 'b

  (* let file_exists ops s0 ns = (resolve_inode_ref ops s0 ns <> None) *)

  (* get the real path, given a dir_ref *)
  let rec real_path_dir_ref ops s0 d0_ref = (
    match (ops.get_parent1 s0 d0_ref) with
    | None -> [""]  (* FIXME not sure if we want to do this; perhaps introduce yet another type; this allows us to just append further names, but [""] is not a valid path from the user - ["";""] represents root *)
    | Some(d1_ref,n) -> (real_path_dir_ref ops s0 d1_ref)@[n])

  type ('dir_ref,'inode_ref) ty_resolve_relative_ok = 
    Dir4 of 'dir_ref
  | File4 of ('dir_ref * name * 'inode_ref)
  | None4 of ('dir_ref * name)

  let rec resolve_relative ops s0 sofar ns = (
    match ns with 
    | [] -> (Ok3(Dir4(sofar)))
    | n::ns -> (
      if (n=".") || (n="") then (
        resolve_relative ops s0 sofar ns
      ) else if (n="..") then (
        match ops.get_parent1 s0 sofar with
        | None -> (resolve_relative ops s0 sofar ns) (* FIXME not correct for disconnected dirs *)
        | Some(dir_ref,_) -> (resolve_relative ops s0 dir_ref ns)
      ) else (
        let m = ops.resolve11 s0 sofar n in
        match m with 
        | None -> (
          if (ns=[]) || (ns=[""]) then (* may end in a slash *)
            Ok3(None4(sofar,n))
          else
            Err3(ENOENT))
        | Some entry -> (
          match entry with 
          | Inr i0_ref -> (
            if ns=[] then (* not allowed to end in slash *)
              Ok3(File4(sofar,n,i0_ref)) 
            else
              Err3(ENOTDIR))
          | Inl d0_ref -> (
            resolve_relative ops s0 d0_ref ns)))))
  let (_:ty_ops' -> ty_impl' -> dir_ref' -> name list -> ((dir_ref',inode_ref')ty_resolve_relative_ok,error) ok_or_err) = resolve_relative

  let process_path1 path = (
    let p = explode path in
    let f1 (ns,cur) c = (if c="/" then (ns@[cur],"") else (ns,cur^c)) in
    let (ns,cur) = List.fold_left f1 ([],"") p in
    let ns = ns@[cur] in
    { ns2=ns })
  let (_:string -> ty_name_list) = process_path1

 (* assumes root not none *)
 let process_name_list ops s0 cwd nl = (
   let root = dest_Some (ops.get_root1 s0) in
   if nl.ns2 = [""] then Err2(ENOENT,nl) (* nl.ns2 was the empty string *)
   else (
     let is_absolute_nl = (List.hd nl.ns2 = "") in
     let r = (
       if is_absolute_nl then
         resolve_relative ops s0 root nl.ns2
       else
         resolve_relative ops s0 cwd nl.ns2)
     in
     match r with
     | Ok3 x -> (
       match x with
       | Dir4 d0_ref -> (
         let rp = { cwd3=cwd; nl3=nl; ns3=(real_path_dir_ref ops s0 d0_ref) } in
         Dname2(d0_ref,rp))
       | File4 (d0_ref,n,i0_ref) -> (
         let rp = { cwd3=cwd; nl3=nl; ns3=((real_path_dir_ref ops s0 d0_ref)@[n]) } in
         Fname2(d0_ref,n,i0_ref,rp))
       | None4 (d0_ref,n) -> 
         let rp = {cwd3=cwd; nl3=nl; ns3=(real_path_dir_ref ops s0 d0_ref)@[n] } in
         None2 (d0_ref,n,rp))
     | Err3 x -> (Err2(x,nl))))
  let (_:ty_ops' -> ty_impl' -> dir_ref' -> ty_name_list -> rname') = process_name_list

  (* guarantees: returns option of Fname or Dname  *)
  let process_path ops s0 cwd path = (
    let nl = process_path1 path in
    let rn = process_name_list ops s0 cwd nl in
    rn)  
  let (_:ty_ops' -> ty_impl' -> dir_ref' -> string -> rname') = process_path

  let process_path_from_root ops s0 path = (
    let root = dest_Some(ops.get_root1 s0) in
    process_path ops s0 root path)

  let ends_with_slash rn = (
    let nl = name_list_of_res_name rn in
    last (nl.ns2) = "")

  (* FIXME we want subsequent defns to work in terms of rname, and possible ty_name_list; we want invariants on these *)

  (* note that true = list_prefix [] [] = list_prefix xs xs; but the semantics checks e.g. whether we are rename something to itself *)
  let rec list_prefix xs ys = (
    match (xs,ys) with
    | ([],_) -> true
    | (_,[]) -> false
    | (x::xs,y::ys) -> (
      if (x=y) then list_prefix xs ys else false))

  (* check if renaming a dir to a subdir of itself; we expect to check for equality before calling this *)
  let subdir s d = (
    list_prefix s.ns3 d.ns3)


end

@fs_spec.md
## `Fs_ops2`

This is the main part of the spec. If a transition succeeds, it calls
a method such as `ops1.mv1` to actually make a change in the
underlying state. Most of the stuff below involves dealing with all
the error cases.

Invariant: if any exception is raised, the state is not changed

@fs_spec.ml

(* FIXME these work in terms of rnames; assumes no Err2 *)
module Fs_ops2 = struct
  
  open Unix (* for st_dev record fields etc *)
  open LargeFile (* FIXME include stats in Fs_types1? *)

  open Prelude
  open Fs_types1
(*  open Fs_ops1 *)
  (* open Resolve *)

(*  let get_parent_dir = Resolve.get_parent_dir
  let resolve_process_path2 = Resolve.process_path2 *)
  let resolve_subdir = Resolve.subdir
  let ends_with_slash = Resolve.ends_with_slash


  (* type error = Fs_types1.error *)
  type ('impl,'a) ty_return3 = (('impl * Fs_types1.error, 'impl * 'a) sum) finset
  (* vars u, v used eg for Mymonad u *)
  type ('impl,'a) mymonad = Mymonad of ('impl -> ('impl,'a) ty_return3)
  let dest_mymonad (Mymonad u) = u
  let return x = Mymonad (fun s -> finset_insert (Inr(s,x)) finset_empty)
  let (_:'a -> ('impl,'a) mymonad) = return

  (* for the purposes of type-checking the following defns without spurious type vars *)
  (* N.B. these dummy X module defns are interesting because they show what types are used in each module *)
  module X2 = struct
    type 'a ty_return3' = (X.Y.t5,'a) ty_return3
    type 'a ty_mymonad' = (X.Y.t5,'a) mymonad
    type res_name' = (X.Y.t1,X.Y.t3) res_name    
    (* type ty_ops' = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)
    type ty_ops' = (X.Y.t1,X.Y.t3,X.Y.t5) ty_ops1
  end
  open X2

  let bind u f = Mymonad (fun s0 ->
    let u = dest_mymonad u in
    let rs = u s0 in
    let f1 v = (match v with 
      | Inl x -> (finset_singleton (Inl x))
      | Inr (s,x) -> (
        let v = dest_mymonad (f x) in
        v s))
    in
    let rs' = finset_image f1 rs in
    let rs'' = finset_bigunion rs' in
    rs'')    
  let (_: 'a ty_mymonad' -> ('a -> 'b ty_mymonad') -> 'b ty_mymonad') = bind

  (* FIXME we also want to bake in that as soon as we have an exception, we will not alter the state further *)

  let ( >>= ) = bind
  
  let get_state = Mymonad (fun (s) -> finset_singleton(Inr(s,s)))
  let put_state s0 = Mymonad (fun (s) -> finset_singleton(Inr(s0,None1)))
  let myraise e = Mymonad (fun (s) -> finset_singleton(Inl(s,e)))
  let maybe_raise e = Mymonad (fun (s) -> 
    finset_insert (Inr(s,())) (finset_singleton(Inl(s,e))))

  (* bes is a list of (b,e); if exists a b that is true, raise those e's where b is true, else do nothing *)
  let cond_raise bes = Mymonad (fun s ->
    let bs = List.filter (fun (b,e) -> b=true) bes in
    if bs=[] then 
      finset_singleton(Inr(s,()))
    else
      finset_image (fun (b,e) -> Inl(s,e)) bs)      

  let choose xs = Mymonad (fun s -> finset_image (fun x -> Inr(s,x)) xs)

  (* for a deterministic version, choose some particular value *)
  let choose xs = Mymonad (fun s -> finset_singleton(Inr(s,finset_choose xs)))

  let do_nothing = Mymonad (fun s -> finset_singleton(Inr(s,())))

  let run_mymonad (Mymonad f) s = (f (s))
  let (_:('a,'b) mymonad -> 'a -> ('a,'b) ty_return3) = run_mymonad
  
  (*  let is_empty_dir (s0:'impl) ns = failwith "FIXME" *)

  let default_stats = {
    st_dev = 2049; (* device number FIXME 0? *)
    st_ino = 999; (* inode number FIXME change this for particular file etc *)
    st_kind = Unix.S_DIR; (* FIXME *)
    st_perm = 0o777; (* ugo+rwx *)
    st_nlink = 2; (* FIXME dummy - for dir should be number of entries + 2 *)
    st_uid = 1000; (* FIXME 0? *)
    st_gid = 1000; 
    st_rdev = 0; (* device minor number *)
    st_size = 4096L; (* FIXME dummy *)
    st_atime = 0.;
    st_mtime = 0.;
    st_ctime = 0.
  }

  let default_file_stats ops s0 i0_ref = { default_stats with
    st_ino=(ops.dest_inode_ref1 s0 i0_ref);
    st_kind=(
      if (ops.get_symlink1 s0 i0_ref) then Unix.S_LNK else Unix.S_REG); (* FIXME we may need our own stats structure *)
    st_size=(
      let bs = dest_bytes1 ((ops.read1 s0 i0_ref).ret2) in
      (Int64.of_int (MyDynArray.dim bs)))
  }
 
  let default_dir_stats ops s0 d0_ref = { default_stats with
    st_ino=(ops.dest_dir_ref1 s0 d0_ref);
    st_kind=Unix.S_DIR;
    st_size=4096L; (* seems to be default on my system - but changes depending on number of entries? *)
  }

  (* Fs_ops1 returns ty_return3, which apart from read is just a state *)
  let put_state' r = put_state r.state2

  (* FIXME remove *)
  let put_state'' f = (put_state' (f ()))

  (* posix/1 *)

  let link ops spath dpath = (
    get_state >>= fun s0 ->
    match spath with 
    | Fname2(d0_ref,name,i0_ref,rp)  -> (
      match dpath with 
      | None2 (d0_ref,n,rp) -> (
        let s0 = ops.link_file1 s0 i0_ref d0_ref n in
        put_state' s0)
      | Err2(e,_) -> (
        (* (maybe_raise EEXIST) >>= fun _x_ -> (* arguably linux bug *) *)
        myraise e)
      | Fname2 _ -> (myraise EEXIST)
      | Dname2 _ -> (myraise EEXIST))
    | Dname2 _ -> (
      (match dpath with
        | Err2(e,_) -> (maybe_raise e)
        | _ -> do_nothing) >>= (fun _x_ ->
      myraise EPERM))
    | Err2(e,_) -> (myraise e)
    | None2 __ -> (myraise ENOENT))

  let mkdir ops rpath perms = (
    (* FIXME deal with perms *)
    get_state >>= fun s0 ->
    match rpath with 
    | None2(d0_ref,n,_) -> (
      let s0 = ops.mkdir1 s0 d0_ref n in
      put_state' s0)
    | Err2(e,_) -> (myraise e)
    | Dname2 _ -> (myraise EEXIST)
    | Fname2 _ -> (myraise EEXIST))

  (* FIXME we have to take care of flags eg O_TRUNC *)
  (* FIXME return is int option - meaning optional file handle? *)
  (* FIXME why is this called fopen (taking an fd?) rather than open? *)
  (* FIXME the mapping between fds and files is handled elsewhere - needs a new part of spec *)
  let o_open ops rpath flags = (
    get_state >>= fun s0 ->
    match rpath with
    | None2 _ -> (myraise ENOENT)
    | Dname2(_,_) -> (myraise ENOENT) (* FIXME should be EISDIR? can we open a dir? *)
    | _ -> (return None1)) (* FIXME err case should raise an err? *)
  let (_:ty_ops' -> res_name' -> 'a -> ret_value ty_mymonad') = o_open

  let open_create ops rpath = (
    get_state >>= fun s0 ->
    match rpath with 
    | Dname2 _ -> (myraise EEXIST) 
    | Fname2 _ -> (myraise EEXIST)
    | Err2 (e,_) -> (myraise e)
    | None2(d0_ref,n,ns) -> (
      (* FIXME for us, open_create should only create files *)
      if ends_with_slash rpath then 
        myraise EISDIR
      else
        let s0 = ops.touch1 s0 d0_ref n in
        put_state' s0))
  let (_:ty_ops' -> res_name' -> ret_value ty_mymonad') = open_create

  (* FIXME the real spec would allow reading less than all the bytes; recall len is maxlen *)
  let read ops rn ofs len = (
    match rn with 
    | None2 _ -> (myraise ENOENT)
    | Dname2 _ -> (myraise ENOENT)
    | Err2 (e,_) -> (myraise e)
    | Fname2(d0_ref,n,i0_ref,rp) -> (
      get_state >>= (fun s0 -> (
      let r = ops.read1 s0 i0_ref in (* FIXME Fs_ops1 may have to take an offset too *)
      (put_state' r) >>= fun _x_ -> 
      (* non-deterministically choose the amount of data to write *)
      choose (downto' len 0) >>= fun len ->
      let bs = dest_bytes1 r.ret2 in
      let len_bs = MyDynArray.dim bs in
      (* assume ofs is wellformed *)
      let len = if ofs+len <= len_bs then len else len_bs - ofs in
      (* let _ = print_endline ("read len_bs: "^(string_of_int len_bs)^"; len: "^(string_of_int len)^"; ofs: "^(string_of_int ofs)) in *)
      (* let _ = print_endline "before" in *)
      let bs' = MyDynArray.sub bs ofs len in
      (* let _ = print_endline "after" in *)
      return (Bytes1(bs'))))))
  let (_:ty_ops' -> res_name' -> int -> int -> ret_value ty_mymonad') = read

  let readdir ops rn = (
    get_state >>= (fun s0 -> (
    match rn with 
    | Err2 (e,_) -> (myraise e)
    | None2 _ -> (myraise ENOENT) (* (raise (Unix_error (ENOENT,"readdir","/FIXMEreaddir"))) (* FIXME we may need access to the underlying path that was given by the user *) *)
    | Fname2 _ -> (myraise ENOTDIR) (* (raise (Unix_error (ENOTDIR,"readdir","/FIXMEreaddir"))) *)
    | Dname2(d0_ref,rp) -> (
      let r = ops.readdir1 s0 d0_ref in
      (put_state' r) >>= (fun _x_ -> (
      return r.ret2))))))
  let (_:ty_ops' -> res_name' -> ret_value ty_mymonad') = readdir
  (* NB later we may want to also return a state, given access times can cause changes when reading etc *)

  (* FIXME surely a lot of this complexity is because this is the user land behaviour of the mv command - but we want to target the syscall interface *)
  (* FIXME we probably want the containing dirs as well, when doing rename; put this in resolve *)
  (* FIXME rename to subdir of self? *)
  (* NB if an error is possible, then all transitions result in an error; we should check that this invariant holds of the spec *)

  (* posix/2 *)

  let rename ops rsrc rdst = (
    get_state >>= (fun s0 -> 
    match rsrc with
    | None2 _ -> (
      (* target may have ENOENT path *)
      (match rdst with 
      | Err2 (e',_) -> (
        maybe_raise e') (* tr/11 *)
      | _ -> do_nothing) >>= (fun _x_ -> (
        myraise ENOENT))) (* no src file *)
    | Err2 (e,_) -> (
      (* target may have ENOENT path *)
      (match rdst with 
      | Err2 (e',_) -> (
        maybe_raise e') (* tr/1 *)
      | _ -> do_nothing) >>= (fun _x_ -> (
      myraise e))) (* tr/2 *)
    | Fname2 (d0_ref,nsrc,i0_ref,rp) -> (
      match rdst with 
      | Err2 (e,_) -> (myraise e)
      | None2 (d1_ref,ndst,rp) -> (
        (let cond1 = ends_with_slash rdst in
        cond_raise [(cond1,ENOTDIR)]) >>= fun _x_ -> (* tr/3 similar to tr/5 *)
        (* do the move; there is no file ns_dst *)
        put_state'' (fun () -> ops.mv1 s0 d0_ref nsrc d1_ref ndst))
      | Fname2 (d1_ref,ndst,i1_ref,rp) -> (
        (* do the move; there is a file name ns_dst *)
        if (d1_ref=d0_ref) && (ndst=nsrc) then 
          return None1 (* tr/4 *)
        else
          put_state'' (fun () -> ops.mv1 s0 d0_ref nsrc d1_ref ndst))
        (* FIXME may want to have putstate return a void value *)
      | Dname2 (d0_ref,rp) -> (
        (* several reasonable options *)
        (if (ends_with_slash rdst) then 
          maybe_raise ENOTDIR         (* tr/5 arguably a Linux bug? Confirmed non-posix behaviour *)
        else 
          do_nothing) >>= (fun _x_ -> 
        if ((ops.readdir1 s0 d0_ref).ret2<>Names1[]) then 
          maybe_raise ENOTEMPTY       (* tr/6 strange, but posix allows this; FIXME posix also allows EEXIST in this case *)
        else
          do_nothing) >>= (fun _x_ ->
        myraise EISDIR))) (* expected *)
    | Dname2 (d0_ref,rps) -> (
      (* rename a directory; directory exists *)
      match rdst with
      | None2 (d1_ref,ndst,rpd) -> (
        (* do the move; there is no file ns_dst *)
        if (resolve_subdir rps rpd) then 
          myraise EINVAL
        else
          let p = ops.get_parent1 s0 d0_ref in
          match p with 
          | None -> (
            (* src was root *)
            myraise EINVAL)
          | Some(d0_ref,nsrc) -> (
            put_state'' (fun () -> ops.mvdir1 s0 d0_ref nsrc d1_ref ndst)))
      | Err2 (e,_) -> (
        (maybe_raise EINVAL) >>= (fun _x_ -> (* tr/7 confirmed non-posix behaviour *)
        myraise e))
      | Fname2 (_,_,_,rpd) -> (
        (* check rename to subdir before rename to file; NB there are different reasonable options here *)
        (if (resolve_subdir rps rpd) then
          maybe_raise EINVAL 
        else 
          do_nothing) >>= (fun _x_ -> 
        myraise ENOTDIR)) 
      | Dname2 (d1_ref,rpd) -> (
        (* if same dir, return silently *)
        if (d1_ref=d0_ref) then
          (return None1) (* tr/8 *)
        (* FIXME check if renaming to a subdir *) (* FIXME following two exceptions should be maybe_raise *)
        else if (resolve_subdir rps rpd) then 
          (myraise EINVAL)
        (* FIXME check if dir not empty *)
        else if ((ops.readdir1 s0 d1_ref).ret2<>Names1[]) then 
          (myraise ENOTEMPTY) (* tr/9 *)
        (* otherwise target dir is empty; do rename; FIXME presumably root, if empty, can't be target unless src=root *)
        (* FIXME with the unix backend, we really don't want to execute this last because we know we are going to raise an error; but we must allow for future stages to raise further exceptions *)
        else
          let x = ops.get_parent1 s0 d0_ref in
          let y = ops.get_parent1 s0 d1_ref in
          match (x,y) with
          | (None,_) -> (myraise EINVAL)
          | (_,None) -> (
            failwith "impossible rename of dir onto root; can't happen because dst must be nonempty")
          | (Some(d0_ref',nsrc),Some(d1_ref',ndst)) -> (
            put_state'' (fun () -> ops.mvdir1 s0 d0_ref' nsrc d1_ref' ndst))))))
  let (_:ty_ops' -> res_name' -> res_name' -> ret_value ty_mymonad') = rename      

  let rmdir ops rpath = (
    get_state >>= fun s0 ->
    match rpath with 
    | Dname2(d0_ref,rp) -> (
      if ((ops.readdir1 s0 d0_ref).ret2<>Names1[]) then
        (myraise ENOTEMPTY)
      else
        let x = ops.get_parent1 s0 d0_ref in
        match x with 
        | None -> (
          (* attempt to remove the root directory, may fail or succeed *)
          (maybe_raise EBUSY) >>= (fun _x_ ->
            (return None1)))
        | Some(d1_ref,n) -> (
          let s0 = ops.unlink1 s0 d1_ref n in
          put_state' s0))
    | Fname2 _ -> (myraise ENOTDIR)
    | None2 _ -> (myraise ENOENT)
    | Err2 (e,_) -> (myraise e))

  let stat ops rn = (
    get_state >>= (fun s0 -> (
    (* let _ = (print_endline ("stat: "^(string_of_res_name rn))) in *)
    match rn with
    | Err2 (e,_) -> (myraise e)
    | None2 _ -> (myraise ENOENT) 
    | Fname2(d0_ref,n,i0_ref,rp) -> (return (Stats1 (default_file_stats ops s0 i0_ref)))
    | Dname2(d0_ref,rp) -> (return (Stats1 (default_dir_stats ops s0 d0_ref)))))) 
  let (_:ty_ops' -> res_name' -> ret_value ty_mymonad') = stat

  let truncate ops rpath len = (
    get_state >>= fun s0 ->
    match rpath with 
    | Err2 (e,_) -> (myraise e)
    | None2 _ -> (myraise ENOENT)
    | Dname2 _ -> (myraise EISDIR) (* FIXME check error messages are sensible *)
    | Fname2(d0_ref,n,i0_ref,rp) -> (
      let r = ops.read1 s0 i0_ref in
      let bs = dest_bytes1 r.ret2 in
      (* create a new array, of length len, with same contents *)
      let bs' = MyDynArray.resize bs len in
      let s0 = ops.write1 s0 i0_ref bs' in
      put_state' s0))
  let (_:ty_ops' -> res_name' -> int -> ret_value ty_mymonad') = truncate

  let unlink ops rpath = (
    get_state >>= fun s0 ->
    match rpath with 
    | Err2(e,_) -> (myraise e)
    | None2 _ -> (myraise ENOENT)
    | Dname2 _ -> (myraise EISDIR) (* LSB has EISDIR; POSIX requires EPERM *)
    | Fname2(d0_ref,n,i0_ref,rp) -> (
      (* FIXME for resolving a file, often useful to have dir ref as well *)
      let s0 = ops.unlink1 s0 d0_ref n in
      put_state' s0))

  (* FIXME we need to make this take an offset in order to be usable, also read *)
  let write ops rn ofs bs len = (
    get_state >>= fun s0 -> 
    match rn with 
    | Err2 (e,_) -> (myraise e)
    | None2 _ -> (myraise ENOENT) 
    | Dname2 _ -> (myraise ENOENT)
    | Fname2(d0_ref,n,i0_ref,rp) -> (
      choose (downto' len 0) >>= fun len ->
      let r = ops.read1 s0 i0_ref in
      let bs' = dest_bytes1 r.ret2 in
      (* want to create a new array from bs' and bs *)
      let bs'' = MyDynArray.write (bs,0,len) (bs',ofs) in
      let r = ops.write1 s0 i0_ref bs'' in
      put_state' r >>= fun _x_ -> 
      return (Int1 len)))
  let (_:ty_ops' -> res_name' -> int -> file_contents -> int -> ret_value ty_mymonad') = write

  (* FIXME this is a hack - should do lots of checking eg src is a dir *)
  (*
  let symlink ops src dst = (
    open_create ops dst >>= fun _x_ -> 
    write ops dst 0 (MyDynArray.of_string src) (String.length src) >>= fun _x_ -> 
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 dst in
    let Fname2(i0_ref,_) = rpath in
    let r = ops.set_symlink1 s0 i0_ref true in
    put_state' r)
  let (_:ty_ops' -> string -> string -> ret_value ty_mymonad') = symlink    
  *)

end

@ignore fs_spec.md
## `Fs_ops3`

This works in terms of strings; handles Err2 on resolving 

@ignore fs_spec.ml

module Fs_ops3 = struct 

  open Fs_types1
  open Resolve
  open Fs_ops2


  (* for the purposes of type-checking the following defns without spurious type vars *)
  module X3 = struct 
    type 'a ty_return3' = (X.Y.t5,'a) ty_return3
    type 'a ty_mymonad' = (X.Y.t5,'a) mymonad
    type res_name' = (X.Y.t1,X.Y.t3) res_name    
    (* type ty_ops' = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)
    type ty_ops' = (X.Y.t1,X.Y.t3,X.Y.t5) ty_ops1
  end
  open X3

(*

  let link ops src dst = (
    get_state >>= fun s0 -> 
    let rsrc = process_path ops s0.fs_state4 s0.cwd4 src in
    let rdst = process_path ops s0.fs_state4 s0.cwd4 dst in
    Fs_ops2.link ops rsrc rdst)

  let mkdir ops path perms = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.mkdir ops rpath perms)

  let _open ops path flags = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    match rpath with
    | None2 _ -> (myraise ENOENT)
    | Dname2(_,_) -> (myraise ENOENT) (* FIXME should be EISDIR? can we open a dir? *)
    | _ -> (return None1)) (* FIXME err case should raise an err? *)
  let (_:ty_ops' -> string -> 'a -> ret_value ty_mymonad') = _open
 
  (* open call returns an fd; but may have side effects; open create is one such call; FIXME what are others? *)
  let open_create ops path = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.open_create ops rpath)

  (* N.B. for read and write ofs is associated with fd, so presumably < len of file *)
  let read ops path ofs len = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.read ops rpath ofs len)
  
  let readdir ops path = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.readdir ops rpath)

  (* FIXME check do_rename against ops2.rename; also check against doc in linux sys programming *)
  let rename ops src dst = (
    get_state >>= fun s0 -> 
    let rsrc = process_path ops s0 src in
    let rdst = process_path ops s0 dst in
    Fs_ops2.rename ops rsrc rdst)
  let (_:ty_ops' -> string -> string -> ret_value ty_mymonad') = rename

  let rmdir ops path = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.rmdir ops rpath)

  let stat ops path = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.stat ops rpath)

  let truncate ops path len = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.truncate ops rpath len)

  let unlink ops path = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.unlink ops rpath)

  let write ops path ofs bs len = (
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 path in
    if (is_Err2 rpath) then (myraise ENOTDIR) else Fs_ops2.write ops rpath ofs bs len)

  (* FIXME this is a hack - should do lots of checking eg src is a dir *)
  let symlink ops src dst = (
    open_create ops dst >>= fun _ -> 
    write ops dst 0 (MyDynArray.of_string src) (String.length src) >>= fun _ -> 
    get_state >>= fun s0 ->
    let rpath = process_path ops s0 dst in
    let Fname2(i0_ref,_) = rpath in
    let r = ops.set_symlink1 s0 i0_ref true in
    put_state' r)
  let (_:ty_ops' -> string -> string -> ret_value ty_mymonad') = symlink    

*)

end


@fs_spec.md
## Fs transition system

The model is of a labelled transition system from state to state, but
where each transition may result in a return to userland (of a value
or an error). FIXME need to be non-determinisitic eg in write and read
behaviour.

@fs_spec.ml

module Fs_transition_system = struct

  open Prelude 
  open Fs_types1
  open Fs_ops2
  (* open Fs_ops3 *)

  module X4 = struct 
    (* for the purposes of type-checking the following defns without spurious type vars *)
    (* type ty_ops' = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)
    type ty_ops' = (X.Y.t1,X.Y.t3,X.Y.t5) ty_ops1
    type state' = X.Y.t5
    type ty_fs_label' = (X.Y.t1,X.Y.t3) ty_fs_label
  end
  open X4

  (* the transition function takes a state, a label, and returns an updated state with a possible value returned, or an error *)
  (* FIXME readlink is just read, but may want to have a separate label *)
  let fs_trans ops s0 lbl = (
    (* let _ = print_endline (string_of_label lbl) in *)
    let m = (match lbl with 
      | FS_LINK (s,d) -> (link ops s d)
      | FS_MKDIR (s,p) -> (mkdir ops s p)
      | FS_OPEN (p,fs) -> (
          if (List.mem O_CREAT fs) then (open_create ops p (* FIXME fs *)) 
          else (o_open ops p fs))
      | FS_READ (p,i,j) -> (read ops p i j)
      | FS_READDIR p -> (readdir ops p)
      | FS_RENAME (s,d) -> (rename ops s d)
      | FS_RMDIR p -> (rmdir ops p)
      | FS_STAT p -> (stat ops p)
      | FS_SYMLINK (s,d) -> failwith "FIXME" (* (symlink ops s d) *)
      | FS_TRUNCATE (p,l) -> (truncate ops p l)
      | FS_UNLINK p -> (unlink ops p)
      | FS_WRITE (p,ofs,bs,len) -> (write ops p ofs bs len))
    in
    let rs = run_mymonad m s0 in
    let f1 ve = (match ve with
      | Inl(s,e) -> (s,Inl e)
      | Inr(s,v) -> (s,Inr v))
    in
    let rs = List.map f1 rs in
    rs)
  let (_:ty_ops' -> state' -> ty_fs_label' -> (state' * (error,ret_value)sum) finset) = fs_trans

  (* convenience method to process a label; always choose first possible result (state,e+v) *)
  let process_label ops s0 lbl = (
    let rs = fs_trans ops s0 lbl in
    let _ = if rs = finset_empty then failwith "process_label: no result state" else () in
    let (s',v) = finset_choose rs in
    (s',v))
  
  (* convenience method to process a list of labels *)
  let process_labels ops s0 lbls = (
    let f1 = (fun xs -> fun lbl -> 
      let l = last xs in
      let (_,_,(s,_)) = l in
      let (s',v) = process_label ops s lbl in
      xs@[(List.length xs,lbl,(s',v))])
    in
    let dummy_lbl = FS_STAT(Err2(EINVAL, { ns2=["dummy lbl"] })) in
    let dummy_error_or_value = Inr None1 in
    List.fold_left f1 [(0,dummy_lbl,(s0,dummy_error_or_value))] lbls)
  let (_:ty_ops' -> state' -> ty_fs_label' list -> (int * ty_fs_label' * (state' * (error,ret_value)sum)) list) = process_labels

end

@fs_spec.md
## OS transition system

The model of transitions at the operating system level is:

  * A call gets made with OS_CALL label

  * The process gets moved to a blocked state

  * Further steps process the call
 
  * A return transition occurs with OS_RETURN; at this point, the process is unblocked

@fs_spec.ml

module Os_transition_system = struct

  open Prelude 
  open Fs_types1
  open Fs_transition_system

  let process_path = Resolve.process_path

  module X5 = struct 
    (* for the purposes of type-checking the following defns without spurious type vars *)
    (* type ty_ops' = (X.Y.t1,X.Y.t2,X.Y.t3,X.Y.t4,X.Y.t5) ty_state_ops *)
    type ty_ops' = (X.Y.t1,X.Y.t3,X.Y.t5) ty_ops1
    type os_state' = (X.Y.t1,X.Y.t3,X.Y.t5) ty_os_state
  end
  open X5

  (* s0 is impl state *)
  let fs_lbl_of ops s0 cwd lbl = (
    let pp = process_path ops s0 cwd in
     match lbl with
    | LINK (s,d) -> (FS_LINK(pp s, pp d))
    | MKDIR (s,p) -> (FS_MKDIR(pp s, p))
    | OPEN (p,fs) -> (FS_OPEN(pp p, fs))
    | READ (p,i,j) -> (FS_READ(pp p, i, j))
    | READDIR p -> (FS_READDIR(pp p))
    | RENAME (s,d) -> (FS_RENAME(pp s, pp d))
    | RMDIR p -> (FS_RMDIR(pp p))
    | STAT p -> (FS_STAT(pp p))
    | SYMLINK (s,d) -> failwith "FIXME" (* (symlink ops s d) *)
    | TRUNCATE (p,l) -> (FS_TRUNCATE(pp p,l))
    | UNLINK p -> (FS_UNLINK(pp p))
    | WRITE (p,ofs,bs,len) -> (FS_WRITE(pp p,ofs,bs,len)))

  (* we return a finite set of possible next states; FIXME should we have functions to decompose and recompose hosts etc without doing everything manually? *)
  let os_trans_pid ops s0 pid lblopt = (
    match (fmap_lookup s0.pid_table pid) with | None -> (failwith "os_trans: impossible")
    | Some ppstate -> (
      let cwd = ppstate.cwd in
      match (ppstate.pid_run_state,lblopt) with 
      | (RUNNING,Some(OS_CALL(pid',lbl))) -> (
        if (pid' <> pid) then finset_empty
        else (
          let lbl = fs_lbl_of ops s0.fs_state cwd lbl in
          let ppstate' = { ppstate with pid_run_state = BLOCKED_CALL(lbl) } in
          let s0 = { s0 with pid_table=(fmap_update s0.pid_table (pid,ppstate')) } in
          finset_singleton s0))
      | (BLOCKED_CALL(lbl),None) -> (
        let fs_s0 = s0.fs_state in
        let next_fs_states = fs_trans ops fs_s0 lbl in
        let f1 (fs_s0',ev) = (
          let ppstate' = { ppstate with pid_run_state = PENDING_RETURN(ev) } in
          { s0 with fs_state=fs_s0'; pid_table=(fmap_update s0.pid_table (pid,ppstate')) })
        in
        finset_image f1 next_fs_states)
      | (PENDING_RETURN(ev),Some(OS_RETURN(pid',ev'))) -> (
        if (pid' <> pid) then finset_empty 
        else if (ev' <> ev) then finset_empty
        else (
          let ppstate' = { ppstate with pid_run_state = RUNNING } in
          let s0 = { s0 with pid_table=(fmap_update s0.pid_table (pid,ppstate')) } in
          finset_singleton s0))
      | (RUNNING,None) -> (finset_singleton s0)
      | (_,_) -> finset_empty))
  let (_:ty_ops' -> os_state' -> ty_pid -> os_label option -> os_state' finset) = os_trans_pid

  let create_pid ops s0 pid = { 
    cwd=(dest_Some (ops.get_root1 s0)); 
    fd_table=fmap_empty; 
    dh_table=fmap_empty; 
    pid_run_state=RUNNING 
  }

  let os_trans_pcreate_destroy ops s0 lblopt = (
    match lblopt with | None -> finset_empty
    | Some lbl -> (
      match lbl with
      | OS_CREATE(pid) -> (
        if finset_mem pid (fmap_dom s0.pid_table) then 
          finset_empty
        else (
          let s0 = { s0 with pid_table=(fmap_update s0.pid_table (pid,create_pid ops s0.fs_state pid)) } in
          finset_singleton s0))
      | OS_DESTROY(pid) -> (
        if not (finset_mem pid (fmap_dom s0.pid_table)) then 
          finset_empty
        else (
          let ppstate = dest_Some (fmap_lookup s0.pid_table pid) in
          match ppstate.pid_run_state with 
          | RUNNING -> (
            let s0 = { s0 with pid_table=(fmap_remove s0.pid_table pid) } in
            finset_singleton s0)
          | _ -> finset_empty (* we don't allow processes to be destroyed if they are in kernel *)))
      | _ -> finset_empty))
            
  (* assumes pid is in host pid_table *)
  let os_trans ops s0 lblopt = (
    (* process transitions *)
    let pids = fmap_dom s0.pid_table in
    let ss = finset_image (fun pid -> os_trans_pid ops s0 pid lblopt) pids in
    let ss = finset_bigunion ss in
    (* create/ destroy transitions *)
    let ss = finset_union ss (os_trans_pcreate_destroy ops s0 lblopt) in
    ss)
  let (_:ty_ops' -> os_state' -> os_label option -> os_state' finset) = os_trans


  (* convenience method to process a label; always choose first possible result (state,e+v) *)
  let os_process_label ops s0 lblopt = (
    let rs = os_trans ops s0 lblopt in
    let _ = if rs = finset_empty then failwith "os_process_label: no result state" else () in
    let s' = finset_choose rs in
    s')

  (* convenience method to process a list of labels *)
  let os_process_labels ops s0 lbls = (
    let f1 = (fun xs -> fun lbl -> 
      let l = last xs in
      let (_,_,s) = l in
      let s' = os_process_label ops s lbl in
      xs@[(List.length xs,lbl,s')])
    in
    let dummy_lbl = None in
    List.fold_left f1 [(0,dummy_lbl,s0)] lbls)
  let (_:ty_ops' -> os_state' -> os_label option list -> (int * os_label option * os_state') list) = os_process_labels

end


@fs_spec.md
## `Fs_spec_everything`
@fs_spec.ml

module Fs_spec_everything = struct

  include Fs_prelude
  include Prelude
(*  include File_utils *)
  include Fs_types1
(*  include Lift *)
(*  include Common *)
(*  include Fs_ops1 *)
  include Resolve
  include Fs_ops2
(*  include Fs_ops3 *)
  include Fs_transition_system
  include Os_transition_system

end

@fs_spec.md
## Debug
@fs_spec.ml
(* FIXME do we need to generalize this over ops? yes probably *)
module Debug = struct
  
  open Prelude
  open Fs_types1

(*
  let string_of_entry e = (
    let i = (match e with
    | Inl dref -> (string_of_int (dest_dir_ref dref))
    | Inr iref -> (string_of_int (dest_inode_ref iref)))
    in
    "("^i^")")
*)

  let rec string_of_dir ops s0 dirname d0_ref = (
    let Names1(ns) = (ops.readdir1 s0 d0_ref).ret2 in
    let is_file ops s0 d0_ref n = (
      let Some(e) = ops.resolve11 s0 d0_ref n in
      is_inode_ref_entry e)
    in
    let is_dir ops s0 d0_ref n = (not (is_file ops s0 d0_ref n)) in
    let this_dir = (String.concat "\n" (List.map (fun n -> n) ns)) in    
    let this_dir = if ns <> [] then this_dir ^ "\n" else this_dir in
    let other_dirs = List.filter (fun n -> is_dir ops s0 d0_ref n) ns in
    let f1 n = (
      let Some(e) = ops.resolve11 s0 d0_ref n in
      let d1_ref = dest_dir_ref_entry e in
      string_of_dir ops s0 (dirname ^ "/" ^ n) d1_ref)
    in
    let others = List.map f1 other_dirs in
    "Directory "^dirname^":\n"
    ^ this_dir
    ^ (String.concat "" others))
    
  (* assume no cycles *)
  let string_of_state ops s = (
    let Some(d0_ref) = ops.get_root1 s in
    (string_of_dir ops s "/" d0_ref))

end



@test write

let s0 = state0
let s = s0
let lbl = OPEN("/tmp.txt",[O_CREAT])
let (s,Inr _) = trans s lbl
let lbl = WRITE("/tmp.txt",0,MyDynArray.of_string "hello",5)
let (s,Inr _) = trans s lbl
let lbl = READ("/tmp.txt",0,5)
let (s,Inr(Bytes1(bs))) = trans s lbl
let _ = MyDynArray.to_string bs


@test rename

open Fs_spec_everything;;

let s0 = DummyFs.state0
let s = s0
let (s,Inr _) = trans s (OPEN("/tom.txt",[O_CREAT]))
let _ = print_endline (string_of_state s)
let (s,Inr _) = trans s (RENAME("/tom.txt","/jen.txt"))
let _ = print_endline (string_of_state s)

let s0 = DummyFs.state0
let s = s0
let (s,Inr _) = trans s (OPEN("/tom.txt",[O_CREAT]))
let _ = print_endline (string_of_state s)
let r = Fs_ops1.mv s (Dir_ref 0,get_dir s (Dir_ref 0)) "tom.txt" (Dir_ref 0,get_dir s (Dir_ref 0)) "jen.txt"
let s = r.state2
let _ = print_endline (string_of_state s)




@test symlink

let s0 = DummyFs.state0
let s = s0
let (s,Inr _) = trans s (SYMLINK("tom.txt","/jen.txt"))


@test include

module A = struct
  type t = int
end

module B = struct
  type t = A.t
end

module C = struct
  include A 
  include B
end

(* fix: since these are only for type checking, we simply need to wrap them in a module defn and open them, rather than declaring them; the names of the dummy modules must be unique *)

module A = struct
  module D = struct end
end

module B = struct
  module D = struct end
end

module C = struct
  include A 
  include B
end


@fs_spec_extras.ml

(* interactive:

    #require "sha";;

*)

open Fs_prelude
open Fs_spec

module Extra_ops = struct

  open Prelude
  open Fs_types1

  let process_label = Fs_transition_system.process_label
  let process_path_from_root = Resolve.process_path_from_root

(*
  let kind_of_inode ops s0 i0 = (
    if (ops.get_symlink i0) then S_LNK else S_REG)
*)

  let string_of_names ns = (String.concat "/" ns)

  let string_of_res_name n = (
    let nl = name_list_of_res_name n in
    string_of_names nl.ns2)

  let kind_of_inode_ref ops s0 i0_ref = (
      if (ops.get_symlink1 s0 i0_ref) then S_LNK else S_REG)

  let kind_of_entry ops s0 e = (
    match e with 
    | Inl _ -> S_DIR
    | Inr i0_ref -> (
      kind_of_inode_ref ops s0 i0_ref))

  let kind_of_path ops s0 p = (
    let rn = process_path_from_root ops s0 p in
    match rn with
    | Dname2 _ -> S_DIR
    | Fname2(_,_,i0_ref,_) -> (kind_of_inode_ref ops s0 i0_ref)
    | _ -> (failwith ("kind_of_path, absent path: "^p)))

  let kind_of_name ops s0 d0_ref name = (
    let Some(e) = ops.resolve11 s0 d0_ref name in
    kind_of_entry ops s0 e)

  (* return a list of paths; p should point to a dir *)
  let ls_path ops s0 p = (
    let rn = process_path_from_root ops s0 p in
    let Dname2(d0_ref,_) = rn in
    let ns = name_list_of_res_name rn in
    let p = string_of_names ns.ns2 in
    let p = if p = "/" then "" else p in
    let Names1(es) = (ops.readdir1 s0 d0_ref).ret2 in
    let r = List.map (fun n -> p^"/"^n) es in
    r)

  let rec find_path ops s0 p = (
    let xs = ls_path ops s0 p in
    let ds = List.filter (fun p -> kind_of_path ops s0 p = S_DIR) xs in
    (* let xs = List.filter (fun p -> kind_of_path ops s0 p <> S_DIR) xs in *)
    let xs' = List.concat (List.map (find_path ops s0) ds) in
    xs@xs')

  let read_all ops s0 p = (
    let pp = process_path_from_root ops s0 p in
    let (_,Inr(Stats1(s))) = process_label ops s0 (FS_STAT pp) in
    let len = s.Unix.LargeFile.st_size in
    let (_,Inr(Bytes1 bs)) = process_label ops s0 (FS_READ(pp,0,(* FIXME *)Int64.to_int len)) in
    bs)

  let inode_of_path ops s0 p = (
    let pp = process_path_from_root ops s0 p in
    let (_,Inr(Stats1(s))) = process_label ops s0 (FS_STAT pp) in
    s.Unix.LargeFile.st_ino)

end


(* FIXME shouldn't this work with ops? *) (* FIXME try and remove this *)
module File_utils2 = struct 

  open Unix

  type path = string list
  
  (* in this module, filenames (lists of strings) are absolute *)
  let string_of_longfname s = "/" ^ (String.concat "/" s)
  
  (* our operations on filesystems can be parameterized in terms of ls and readlink *)
  type 'a fs_ops = {
    ls4: 'a -> path -> path list;
    kind4: 'a -> path -> file_kind;
    readlink4: 'a -> path -> string;
    inode4: 'a -> path -> int
  }
 
  let is_dir ops s d = (ops.kind4 s d = S_DIR)
    
  let is_link ops s f = (ops.kind4 s f = S_LNK)

  let is_file ops s f = (ops.kind4 s f = S_REG)
      
  (* FIXME make tail recursive, alphabetical etc *)
  let rec find ops s d = 
    let ss = ops.ls4 s d in
    let ds = List.filter (is_dir ops s) ss in
    (List.concat (List.map (find ops s) ds))@ss (* order: want leaves first *)

end

(* FIXME shouldn't this work with ops? *) (* FIXME try and remove this *)
module Unix_utils = struct

  open File_utils2
  
  let string_of_path = File_utils2.string_of_longfname
  let path_of_string s = Str.split (Str.regexp "/") s

  (* return a list of list of strings - a long filename is a list of dirs and a filename *)
  let ls d = (
    let lines = ref [] in
    let h = Unix.opendir (string_of_path d) in
    try
      while true; do
        lines := Unix.readdir h :: !lines
      done; []
    with End_of_file ->
      Unix.closedir h;
      let fs = List.map (fun s -> d@[s]) (List.filter (fun s -> not (s="." || s = "..")) (List.rev !lines)) in
      List.sort Pervasives.compare fs)
  let (_:string list -> string list list) = ls

  let kind f = (
    let open Unix.LargeFile in
    let stats = lstat (string_of_path f) in
    match stats.st_kind with 
    | Unix.S_DIR -> Unix.S_DIR
    | Unix.S_REG -> Unix.S_REG
    | Unix.S_LNK -> Unix.S_LNK
    | _ -> (failwith ("Unknown file type for file: "^(string_of_path f)))) 

  let inode f = (
    let open Unix.LargeFile in
    let stats = lstat (string_of_path f) in
    stats.st_ino)
  
  let readlink f = (
    let s = Unix.readlink (string_of_path f) in
    (* path_of_string *) s)

  let unix_ops = {
    ls4=(fun _ -> ls);
    kind4=(fun _ -> kind);
    readlink4=(fun _ -> readlink);
    inode4=(fun _ -> inode)
  }

  let is_file = File_utils2.is_file unix_ops ()
    
  let find = File_utils2.find unix_ops ()

end


(* interactive:

    #use "local_resources/p3_lib.toplevel.ml";;
    #use "local_resources/mycsv.toplevel.ml";;

*)

(* FIXME shouldn't this work with ops? *) (* FIXME try and remove this *)
module Unix_dump_fs = struct

  open Unix
  open Unix_utils
  open Mycsv
  open Sha1
 
  let sha1_of_file fname = Sha1.to_hex (Sha1.file_fast fname)

  let sha1_of_string s = Sha1.to_hex (Sha1.string s)

  let records_of_path s = (
    let p = path_of_string s in
    let fs = find p in
    let f1 f = (
      let s = string_of_path f in
      let k = kind f in
      match k with 
      | S_REG -> [s;"F";(string_of_int (inode f));(sha1_of_file s)]
      | S_DIR -> [s;"D"]
      | S_LNK -> [s;"L";(readlink f)]
      | _ -> failwith "main")
    in
    let ss = List.map f1 fs in
    ss)

(*
  let fs = find ["tmp";"a"]
  let fs = List.filter is_file fs 
  let _ = List.map (fun f -> (string_of_path f,inode_of_file f, sha1_of_file (string_of_path f))) fs

  let _ = sha1_of_file "/mnt/sda7/tom/downloads/ubuntu/xubuntu-12.04.2-desktop-i386.iso"

  let fs = find ["tmp"]

  let _ = sha1_of_file "/tmp/a/tom.txt"
  let _ = sha1_of_file "/tmp/a/jen.txt"
*)

end


module Dump_fs = struct

  open Prelude
  open Fs_types1
  open Sha1
 
  let sha1_of_string s = Sha1.to_hex (Sha1.string s)

  (* sha1 of contents of file *)
  let sha1_of_path ops s0 p = (
    let bs = Extra_ops.read_all ops s0 p in
    let s = MyDynArray.to_string bs in
    sha1_of_string s)

  let find = Extra_ops.find_path
  let kind = Extra_ops.kind_of_path
  let inode_of_path = Extra_ops.inode_of_path

  (* we need to maintain a map of inodes that we have already seen, so we can update them as we go; we maintain a counter c from 1, and insert (inode,c++) into map when meeting new inode *)
  (* note this ordering is sensitive to the order of the paths ps! *)
  let get_normalized_inodes ops s0 ps = (
    let f1 (c,m,sofar) p = (
      (* check whether p's inode has already been seen *)
      let i = inode_of_path ops s0 p in
      match (fmap_lookup m i) with
      | None -> (
        let m' = fmap_update m (i,c) in
        (c+1,m',fmap_update sofar (p,c)))
      | Some i' -> (
        (c,m,fmap_update sofar (p,i'))))
    in
    let (_,_,ips) = List.fold_left f1 (1,fmap_empty,fmap_empty) ps in
    ips)

  let records_of_path ops s0 s = (
    let ps = find ops s0 s in
    let fps = List.filter (fun p -> Extra_ops.kind_of_path ops s0 p = S_REG) ps in
    let inodes_map = get_normalized_inodes ops s0 fps in
    let f1 p = (
      let k = kind ops s0 p in
      match k with 
      | S_REG -> [p;"F";(string_of_int (dest_Some (fmap_lookup inodes_map p)));(sha1_of_path ops s0 p)]
      | S_DIR -> [p;"D"]
      | S_LNK -> [p;"L";(MyDynArray.to_string (Extra_ops.read_all ops s0 p))]
      | _ -> failwith "main")
    in
    let ss = List.map f1 ps in
    ss)

  (* convert to csv data *)
  let dump_of_path ops s0 p = (
    let open Mycsv in
    let rs = records_of_path ops s0 p in
    let params = { sep="|"; outsep="|"; newline="\n"; dquote="\"" } in
    let s = String.concat "" (List.map (format params None1 rs) rs) in
    s)


(*

  #use "unix_impl.toplevel.ml";;
  let ops = Unix_impl.Unix_impl_everything.ops1
  let s0 = Unix_impl.Unix_impl_everything.state0
  let _ = records_of_path ops s0 "/"
  let _ = print_endline(dump_of_path ops s0 "/")
 
*)

end


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ignore
# Local variables

Local Variables:
mode: tuareg
mode: hi-lock
mode: outline-minor
outline-regexp: "@\\|#+"
End:

